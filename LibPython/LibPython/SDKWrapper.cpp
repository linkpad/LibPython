/* This file was generated by PyBindGen 0.0.0.0 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>
#include "SDKWrapper.h"

#if PY_VERSION_HEX < 0x020400F0

#define PyEval_ThreadsInitialized() 1

#define Py_CLEAR(op)				\
        do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
				                }				\
		        } while (0)


#define Py_VISIT(op)							\
        do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
				                }							\
		        } while (0)

#endif



#if PY_VERSION_HEX < 0x020500F0

typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;

#endif


#ifndef PyVarObject_HEAD_INIT
#define PyVarObject_HEAD_INIT(type, size) \
        PyObject_HEAD_INIT(type) size,
#endif


#if PY_VERSION_HEX >= 0x03000000
typedef void* cmpfunc;
#define PyCObject_FromVoidPtr(a, b) PyCapsule_New(a, NULL, b)
#define PyCObject_AsVoidPtr(a) PyCapsule_GetPointer(a, NULL)
#define PyString_FromString(a) PyBytes_FromString(a)
#define Py_TPFLAGS_CHECKTYPES 0 /* this flag doesn't exist in python 3 */
#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param) param
#endif  /* !__GNUC__ */

#ifndef _PyBindGenWrapperFlags_defined_
#define _PyBindGenWrapperFlags_defined_
//typedef enum _PyBindGenWrapperFlags {
//	PYBINDGEN_WRAPPER_FLAG_NONE = 0,
//	PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED = (1 << 0),
//} PyBindGenWrapperFlags;
#endif


#include "PluginSDK.h"
/* --- forward declarations --- */


typedef struct {
	PyObject_HEAD
		std::vector<Vec2> *obj;
} Pystd__vector__lt__Vec2__gt__;


typedef struct {
	PyObject_HEAD
		Pystd__vector__lt__Vec2__gt__ *container;
	std::vector<Vec2>::iterator *iterator;
} Pystd__vector__lt__Vec2__gt__Iter;


extern PyTypeObject Pystd__vector__lt__Vec2__gt___Type;
extern PyTypeObject Pystd__vector__lt__Vec2__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___Vec2___gt__(PyObject *arg, std::vector<Vec2> *container);

typedef struct {
	PyObject_HEAD
		std::vector<Vec3> *obj;
} Pystd__vector__lt__Vec3__gt__;


typedef struct {
	PyObject_HEAD
		Pystd__vector__lt__Vec3__gt__ *container;
	std::vector<Vec3>::iterator *iterator;
} Pystd__vector__lt__Vec3__gt__Iter;


extern PyTypeObject Pystd__vector__lt__Vec3__gt___Type;
extern PyTypeObject Pystd__vector__lt__Vec3__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___Vec3___gt__(PyObject *arg, std::vector<Vec3> *container);

typedef struct {
	PyObject_HEAD
		std::vector<IUnit*> *obj;
} Pystd__vector__lt__IUnit__star____gt__;


typedef struct {
	PyObject_HEAD
		Pystd__vector__lt__IUnit__star____gt__ *container;
	std::vector<IUnit*>::iterator *iterator;
} Pystd__vector__lt__IUnit__star____gt__Iter;


extern PyTypeObject Pystd__vector__lt__IUnit__star____gt___Type;
extern PyTypeObject Pystd__vector__lt__IUnit__star____gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___IUnit___star_____gt__(PyObject *arg, std::vector<IUnit*> *container);

typedef struct {
	PyObject_HEAD
		std::vector<ItemData> *obj;
} Pystd__vector__lt__ItemData__gt__;


typedef struct {
	PyObject_HEAD
		Pystd__vector__lt__ItemData__gt__ *container;
	std::vector<ItemData>::iterator *iterator;
} Pystd__vector__lt__ItemData__gt__Iter;


extern PyTypeObject Pystd__vector__lt__ItemData__gt___Type;
extern PyTypeObject Pystd__vector__lt__ItemData__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___ItemData___gt__(PyObject *arg, std::vector<ItemData> *container);

typedef struct {
	PyObject_HEAD
		std::vector<HeroMastery> *obj;
} Pystd__vector__lt__HeroMastery__gt__;


typedef struct {
	PyObject_HEAD
		Pystd__vector__lt__HeroMastery__gt__ *container;
	std::vector<HeroMastery>::iterator *iterator;
} Pystd__vector__lt__HeroMastery__gt__Iter;


extern PyTypeObject Pystd__vector__lt__HeroMastery__gt___Type;
extern PyTypeObject Pystd__vector__lt__HeroMastery__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___HeroMastery___gt__(PyObject *arg, std::vector<HeroMastery> *container);

typedef struct {
	PyObject_HEAD
		std::vector<std::string> *obj;
} Pystd__vector__lt__std__string__gt__;


typedef struct {
	PyObject_HEAD
		Pystd__vector__lt__std__string__gt__ *container;
	std::vector<std::string>::iterator *iterator;
} Pystd__vector__lt__std__string__gt__Iter;


extern PyTypeObject Pystd__vector__lt__std__string__gt___Type;
extern PyTypeObject Pystd__vector__lt__std__string__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___std__string___gt__(PyObject *arg, std::vector<std::string> *container);

typedef struct {
	PyObject_HEAD
		std::vector<eGameObjectClassId> *obj;
} Pystd__vector__lt__eGameObjectClassId__gt__;


typedef struct {
	PyObject_HEAD
		Pystd__vector__lt__eGameObjectClassId__gt__ *container;
	std::vector<eGameObjectClassId>::iterator *iterator;
} Pystd__vector__lt__eGameObjectClassId__gt__Iter;


extern PyTypeObject Pystd__vector__lt__eGameObjectClassId__gt___Type;
extern PyTypeObject Pystd__vector__lt__eGameObjectClassId__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___eGameObjectClassId___gt__(PyObject *arg, std::vector<eGameObjectClassId> *container);

PyObject* _wrap_convert_c2py__Vec2(Vec2 *cvalue);


int _wrap_convert_py2c__Vec2(PyObject *value, Vec2 *address);


int _wrap_convert_py2c__float(PyObject *value, float *address);


PyObject* _wrap_convert_c2py__Vec3(Vec3 *cvalue);


int _wrap_convert_py2c__Vec3(PyObject *value, Vec3 *address);


PyObject* _wrap_convert_c2py__Vec4(Vec4 *cvalue);


int _wrap_convert_py2c__Vec4(PyObject *value, Vec4 *address);


int _wrap_convert_py2c__IUnit___star__(PyObject *value, IUnit * *address);


int _wrap_convert_py2c__ItemData(PyObject *value, ItemData *address);


int _wrap_convert_py2c__HeroMastery(PyObject *value, HeroMastery *address);


int _wrap_convert_py2c__std__string(PyObject *value, std::string *address);


int _wrap_convert_py2c__eGameObjectClassId(PyObject *value, eGameObjectClassId *address);

/* --- module functions --- */


PyObject *
_wrap_SDK_GTargetSelector()
{
	PyObject *py_retval;
	ITargetSelector *retval;
	PyITargetSelector *py_ITargetSelector;

	retval = GTargetSelector;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_ITargetSelector = PyObject_New(PyITargetSelector, &PyITargetSelector_Type);
	py_ITargetSelector->obj = retval;
	py_ITargetSelector->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_ITargetSelector);
	return py_retval;
}
PyObject * _wrap_SDK_GTargetSelector();


PyObject *
_wrap_SDK_GOrbwalking()
{
	PyObject *py_retval;
	IOrbwalking *retval;
	PyIOrbwalking *py_IOrbwalking;

	retval = GOrbwalking;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IOrbwalking = PyObject_New(PyIOrbwalking, &PyIOrbwalking_Type);
	py_IOrbwalking->obj = retval;
	py_IOrbwalking->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IOrbwalking);
	return py_retval;
}
PyObject * _wrap_SDK_GOrbwalking();


PyObject *
_wrap_SDK_GDamage()
{
	PyObject *py_retval;
	IDamage *retval;
	PyIDamage *py_IDamage;

	retval = GDamage;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IDamage = PyObject_New(PyIDamage, &PyIDamage_Type);
	py_IDamage->obj = retval;
	py_IDamage->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IDamage);
	return py_retval;
}
PyObject * _wrap_SDK_GDamage();


PyObject *
_wrap_SDK_GRender()
{
	PyObject *py_retval;
	IRender *retval;
	PyIRender *py_IRender;

	retval = GRender;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IRender = PyObject_New(PyIRender, &PyIRender_Type);
	py_IRender->obj = retval;
	py_IRender->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IRender);
	return py_retval;
}
PyObject * _wrap_SDK_GRender();


PyObject *
_wrap_SDK_GHealthPrediction()
{
	PyObject *py_retval;
	IHealthPrediction *retval;
	PyIHealthPrediction *py_IHealthPrediction;

	retval = GHealthPrediction;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IHealthPrediction = PyObject_New(PyIHealthPrediction, &PyIHealthPrediction_Type);
	py_IHealthPrediction->obj = retval;
	py_IHealthPrediction->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IHealthPrediction);
	return py_retval;
}
PyObject * _wrap_SDK_GHealthPrediction();


PyObject *
_wrap_SDK_GNavMesh()
{
	PyObject *py_retval;
	INavMesh *retval;
	PyINavMesh *py_INavMesh;

	retval = GNavMesh;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_INavMesh = PyObject_New(PyINavMesh, &PyINavMesh_Type);
	py_INavMesh->obj = retval;
	py_INavMesh->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_INavMesh);
	return py_retval;
}
PyObject * _wrap_SDK_GNavMesh();


PyObject *
_wrap_SDK_GMissileData()
{
	PyObject *py_retval;
	IMissileData *retval;
	PyIMissileData *py_IMissileData;

	retval = GMissileData;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMissileData = PyObject_New(PyIMissileData, &PyIMissileData_Type);
	py_IMissileData->obj = retval;
	py_IMissileData->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMissileData);
	return py_retval;
}
PyObject * _wrap_SDK_GMissileData();


PyObject *
_wrap_SDK_GPrediction()
{
	PyObject *py_retval;
	IPrediction *retval;
	PyIPrediction *py_IPrediction;

	retval = GPrediction;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IPrediction = PyObject_New(PyIPrediction, &PyIPrediction_Type);
	py_IPrediction->obj = retval;
	py_IPrediction->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IPrediction);
	return py_retval;
}
PyObject * _wrap_SDK_GPrediction();


PyObject *
_wrap_SDK_GGame()
{
	PyObject *py_retval;
	IGame *retval;
	PyIGame *py_IGame;

	retval = GGame;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IGame = PyObject_New(PyIGame, &PyIGame_Type);
	py_IGame->obj = retval;
	py_IGame->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IGame);
	return py_retval;
}
PyObject * _wrap_SDK_GGame();


PyObject *
_wrap_SDK_GEntityList()
{
	PyObject *py_retval;
	IEntityList *retval;
	PyIEntityList *py_IEntityList;

	retval = GEntityList;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IEntityList = PyObject_New(PyIEntityList, &PyIEntityList_Type);
	py_IEntityList->obj = retval;
	py_IEntityList->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IEntityList);
	return py_retval;
}
PyObject * _wrap_SDK_GEntityList();


PyObject *
_wrap_SDK_GPluginSDK()
{
	PyObject *py_retval;
	IPluginSDK *retval;
	PyIPluginSDK *py_IPluginSDK;

	retval = GPluginSDK;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IPluginSDK = PyObject_New(PyIPluginSDK, &PyIPluginSDK_Type);
	py_IPluginSDK->obj = retval;
	py_IPluginSDK->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IPluginSDK);
	return py_retval;
}
PyObject * _wrap_SDK_GPluginSDK();


PyObject *
_wrap_SDK_GUtility()
{
	PyObject *py_retval;
	IUtility *retval;
	PyIUtility *py_IUtility;

	retval = GUtility;
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUtility = PyObject_New(PyIUtility, &PyIUtility_Type);
	py_IUtility->obj = retval;
	py_IUtility->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUtility);
	return py_retval;
}
PyObject * _wrap_SDK_GUtility();

static PyMethodDef SDK_functions[] = {
	{ (char *) "GTargetSelector", (PyCFunction)_wrap_SDK_GTargetSelector, METH_NOARGS, "GTargetSelector()\n\n" },
	{ (char *) "GOrbwalking", (PyCFunction)_wrap_SDK_GOrbwalking, METH_NOARGS, "GOrbwalking()\n\n" },
	{ (char *) "GDamage", (PyCFunction)_wrap_SDK_GDamage, METH_NOARGS, "GDamage()\n\n" },
	{ (char *) "GRender", (PyCFunction)_wrap_SDK_GRender, METH_NOARGS, "GRender()\n\n" },
	{ (char *) "GHealthPrediction", (PyCFunction)_wrap_SDK_GHealthPrediction, METH_NOARGS, "GHealthPrediction()\n\n" },
	{ (char *) "GNavMesh", (PyCFunction)_wrap_SDK_GNavMesh, METH_NOARGS, "GNavMesh()\n\n" },
	{ (char *) "GMissileData", (PyCFunction)_wrap_SDK_GMissileData, METH_NOARGS, "GMissileData()\n\n" },
	{ (char *) "GPrediction", (PyCFunction)_wrap_SDK_GPrediction, METH_NOARGS, "GPrediction()\n\n" },
	{ (char *) "GGame", (PyCFunction)_wrap_SDK_GGame, METH_NOARGS, "GGame()\n\n" },
	{ (char *) "GEntityList", (PyCFunction)_wrap_SDK_GEntityList, METH_NOARGS, "GEntityList()\n\n" },
	{ (char *) "GPluginSDK", (PyCFunction)_wrap_SDK_GPluginSDK, METH_NOARGS, "GPluginSDK()\n\n" },
	{ (char *) "GUtility", (PyCFunction)_wrap_SDK_GUtility, METH_NOARGS, "GUtility()\n\n" },
	{ NULL, NULL, 0, NULL }
};
/* --- classes --- */


static PyObject* _wrap_PyVec2__get_x(PyVec2 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->x);
	return py_retval;
}
static int _wrap_PyVec2__set_x(PyVec2 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->x)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyVec2__get_y(PyVec2 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->y);
	return py_retval;
}
static int _wrap_PyVec2__set_y(PyVec2 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->y)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyVec2__getsets[] = {
	{
		(char*) "y", /* attribute name */
		(getter)_wrap_PyVec2__get_y, /* C function to get the attribute */
		(setter)_wrap_PyVec2__set_y, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "x", /* attribute name */
		(getter)_wrap_PyVec2__get_x, /* C function to get the attribute */
		(setter)_wrap_PyVec2__set_x, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyVec2__tp_init__0(PyVec2 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyVec2 *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec2(*((PyVec2 *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyVec2__tp_init__1(PyVec2 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec2();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyVec2__tp_init__2(PyVec2 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	float x;
	float y;
	const char *keywords[] = { "x", "y", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ff", (char **)keywords, &x, &y)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec2(x, y);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyVec2__tp_init(PyVec2 *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[3] = { 0, };
	retval = _wrap_PyVec2__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyVec2__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	retval = _wrap_PyVec2__tp_init__2(self, args, kwargs, &exceptions[2]);
	if (!exceptions[2]) {
		Py_DECREF(exceptions[0]);
		Py_DECREF(exceptions[1]);
		return retval;
	}
	error_list = PyList_New(3);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
	Py_DECREF(exceptions[2]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


PyObject *
_wrap_PyVec2_VectorNormalize(PyVec2 *self)
{
	PyObject *py_retval;
	PyVec2 *py_Vec2;

	Vec2 & retval = self->obj->VectorNormalize();
	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}


PyObject *
_wrap_PyVec2_Compare(PyVec2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec2 *a;
	const char *keywords[] = { "a", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &a)) {
		return NULL;
	}
	retval = self->obj->Compare(*((PyVec2 *)a)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyVec2_Set(PyVec2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float x;
	float y;
	const char *keywords[] = { "x", "y", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ff", (char **)keywords, &x, &y)) {
		return NULL;
	}
	self->obj->Set(x, y);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyVec2_Extend(PyVec2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *Other;
	float Len;
	const char *keywords[] = { "Other", "Len", NULL };
	PyVec2 *py_Vec2;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!f", (char **)keywords, &PyVec2_Type, &Other, &Len)) {
		return NULL;
	}
	Vec2 retval = self->obj->Extend(*((PyVec2 *)Other)->obj, Len);
	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}


PyObject *
_wrap_PyVec2_Length(PyVec2 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Length();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyVec2_Zero(PyVec2 *self)
{
	PyObject *py_retval;

	self->obj->Zero();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyVec2_DotProduct(PyVec2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyVec2 *vecOther;
	const char *keywords[] = { "vecOther", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &vecOther)) {
		return NULL;
	}
	retval = self->obj->DotProduct(*((PyVec2 *)vecOther)->obj);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


static PyObject*
_wrap_PyVec2__copy__(PyVec2 *self)
{

	PyVec2 *py_copy;
	py_copy = PyObject_New(PyVec2, &PyVec2_Type);
	py_copy->obj = new Vec2(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyVec2_methods[] = {
	{ (char *) "VectorNormalize", (PyCFunction)_wrap_PyVec2_VectorNormalize, METH_NOARGS, "VectorNormalize()\n\n" },
	{ (char *) "Compare", (PyCFunction)_wrap_PyVec2_Compare, METH_KEYWORDS | METH_VARARGS, "Compare(a)\n\ntype: a: Vec2 const &" },
	{ (char *) "Set", (PyCFunction)_wrap_PyVec2_Set, METH_KEYWORDS | METH_VARARGS, "Set(x, y)\n\ntype: x: float\ntype: y: float" },
	{ (char *) "Extend", (PyCFunction)_wrap_PyVec2_Extend, METH_KEYWORDS | METH_VARARGS, "Extend(Other, Len)\n\ntype: Other: Vec2 const\ntype: Len: float" },
	{ (char *) "Length", (PyCFunction)_wrap_PyVec2_Length, METH_NOARGS, "Length()\n\n" },
	{ (char *) "Zero", (PyCFunction)_wrap_PyVec2_Zero, METH_NOARGS, "Zero()\n\n" },
	{ (char *) "DotProduct", (PyCFunction)_wrap_PyVec2_DotProduct, METH_KEYWORDS | METH_VARARGS, "DotProduct(vecOther)\n\ntype: vecOther: Vec2 const &" },
	{ (char *) "__copy__", (PyCFunction)_wrap_PyVec2__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyVec2__tp_dealloc(PyVec2 *self)
{
	Vec2 *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyVec2__tp_richcompare(PyVec2 *PYBINDGEN_UNUSED(self), PyVec2 *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyVec2_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		if (*self->obj == *other->obj) {
			Py_INCREF(Py_True);
			return Py_True;
		}
		else {
			Py_INCREF(Py_False);
			return Py_False;
		}
	case Py_NE:
		if (*self->obj != *other->obj) {
			Py_INCREF(Py_True);
			return Py_True;
		}
		else {
			Py_INCREF(Py_False);
			return Py_False;
		}
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Vec2(Vec2 *cvalue)
{
	PyObject *py_retval;
	PyVec2 *py_Vec2;

	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2(*cvalue);
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}


int _wrap_convert_py2c__Vec2(PyObject *value, Vec2 *address)
{
	PyObject *py_retval;
	PyVec2 *tmp_Vec2;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec2_Type, &tmp_Vec2)) {
		Py_DECREF(py_retval);
		return 0;
	}
	*address = *tmp_Vec2->obj;
	Py_DECREF(py_retval);
	return 1;
}


int _wrap_convert_py2c__float(PyObject *value, float *address)
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &*address)) {
		Py_DECREF(py_retval);
		return 0;
	}
	Py_DECREF(py_retval);
	return 1;
}

static PyObject*
Vec2__nb_add(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		Vec2 right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__Vec2(py_right, &right)) {
			Vec2 result = (left + right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec2__nb_subtract(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		Vec2 right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__Vec2(py_right, &right)) {
			Vec2 result = (left - right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec2__nb_multiply(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		float right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec2 result = (left * right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec2__nb_divide(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		float right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec2 result = (left / right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec2__nb_inplace_add(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		Vec2 right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__Vec2(py_right, &right)) {
			Vec2 result = (left += right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec2__nb_inplace_subtract(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		Vec2 right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__Vec2(py_right, &right)) {
			Vec2 result = (left -= right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec2__nb_inplace_multiply(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		float right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec2 result = (left *= right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec2__nb_inplace_divide(PyObject *py_left, PyObject *py_right)
{
	{
		Vec2 left;
		Vec2 right;
		if (_wrap_convert_py2c__Vec2(py_left, &left) && _wrap_convert_py2c__Vec2(py_right, &right)) {
			Vec2 result = (left /= right);
			return _wrap_convert_c2py__Vec2(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyNumberMethods Vec2__py_number_methods = {
#if PY_VERSION_HEX < 0x03000000
	(binaryfunc)Vec2__nb_add,
	(binaryfunc)Vec2__nb_subtract,
	(binaryfunc)Vec2__nb_multiply,
	(binaryfunc)Vec2__nb_divide,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(inquiry)NULL,
	(unaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(coercion)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	/* Added in release 2.0 */
	(binaryfunc)Vec2__nb_inplace_add,
	(binaryfunc)Vec2__nb_inplace_subtract,
	(binaryfunc)Vec2__nb_inplace_multiply,
	(binaryfunc)Vec2__nb_inplace_divide,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

	/* Added in release 2.2 */
	/* The following require the Py_TPFLAGS_HAVE_CLASS flag */
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

#if PY_VERSION_HEX >= 0x020500F0
	/* Added in release 2.5 */
	(unaryfunc)NULL,

#endif
#else /* Python 3 changed this structure a lot */
	(binaryfunc)Vec2__nb_add,
	(binaryfunc)Vec2__nb_subtract,
	(binaryfunc)Vec2__nb_multiply,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(inquiry)NULL,
	(unaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(unaryfunc)NULL,
	NULL,
	(unaryfunc)NULL,

	(binaryfunc)Vec2__nb_inplace_add,
	(binaryfunc)Vec2__nb_inplace_subtract,
	(binaryfunc)Vec2__nb_inplace_multiply,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

	(binaryfunc)NULL,
	(binaryfunc)Vec2__nb_divide,
	(binaryfunc)NULL,
	(binaryfunc)Vec2__nb_inplace_divide,

	(unaryfunc)NULL,
#endif
};

PyTypeObject PyVec2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.Vec2",            /* tp_name */
	sizeof(PyVec2),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyVec2__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)&Vec2__py_number_methods,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
	"Vec2(ctor_arg)\nVec2(x, y)\nVec2()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyVec2__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyVec2_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyVec2__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyVec2__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyVec3__get_x(PyVec3 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->x);
	return py_retval;
}
static int _wrap_PyVec3__set_x(PyVec3 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->x)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyVec3__get_y(PyVec3 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->y);
	return py_retval;
}
static int _wrap_PyVec3__set_y(PyVec3 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->y)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyVec3__get_z(PyVec3 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->z);
	return py_retval;
}
static int _wrap_PyVec3__set_z(PyVec3 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->z)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyVec3__getsets[] = {
	{
		(char*) "y", /* attribute name */
		(getter)_wrap_PyVec3__get_y, /* C function to get the attribute */
		(setter)_wrap_PyVec3__set_y, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "x", /* attribute name */
		(getter)_wrap_PyVec3__get_x, /* C function to get the attribute */
		(setter)_wrap_PyVec3__set_x, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "z", /* attribute name */
		(getter)_wrap_PyVec3__get_z, /* C function to get the attribute */
		(setter)_wrap_PyVec3__set_z, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyVec3__tp_init__0(PyVec3 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyVec3 *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec3(*((PyVec3 *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyVec3__tp_init__1(PyVec3 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec3();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyVec3__tp_init__2(PyVec3 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	float x;
	float y;
	float z;
	const char *keywords[] = { "x", "y", "z", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "fff", (char **)keywords, &x, &y, &z)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec3(x, y, z);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyVec3__tp_init(PyVec3 *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[3] = { 0, };
	retval = _wrap_PyVec3__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyVec3__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	retval = _wrap_PyVec3__tp_init__2(self, args, kwargs, &exceptions[2]);
	if (!exceptions[2]) {
		Py_DECREF(exceptions[0]);
		Py_DECREF(exceptions[1]);
		return retval;
	}
	error_list = PyList_New(3);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
	Py_DECREF(exceptions[2]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


PyObject *
_wrap_PyVec3_VectorNormalize(PyVec3 *self)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	Vec3 & retval = self->obj->VectorNormalize();
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyVec3_Compare(PyVec3 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *a;
	const char *keywords[] = { "a", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &a)) {
		return NULL;
	}
	retval = self->obj->Compare(*((PyVec3 *)a)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyVec3_Set(PyVec3 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float x;
	float y;
	float z;
	const char *keywords[] = { "x", "y", "z", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "fff", (char **)keywords, &x, &y, &z)) {
		return NULL;
	}
	self->obj->Set(x, y, z);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyVec3_Length2D(PyVec3 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Length2D();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyVec3_Extend(PyVec3 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec3 *Other;
	float Len;
	const char *keywords[] = { "Other", "Len", NULL };
	PyVec3 *py_Vec3;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!f", (char **)keywords, &PyVec3_Type, &Other, &Len)) {
		return NULL;
	}
	Vec3 retval = self->obj->Extend(*((PyVec3 *)Other)->obj, Len);
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyVec3_Length(PyVec3 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Length();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyVec3_Zero(PyVec3 *self)
{
	PyObject *py_retval;

	self->obj->Zero();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyVec3_DotProduct(PyVec3 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyVec3 *vecOther;
	const char *keywords[] = { "vecOther", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &vecOther)) {
		return NULL;
	}
	retval = self->obj->DotProduct(*((PyVec3 *)vecOther)->obj);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


static PyObject*
_wrap_PyVec3__copy__(PyVec3 *self)
{

	PyVec3 *py_copy;
	py_copy = PyObject_New(PyVec3, &PyVec3_Type);
	py_copy->obj = new Vec3(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyVec3_methods[] = {
	{ (char *) "VectorNormalize", (PyCFunction)_wrap_PyVec3_VectorNormalize, METH_NOARGS, "VectorNormalize()\n\n" },
	{ (char *) "Compare", (PyCFunction)_wrap_PyVec3_Compare, METH_KEYWORDS | METH_VARARGS, "Compare(a)\n\ntype: a: Vec3 const &" },
	{ (char *) "Set", (PyCFunction)_wrap_PyVec3_Set, METH_KEYWORDS | METH_VARARGS, "Set(x, y, z)\n\ntype: x: float\ntype: y: float\ntype: z: float" },
	{ (char *) "Length2D", (PyCFunction)_wrap_PyVec3_Length2D, METH_NOARGS, "Length2D()\n\n" },
	{ (char *) "Extend", (PyCFunction)_wrap_PyVec3_Extend, METH_KEYWORDS | METH_VARARGS, "Extend(Other, Len)\n\ntype: Other: Vec3 const\ntype: Len: float" },
	{ (char *) "Length", (PyCFunction)_wrap_PyVec3_Length, METH_NOARGS, "Length()\n\n" },
	{ (char *) "Zero", (PyCFunction)_wrap_PyVec3_Zero, METH_NOARGS, "Zero()\n\n" },
	{ (char *) "DotProduct", (PyCFunction)_wrap_PyVec3_DotProduct, METH_KEYWORDS | METH_VARARGS, "DotProduct(vecOther)\n\ntype: vecOther: Vec3 const &" },
	{ (char *) "__copy__", (PyCFunction)_wrap_PyVec3__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyVec3__tp_dealloc(PyVec3 *self)
{
	Vec3 *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyVec3__tp_richcompare(PyVec3 *PYBINDGEN_UNUSED(self), PyVec3 *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyVec3_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		if (*self->obj == *other->obj) {
			Py_INCREF(Py_True);
			return Py_True;
		}
		else {
			Py_INCREF(Py_False);
			return Py_False;
		}
	case Py_NE:
		if (*self->obj != *other->obj) {
			Py_INCREF(Py_True);
			return Py_True;
		}
		else {
			Py_INCREF(Py_False);
			return Py_False;
		}
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Vec3(Vec3 *cvalue)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(*cvalue);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


int _wrap_convert_py2c__Vec3(PyObject *value, Vec3 *address)
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return 0;
	}
	*address = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 1;
}

static PyObject*
Vec3__nb_add(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		Vec3 right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__Vec3(py_right, &right)) {
			Vec3 result = (left + right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec3__nb_subtract(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		Vec3 right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__Vec3(py_right, &right)) {
			Vec3 result = (left - right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec3__nb_multiply(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		float right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec3 result = (left * right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec3__nb_divide(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		float right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec3 result = (left / right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec3__nb_inplace_add(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		Vec3 right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__Vec3(py_right, &right)) {
			Vec3 result = (left += right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec3__nb_inplace_subtract(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		Vec3 right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__Vec3(py_right, &right)) {
			Vec3 result = (left -= right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec3__nb_inplace_multiply(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		float right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec3 result = (left *= right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec3__nb_inplace_divide(PyObject *py_left, PyObject *py_right)
{
	{
		Vec3 left;
		Vec3 right;
		if (_wrap_convert_py2c__Vec3(py_left, &left) && _wrap_convert_py2c__Vec3(py_right, &right)) {
			Vec3 result = (left /= right);
			return _wrap_convert_c2py__Vec3(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyNumberMethods Vec3__py_number_methods = {
#if PY_VERSION_HEX < 0x03000000
	(binaryfunc)Vec3__nb_add,
	(binaryfunc)Vec3__nb_subtract,
	(binaryfunc)Vec3__nb_multiply,
	(binaryfunc)Vec3__nb_divide,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(inquiry)NULL,
	(unaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(coercion)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	/* Added in release 2.0 */
	(binaryfunc)Vec3__nb_inplace_add,
	(binaryfunc)Vec3__nb_inplace_subtract,
	(binaryfunc)Vec3__nb_inplace_multiply,
	(binaryfunc)Vec3__nb_inplace_divide,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

	/* Added in release 2.2 */
	/* The following require the Py_TPFLAGS_HAVE_CLASS flag */
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

#if PY_VERSION_HEX >= 0x020500F0
	/* Added in release 2.5 */
	(unaryfunc)NULL,

#endif
#else /* Python 3 changed this structure a lot */
	(binaryfunc)Vec3__nb_add,
	(binaryfunc)Vec3__nb_subtract,
	(binaryfunc)Vec3__nb_multiply,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(inquiry)NULL,
	(unaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(unaryfunc)NULL,
	NULL,
	(unaryfunc)NULL,

	(binaryfunc)Vec3__nb_inplace_add,
	(binaryfunc)Vec3__nb_inplace_subtract,
	(binaryfunc)Vec3__nb_inplace_multiply,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

	(binaryfunc)NULL,
	(binaryfunc)Vec3__nb_divide,
	(binaryfunc)NULL,
	(binaryfunc)Vec3__nb_inplace_divide,

	(unaryfunc)NULL,
#endif
};

PyTypeObject PyVec3_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.Vec3",            /* tp_name */
	sizeof(PyVec3),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyVec3__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)&Vec3__py_number_methods,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
	"Vec3(ctor_arg)\nVec3(x, y, z)\nVec3()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyVec3__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyVec3_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyVec3__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyVec3__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyVec4__get_x(PyVec4 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->x);
	return py_retval;
}
static int _wrap_PyVec4__set_x(PyVec4 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->x)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyVec4__get_y(PyVec4 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->y);
	return py_retval;
}
static int _wrap_PyVec4__set_y(PyVec4 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->y)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyVec4__get_z(PyVec4 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->z);
	return py_retval;
}
static int _wrap_PyVec4__set_z(PyVec4 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->z)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyVec4__get_w(PyVec4 *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->w);
	return py_retval;
}
static int _wrap_PyVec4__set_w(PyVec4 *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->w)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyVec4__getsets[] = {
	{
		(char*) "y", /* attribute name */
		(getter)_wrap_PyVec4__get_y, /* C function to get the attribute */
		(setter)_wrap_PyVec4__set_y, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "x", /* attribute name */
		(getter)_wrap_PyVec4__get_x, /* C function to get the attribute */
		(setter)_wrap_PyVec4__set_x, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "z", /* attribute name */
		(getter)_wrap_PyVec4__get_z, /* C function to get the attribute */
		(setter)_wrap_PyVec4__set_z, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "w", /* attribute name */
		(getter)_wrap_PyVec4__get_w, /* C function to get the attribute */
		(setter)_wrap_PyVec4__set_w, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyVec4__tp_init__0(PyVec4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyVec4 *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec4_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec4(*((PyVec4 *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyVec4__tp_init__1(PyVec4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec4();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyVec4__tp_init__2(PyVec4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	float x;
	float y;
	float z;
	float w;
	const char *keywords[] = { "x", "y", "z", "w", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ffff", (char **)keywords, &x, &y, &z, &w)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new Vec4(x, y, z, w);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyVec4__tp_init(PyVec4 *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[3] = { 0, };
	retval = _wrap_PyVec4__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyVec4__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	retval = _wrap_PyVec4__tp_init__2(self, args, kwargs, &exceptions[2]);
	if (!exceptions[2]) {
		Py_DECREF(exceptions[0]);
		Py_DECREF(exceptions[1]);
		return retval;
	}
	error_list = PyList_New(3);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
	Py_DECREF(exceptions[2]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


PyObject *
_wrap_PyVec4_VectorNormalize(PyVec4 *self)
{
	PyObject *py_retval;
	PyVec4 *py_Vec4;

	Vec4 & retval = self->obj->VectorNormalize();
	py_Vec4 = PyObject_New(PyVec4, &PyVec4_Type);
	py_Vec4->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec4->obj = new Vec4(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec4);
	return py_retval;
}


PyObject *
_wrap_PyVec4_Compare(PyVec4 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec4 *a;
	const char *keywords[] = { "a", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec4_Type, &a)) {
		return NULL;
	}
	retval = self->obj->Compare(*((PyVec4 *)a)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyVec4_Set(PyVec4 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float x;
	float y;
	float z;
	float w;
	const char *keywords[] = { "x", "y", "z", "w", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ffff", (char **)keywords, &x, &y, &z, &w)) {
		return NULL;
	}
	self->obj->Set(x, y, z, w);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyVec4_Length(PyVec4 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Length();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}



PyObject *
_wrap_PyVec4_DotProduct__0(PyVec4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float retval;
	PyVec4 *vecOther;
	const char *keywords[] = { "vecOther", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec4_Type, &vecOther)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	retval = self->obj->DotProduct(*((PyVec4 *)vecOther)->obj);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}

PyObject *
_wrap_PyVec4_DotProduct__1(PyVec4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float retval;
	PyVec3 *vecOther;
	const char *keywords[] = { "vecOther", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &vecOther)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	retval = self->obj->DotProduct(*((PyVec3 *)vecOther)->obj);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}

PyObject * _wrap_PyVec4_DotProduct(PyVec4 *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyVec4_DotProduct__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyVec4_DotProduct__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyVec4_Zero(PyVec4 *self)
{
	PyObject *py_retval;

	self->obj->Zero();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyVec4_Negate(PyVec4 *self)
{
	PyObject *py_retval;

	self->obj->Negate();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


static PyObject*
_wrap_PyVec4__copy__(PyVec4 *self)
{

	PyVec4 *py_copy;
	py_copy = PyObject_New(PyVec4, &PyVec4_Type);
	py_copy->obj = new Vec4(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyVec4_methods[] = {
	{ (char *) "VectorNormalize", (PyCFunction)_wrap_PyVec4_VectorNormalize, METH_NOARGS, "VectorNormalize()\n\n" },
	{ (char *) "Compare", (PyCFunction)_wrap_PyVec4_Compare, METH_KEYWORDS | METH_VARARGS, "Compare(a)\n\ntype: a: Vec4 const &" },
	{ (char *) "Set", (PyCFunction)_wrap_PyVec4_Set, METH_KEYWORDS | METH_VARARGS, "Set(x, y, z, w)\n\ntype: x: float\ntype: y: float\ntype: z: float\ntype: w: float" },
	{ (char *) "Length", (PyCFunction)_wrap_PyVec4_Length, METH_NOARGS, "Length()\n\n" },
	{ (char *) "DotProduct", (PyCFunction)_wrap_PyVec4_DotProduct, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "Zero", (PyCFunction)_wrap_PyVec4_Zero, METH_NOARGS, "Zero()\n\n" },
	{ (char *) "Negate", (PyCFunction)_wrap_PyVec4_Negate, METH_NOARGS, "Negate()\n\n" },
	{ (char *) "__copy__", (PyCFunction)_wrap_PyVec4__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyVec4__tp_dealloc(PyVec4 *self)
{
	Vec4 *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyVec4__tp_richcompare(PyVec4 *PYBINDGEN_UNUSED(self), PyVec4 *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyVec4_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		if (*self->obj == *other->obj) {
			Py_INCREF(Py_True);
			return Py_True;
		}
		else {
			Py_INCREF(Py_False);
			return Py_False;
		}
	case Py_NE:
		if (*self->obj != *other->obj) {
			Py_INCREF(Py_True);
			return Py_True;
		}
		else {
			Py_INCREF(Py_False);
			return Py_False;
		}
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Vec4(Vec4 *cvalue)
{
	PyObject *py_retval;
	PyVec4 *py_Vec4;

	py_Vec4 = PyObject_New(PyVec4, &PyVec4_Type);
	py_Vec4->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec4->obj = new Vec4(*cvalue);
	py_retval = Py_BuildValue((char *) "N", py_Vec4);
	return py_retval;
}


int _wrap_convert_py2c__Vec4(PyObject *value, Vec4 *address)
{
	PyObject *py_retval;
	PyVec4 *tmp_Vec4;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec4_Type, &tmp_Vec4)) {
		Py_DECREF(py_retval);
		return 0;
	}
	*address = *tmp_Vec4->obj;
	Py_DECREF(py_retval);
	return 1;
}

static PyObject*
Vec4__nb_add(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		Vec4 right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__Vec4(py_right, &right)) {
			Vec4 result = (left + right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec4__nb_subtract(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		Vec4 right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__Vec4(py_right, &right)) {
			Vec4 result = (left - right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec4__nb_multiply(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		float right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec4 result = (left * right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec4__nb_divide(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		float right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec4 result = (left / right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec4__nb_inplace_add(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		Vec4 right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__Vec4(py_right, &right)) {
			Vec4 result = (left += right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec4__nb_inplace_subtract(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		Vec4 right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__Vec4(py_right, &right)) {
			Vec4 result = (left -= right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec4__nb_inplace_multiply(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		float right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__float(py_right, &right)) {
			Vec4 result = (left *= right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyObject*
Vec4__nb_inplace_divide(PyObject *py_left, PyObject *py_right)
{
	{
		Vec4 left;
		Vec4 right;
		if (_wrap_convert_py2c__Vec4(py_left, &left) && _wrap_convert_py2c__Vec4(py_right, &right)) {
			Vec4 result = (left /= right);
			return _wrap_convert_c2py__Vec4(&result);
		}
		PyErr_Clear();
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
static PyNumberMethods Vec4__py_number_methods = {
#if PY_VERSION_HEX < 0x03000000
	(binaryfunc)Vec4__nb_add,
	(binaryfunc)Vec4__nb_subtract,
	(binaryfunc)Vec4__nb_multiply,
	(binaryfunc)Vec4__nb_divide,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(inquiry)NULL,
	(unaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(coercion)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	/* Added in release 2.0 */
	(binaryfunc)Vec4__nb_inplace_add,
	(binaryfunc)Vec4__nb_inplace_subtract,
	(binaryfunc)Vec4__nb_inplace_multiply,
	(binaryfunc)Vec4__nb_inplace_divide,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

	/* Added in release 2.2 */
	/* The following require the Py_TPFLAGS_HAVE_CLASS flag */
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

#if PY_VERSION_HEX >= 0x020500F0
	/* Added in release 2.5 */
	(unaryfunc)NULL,

#endif
#else /* Python 3 changed this structure a lot */
	(binaryfunc)Vec4__nb_add,
	(binaryfunc)Vec4__nb_subtract,
	(binaryfunc)Vec4__nb_multiply,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(unaryfunc)NULL,
	(inquiry)NULL,
	(unaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(unaryfunc)NULL,
	NULL,
	(unaryfunc)NULL,

	(binaryfunc)Vec4__nb_inplace_add,
	(binaryfunc)Vec4__nb_inplace_subtract,
	(binaryfunc)Vec4__nb_inplace_multiply,
	(binaryfunc)NULL,
	(ternaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,
	(binaryfunc)NULL,

	(binaryfunc)NULL,
	(binaryfunc)Vec4__nb_divide,
	(binaryfunc)NULL,
	(binaryfunc)Vec4__nb_inplace_divide,

	(unaryfunc)NULL,
#endif
};

PyTypeObject PyVec4_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.Vec4",            /* tp_name */
	sizeof(PyVec4),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyVec4__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)&Vec4__py_number_methods,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
	"Vec4(x, y, z, w)\nVec4(ctor_arg)\nVec4()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyVec4__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyVec4_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyVec4__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyVec4__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIUnit__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IUnit' cannot be constructed ()");
	return -1;
}


PyObject *
_wrap_PyIUnit_TotalPhysicalDamage(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->TotalPhysicalDamage();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetDeaths(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetDeaths();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_SkinName(PyIUnit *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->SkinName();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsFacing(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Other;
	IUnit *Other_ptr;
	const char *keywords[] = { "Other", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Other)) {
		return NULL;
	}
	Other_ptr = (Other ? Other->obj : NULL);
	retval = self->obj->IsFacing(Other_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsVisible(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsVisible();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetTargetId(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetTargetId();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_PhysicalDamageMod(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->PhysicalDamageMod();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_NumberOfDebuffs(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->NumberOfDebuffs();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_Direction(PyIUnit *self)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	Vec3 const retval = self->obj->Direction();
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSpellRemainingCooldown(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetSpellRemainingCooldown(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetBuffCaster(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	char const *Name;
	const char *keywords[] = { "Name", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Name)) {
		return NULL;
	}
	retval = self->obj->GetBuffCaster(Name);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetNumberOfBuffs(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetNumberOfBuffs();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsDashing(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsDashing();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_CreatePath2D(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec2 *EndPosition;
	std::vector<Vec2> Out_value;
	const char *keywords[] = { "EndPosition", "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O&", (char **)keywords, &PyVec2_Type, &EndPosition, _wrap_convert_py2c__std__vector__lt___Vec2___gt__, &Out_value)) {
		return NULL;
	}
	retval = self->obj->CreatePath2D(*((PyVec2 *)EndPosition)->obj, Out_value);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetObjectName(PyIUnit *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->GetObjectName();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_BonusMagicDamage(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->BonusMagicDamage();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_HPRegenRate(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->HPRegenRate();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetLevel(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetLevel();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MagicPenetrationPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->MagicPenetrationPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_BonusArmorPenetrationPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->BonusArmorPenetrationPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetBuffStartTime(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	char const *Name;
	const char *keywords[] = { "Name", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Name)) {
		return NULL;
	}
	retval = self->obj->GetBuffStartTime(Name);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_CritDamageMultiplier(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->CritDamageMultiplier();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetWaypointList(PyIUnit *self)
{
	PyObject *py_retval;
	std::vector< Vec3 > retval;
	Pystd__vector__lt__Vec3__gt__ *py_std__vector__lt__Vec3__gt__;

	retval = self->obj->GetWaypointList();
	py_std__vector__lt__Vec3__gt__ = PyObject_New(Pystd__vector__lt__Vec3__gt__, &Pystd__vector__lt__Vec3__gt___Type);
	py_std__vector__lt__Vec3__gt__->obj = new std::vector<Vec3>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__Vec3__gt__);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_UnitFlags(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->UnitFlags();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}



PyObject *
_wrap_PyIUnit_IsValidTarget__0(PyIUnit *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *unit;
	IUnit *unit_ptr;
	float value;
	const char *keywords[] = { "unit", "value", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!f", (char **)keywords, &PyIUnit_Type, &unit, &value)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	unit_ptr = (unit ? unit->obj : NULL);
	retval = self->obj->IsValidTarget(unit_ptr, value);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

PyObject *
_wrap_PyIUnit_IsValidTarget__1(PyIUnit *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	bool retval;
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	retval = self->obj->IsValidTarget();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

PyObject * _wrap_PyIUnit_IsValidTarget(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIUnit_IsValidTarget__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIUnit_IsValidTarget__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIUnit_GetHealth(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetHealth();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_Crit(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Crit();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetBonusArmor(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetBonusArmor();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_HasItem(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	char const *item;
	const char *keywords[] = { "item", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &item)) {
		return NULL;
	}
	retval = self->obj->HasItem(item);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsTurret(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsTurret();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MaxSpells(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->MaxSpells();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetPet(PyIUnit *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->GetPet();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_Armor(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Armor();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsEnemy(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *other;
	IUnit *other_ptr;
	const char *keywords[] = { "other", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &other)) {
		return NULL;
	}
	other_ptr = (other ? other->obj : NULL);
	retval = self->obj->IsEnemy(other_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetMaxMana(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetMaxMana();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_AttackRange(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->AttackRange();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_LevelUpSpell(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	self->obj->LevelUpSpell(Slot);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetRealAutoAttackRange(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *Other;
	IUnit *Other_ptr;
	const char *keywords[] = { "Other", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Other)) {
		return NULL;
	}
	Other_ptr = (Other ? Other->obj : NULL);
	retval = self->obj->GetRealAutoAttackRange(Other_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MagicDamage(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->MagicDamage();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_AttackSpeed(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->AttackSpeed();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetCooldownReductionPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetCooldownReductionPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetBuffCount(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	char const *name;
	const char *keywords[] = { "name", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &name)) {
		return NULL;
	}
	retval = self->obj->GetBuffCount(name);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_CreatePath(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *EndPosition;
	std::vector<Vec3> Out_value;
	const char *keywords[] = { "EndPosition", "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O&", (char **)keywords, &PyVec3_Type, &EndPosition, _wrap_convert_py2c__std__vector__lt___Vec3___gt__, &Out_value)) {
		return NULL;
	}
	retval = self->obj->CreatePath(*((PyVec3 *)EndPosition)->obj, Out_value);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsInvulnerable(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsInvulnerable();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetHitboxCenter(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Out_Hitbox;
	Vec3 *Out_Hitbox_ptr;
	const char *keywords[] = { "Out_Hitbox", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Out_Hitbox)) {
		return NULL;
	}
	Out_Hitbox_ptr = (Out_Hitbox ? Out_Hitbox->obj : NULL);
	retval = self->obj->GetHitboxCenter(Out_Hitbox_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_ServerPosition(PyIUnit *self)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	Vec3 const & retval = self->obj->ServerPosition();
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsJungleCreep(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsJungleCreep();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetTeam(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetTeam();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_TotalMagicDamage(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->TotalMagicDamage();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSpellState(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	eSpellState retval;
	eSpellSlot slot;
	const char *keywords[] = { "slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &slot)) {
		return NULL;
	}
	retval = self->obj->GetSpellState(slot);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_BoundingRadius(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->BoundingRadius();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetKills(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetKills();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetMaxHealth(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetMaxHealth();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MagicPenetrationFlat(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->MagicPenetrationFlat();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MovementSpeed(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->MovementSpeed();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_ArmorReductionFlat(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->ArmorReductionFlat();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_AnimationTime(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->AnimationTime();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSkinId(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetSkinId();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsValidObject(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsValidObject();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsMissile(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsMissile();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsRecalling(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsRecalling();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_SetSkinId(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int Id;
	const char *keywords[] = { "Id", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Id)) {
		return NULL;
	}
	self->obj->SetSkinId(Id);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIUnit_PhysicalDamage(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->PhysicalDamage();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSpellLevel(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	int value;
	const char *keywords[] = { "value", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &value)) {
		return NULL;
	}
	retval = self->obj->GetSpellLevel(value);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSpellBook(PyIUnit *self)
{
	PyObject *py_retval;
	ISpellBook *retval;
	PyISpellBook *py_ISpellBook;

	retval = self->obj->GetSpellBook();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_ISpellBook = PyObject_New(PyISpellBook, &PyISpellBook_Type);
	py_ISpellBook->obj = retval;
	py_ISpellBook->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_ISpellBook);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_ArmorPenetrationPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->ArmorPenetrationPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSpellName(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetSpellName(Slot);
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetExperience(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetExperience();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_HasBuff(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	char const *buff;
	const char *keywords[] = { "buff", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &buff)) {
		return NULL;
	}
	retval = self->obj->HasBuff(buff);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsChasing(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Other;
	IUnit *Other_ptr;
	const char *keywords[] = { "Other", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Other)) {
		return NULL;
	}
	Other_ptr = (Other ? Other->obj : NULL);
	retval = self->obj->IsChasing(Other_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetCharacterState(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetCharacterState();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsClone(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsClone();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsRanged(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsRanged();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetHPBarPosition(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec2 *Out;
	const char *keywords[] = { "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &Out)) {
		return NULL;
	}
	retval = self->obj->GetHPBarPosition(*((PyVec2 *)Out)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsCastingImportantSpell(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	float EndTime;
	const char *keywords[] = { "EndTime", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &EndTime)) {
		return NULL;
	}
	retval = self->obj->IsCastingImportantSpell(&EndTime);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MagicReductionPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->MagicReductionPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_ArmorPenetrationFlat(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->ArmorPenetrationFlat();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetMasteries(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	std::vector<HeroMastery> Out_value;
	const char *keywords[] = { "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **)keywords, _wrap_convert_py2c__std__vector__lt___HeroMastery___gt__, &Out_value)) {
		return NULL;
	}
	retval = self->obj->GetMasteries(Out_value);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsDead(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsDead();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_ArmorReductionPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->ArmorReductionPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetTimeVisibleMs(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetTimeVisibleMs();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MagicReductionFlat(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->MagicReductionFlat();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsHpBarBeingRendered(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsHpBarBeingRendered();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_MagicResist(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->MagicResist();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetType(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetType();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetClassId(PyIUnit *self)
{
	PyObject *py_retval;
	eGameObjectClassId retval;

	retval = self->obj->GetClassId();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_ManaPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->ManaPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetPosition(PyIUnit *self)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	Vec3 const & retval = self->obj->GetPosition();
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetLastCastedSpell(PyIUnit *self)
{
	PyObject *py_retval;
	LastCastedSpellArgs *retval;
	PyLastCastedSpellArgs *py_LastCastedSpellArgs;

	retval = self->obj->GetLastCastedSpell();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_LastCastedSpellArgs = PyObject_New(PyLastCastedSpellArgs, &PyLastCastedSpellArgs_Type);
	py_LastCastedSpellArgs->obj = retval;
	py_LastCastedSpellArgs->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_LastCastedSpellArgs);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_HasItemId(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	int item;
	const char *keywords[] = { "item", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &item)) {
		return NULL;
	}
	retval = self->obj->HasItemId(item);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsMelee(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsMelee();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetAssists(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetAssists();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_WindupTime(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->WindupTime();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsTargetable(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsTargetable();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_BonusDamage(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->BonusDamage();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetClassIdentifier(PyIUnit *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->GetClassIdentifier();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetMana(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetMana();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_PercentMagicDamageMod(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->PercentMagicDamageMod();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsWindingUp(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsWindingUp();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsOnScreen(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsOnScreen();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsHero(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsHero();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetDashData(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyUnitDash *Out;
	UnitDash *Out_ptr;
	const char *keywords[] = { "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyUnitDash_Type, &Out)) {
		return NULL;
	}
	Out_ptr = (Out ? Out->obj : NULL);
	retval = self->obj->GetDashData(Out_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetNavigationPath(PyIUnit *self)
{
	PyObject *py_retval;
	NavigationPath *retval;
	PyNavigationPath *py_NavigationPath;

	retval = self->obj->GetNavigationPath();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_NavigationPath = PyObject_New(PyNavigationPath, &PyNavigationPath_Type);
	py_NavigationPath->obj = retval;
	py_NavigationPath->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_NavigationPath);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsWard(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsWard();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_HasBuffOfType(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	eBuffType Type;
	const char *keywords[] = { "Type", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Type)) {
		return NULL;
	}
	retval = self->obj->HasBuffOfType(Type);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSpellTotalCooldown(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetSpellTotalCooldown(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetNetworkId(PyIUnit *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetNetworkId();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetSpellSlot(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	eSpellSlot retval;
	char const *name;
	const char *keywords[] = { "name", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &name)) {
		return NULL;
	}
	retval = self->obj->GetSpellSlot(name);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_HasIncomingDamage(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->HasIncomingDamage();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetBonusMana(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetBonusMana();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsMoving(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsMoving();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_IsCreep(PyIUnit *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsCreep();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_HealthPercent(PyIUnit *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->HealthPercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_ChampionName(PyIUnit *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->ChampionName();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetAutoAttack(PyIUnit *self)
{
	PyObject *py_retval;
	PyCastedSpell *py_CastedSpell;

	CastedSpell const & retval = self->obj->GetAutoAttack();
	py_CastedSpell = PyObject_New(PyCastedSpell, &PyCastedSpell_Type);
	py_CastedSpell->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_CastedSpell->obj = new CastedSpell(retval);
	py_retval = Py_BuildValue((char *) "N", py_CastedSpell);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_AllItems(PyIUnit *self)
{
	PyObject *py_retval;
	std::vector< ItemData > retval;
	Pystd__vector__lt__ItemData__gt__ *py_std__vector__lt__ItemData__gt__;

	retval = self->obj->AllItems();
	py_std__vector__lt__ItemData__gt__ = PyObject_New(Pystd__vector__lt__ItemData__gt__, &Pystd__vector__lt__ItemData__gt___Type);
	py_std__vector__lt__ItemData__gt__->obj = new std::vector<ItemData>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__ItemData__gt__);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetClone(PyIUnit *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->GetClone();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetBounds(PyIUnit *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Out_Min;
	Vec3 *Out_Min_ptr;
	PyVec3 *Out_Max;
	Vec3 *Out_Max_ptr;
	const char *keywords[] = { "Out_Min", "Out_Max", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **)keywords, &PyVec3_Type, &Out_Min, &PyVec3_Type, &Out_Max)) {
		return NULL;
	}
	Out_Min_ptr = (Out_Min ? Out_Min->obj : NULL);
	Out_Max_ptr = (Out_Max ? Out_Max->obj : NULL);
	retval = self->obj->GetBounds(Out_Min_ptr, Out_Max_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUnit_GetBaseSkinName(PyIUnit *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->GetBaseSkinName();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}

static PyMethodDef PyIUnit_methods[] = {
	{ (char *) "TotalPhysicalDamage", (PyCFunction)_wrap_PyIUnit_TotalPhysicalDamage, METH_NOARGS, "TotalPhysicalDamage()\n\n" },
	{ (char *) "GetDeaths", (PyCFunction)_wrap_PyIUnit_GetDeaths, METH_NOARGS, "GetDeaths()\n\n" },
	{ (char *) "SkinName", (PyCFunction)_wrap_PyIUnit_SkinName, METH_NOARGS, "SkinName()\n\n" },
	{ (char *) "IsFacing", (PyCFunction)_wrap_PyIUnit_IsFacing, METH_KEYWORDS | METH_VARARGS, "IsFacing(Other)\n\ntype: Other: IUnit *" },
	{ (char *) "IsVisible", (PyCFunction)_wrap_PyIUnit_IsVisible, METH_NOARGS, "IsVisible()\n\n" },
	{ (char *) "GetTargetId", (PyCFunction)_wrap_PyIUnit_GetTargetId, METH_NOARGS, "GetTargetId()\n\n" },
	{ (char *) "PhysicalDamageMod", (PyCFunction)_wrap_PyIUnit_PhysicalDamageMod, METH_NOARGS, "PhysicalDamageMod()\n\n" },
	{ (char *) "NumberOfDebuffs", (PyCFunction)_wrap_PyIUnit_NumberOfDebuffs, METH_NOARGS, "NumberOfDebuffs()\n\n" },
	{ (char *) "Direction", (PyCFunction)_wrap_PyIUnit_Direction, METH_NOARGS, "Direction()\n\n" },
	{ (char *) "GetSpellRemainingCooldown", (PyCFunction)_wrap_PyIUnit_GetSpellRemainingCooldown, METH_KEYWORDS | METH_VARARGS, "GetSpellRemainingCooldown(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetBuffCaster", (PyCFunction)_wrap_PyIUnit_GetBuffCaster, METH_KEYWORDS | METH_VARARGS, "GetBuffCaster(Name)\n\ntype: Name: char const *" },
	{ (char *) "GetNumberOfBuffs", (PyCFunction)_wrap_PyIUnit_GetNumberOfBuffs, METH_NOARGS, "GetNumberOfBuffs()\n\n" },
	{ (char *) "IsDashing", (PyCFunction)_wrap_PyIUnit_IsDashing, METH_NOARGS, "IsDashing()\n\n" },
	{ (char *) "CreatePath2D", (PyCFunction)_wrap_PyIUnit_CreatePath2D, METH_KEYWORDS | METH_VARARGS, "CreatePath2D(EndPosition, Out)\n\ntype: EndPosition: Vec2 const &\ntype: Out: std::vector< Vec2 > &" },
	{ (char *) "GetObjectName", (PyCFunction)_wrap_PyIUnit_GetObjectName, METH_NOARGS, "GetObjectName()\n\n" },
	{ (char *) "BonusMagicDamage", (PyCFunction)_wrap_PyIUnit_BonusMagicDamage, METH_NOARGS, "BonusMagicDamage()\n\n" },
	{ (char *) "HPRegenRate", (PyCFunction)_wrap_PyIUnit_HPRegenRate, METH_NOARGS, "HPRegenRate()\n\n" },
	{ (char *) "GetLevel", (PyCFunction)_wrap_PyIUnit_GetLevel, METH_NOARGS, "GetLevel()\n\n" },
	{ (char *) "MagicPenetrationPercent", (PyCFunction)_wrap_PyIUnit_MagicPenetrationPercent, METH_NOARGS, "MagicPenetrationPercent()\n\n" },
	{ (char *) "BonusArmorPenetrationPercent", (PyCFunction)_wrap_PyIUnit_BonusArmorPenetrationPercent, METH_NOARGS, "BonusArmorPenetrationPercent()\n\n" },
	{ (char *) "GetBuffStartTime", (PyCFunction)_wrap_PyIUnit_GetBuffStartTime, METH_KEYWORDS | METH_VARARGS, "GetBuffStartTime(Name)\n\ntype: Name: char const *" },
	{ (char *) "CritDamageMultiplier", (PyCFunction)_wrap_PyIUnit_CritDamageMultiplier, METH_NOARGS, "CritDamageMultiplier()\n\n" },
	{ (char *) "GetWaypointList", (PyCFunction)_wrap_PyIUnit_GetWaypointList, METH_NOARGS, "GetWaypointList()\n\n" },
	{ (char *) "UnitFlags", (PyCFunction)_wrap_PyIUnit_UnitFlags, METH_NOARGS, "UnitFlags()\n\n" },
	{ (char *) "IsValidTarget", (PyCFunction)_wrap_PyIUnit_IsValidTarget, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "GetHealth", (PyCFunction)_wrap_PyIUnit_GetHealth, METH_NOARGS, "GetHealth()\n\n" },
	{ (char *) "Crit", (PyCFunction)_wrap_PyIUnit_Crit, METH_NOARGS, "Crit()\n\n" },
	{ (char *) "GetBonusArmor", (PyCFunction)_wrap_PyIUnit_GetBonusArmor, METH_NOARGS, "GetBonusArmor()\n\n" },
	{ (char *) "HasItem", (PyCFunction)_wrap_PyIUnit_HasItem, METH_KEYWORDS | METH_VARARGS, "HasItem(item)\n\ntype: item: char const *" },
	{ (char *) "IsTurret", (PyCFunction)_wrap_PyIUnit_IsTurret, METH_NOARGS, "IsTurret()\n\n" },
	{ (char *) "MaxSpells", (PyCFunction)_wrap_PyIUnit_MaxSpells, METH_NOARGS, "MaxSpells()\n\n" },
	{ (char *) "GetPet", (PyCFunction)_wrap_PyIUnit_GetPet, METH_NOARGS, "GetPet()\n\n" },
	{ (char *) "Armor", (PyCFunction)_wrap_PyIUnit_Armor, METH_NOARGS, "Armor()\n\n" },
	{ (char *) "IsEnemy", (PyCFunction)_wrap_PyIUnit_IsEnemy, METH_KEYWORDS | METH_VARARGS, "IsEnemy(other)\n\ntype: other: IUnit *" },
	{ (char *) "GetMaxMana", (PyCFunction)_wrap_PyIUnit_GetMaxMana, METH_NOARGS, "GetMaxMana()\n\n" },
	{ (char *) "AttackRange", (PyCFunction)_wrap_PyIUnit_AttackRange, METH_NOARGS, "AttackRange()\n\n" },
	{ (char *) "LevelUpSpell", (PyCFunction)_wrap_PyIUnit_LevelUpSpell, METH_KEYWORDS | METH_VARARGS, "LevelUpSpell(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetRealAutoAttackRange", (PyCFunction)_wrap_PyIUnit_GetRealAutoAttackRange, METH_KEYWORDS | METH_VARARGS, "GetRealAutoAttackRange(Other)\n\ntype: Other: IUnit *" },
	{ (char *) "MagicDamage", (PyCFunction)_wrap_PyIUnit_MagicDamage, METH_NOARGS, "MagicDamage()\n\n" },
	{ (char *) "AttackSpeed", (PyCFunction)_wrap_PyIUnit_AttackSpeed, METH_NOARGS, "AttackSpeed()\n\n" },
	{ (char *) "GetCooldownReductionPercent", (PyCFunction)_wrap_PyIUnit_GetCooldownReductionPercent, METH_NOARGS, "GetCooldownReductionPercent()\n\n" },
	{ (char *) "GetBuffCount", (PyCFunction)_wrap_PyIUnit_GetBuffCount, METH_KEYWORDS | METH_VARARGS, "GetBuffCount(name)\n\ntype: name: char const *" },
	{ (char *) "CreatePath", (PyCFunction)_wrap_PyIUnit_CreatePath, METH_KEYWORDS | METH_VARARGS, "CreatePath(EndPosition, Out)\n\ntype: EndPosition: Vec3 const &\ntype: Out: std::vector< Vec3 > &" },
	{ (char *) "IsInvulnerable", (PyCFunction)_wrap_PyIUnit_IsInvulnerable, METH_NOARGS, "IsInvulnerable()\n\n" },
	{ (char *) "GetHitboxCenter", (PyCFunction)_wrap_PyIUnit_GetHitboxCenter, METH_KEYWORDS | METH_VARARGS, "GetHitboxCenter(Out_Hitbox)\n\ntype: Out_Hitbox: Vec3 *" },
	{ (char *) "ServerPosition", (PyCFunction)_wrap_PyIUnit_ServerPosition, METH_NOARGS, "ServerPosition()\n\n" },
	{ (char *) "IsJungleCreep", (PyCFunction)_wrap_PyIUnit_IsJungleCreep, METH_NOARGS, "IsJungleCreep()\n\n" },
	{ (char *) "GetTeam", (PyCFunction)_wrap_PyIUnit_GetTeam, METH_NOARGS, "GetTeam()\n\n" },
	{ (char *) "TotalMagicDamage", (PyCFunction)_wrap_PyIUnit_TotalMagicDamage, METH_NOARGS, "TotalMagicDamage()\n\n" },
	{ (char *) "GetSpellState", (PyCFunction)_wrap_PyIUnit_GetSpellState, METH_KEYWORDS | METH_VARARGS, "GetSpellState(slot)\n\ntype: slot: eSpellSlot" },
	{ (char *) "BoundingRadius", (PyCFunction)_wrap_PyIUnit_BoundingRadius, METH_NOARGS, "BoundingRadius()\n\n" },
	{ (char *) "GetKills", (PyCFunction)_wrap_PyIUnit_GetKills, METH_NOARGS, "GetKills()\n\n" },
	{ (char *) "GetMaxHealth", (PyCFunction)_wrap_PyIUnit_GetMaxHealth, METH_NOARGS, "GetMaxHealth()\n\n" },
	{ (char *) "MagicPenetrationFlat", (PyCFunction)_wrap_PyIUnit_MagicPenetrationFlat, METH_NOARGS, "MagicPenetrationFlat()\n\n" },
	{ (char *) "MovementSpeed", (PyCFunction)_wrap_PyIUnit_MovementSpeed, METH_NOARGS, "MovementSpeed()\n\n" },
	{ (char *) "ArmorReductionFlat", (PyCFunction)_wrap_PyIUnit_ArmorReductionFlat, METH_NOARGS, "ArmorReductionFlat()\n\n" },
	{ (char *) "AnimationTime", (PyCFunction)_wrap_PyIUnit_AnimationTime, METH_NOARGS, "AnimationTime()\n\n" },
	{ (char *) "GetSkinId", (PyCFunction)_wrap_PyIUnit_GetSkinId, METH_NOARGS, "GetSkinId()\n\n" },
	{ (char *) "IsValidObject", (PyCFunction)_wrap_PyIUnit_IsValidObject, METH_NOARGS, "IsValidObject()\n\n" },
	{ (char *) "IsMissile", (PyCFunction)_wrap_PyIUnit_IsMissile, METH_NOARGS, "IsMissile()\n\n" },
	{ (char *) "IsRecalling", (PyCFunction)_wrap_PyIUnit_IsRecalling, METH_NOARGS, "IsRecalling()\n\n" },
	{ (char *) "SetSkinId", (PyCFunction)_wrap_PyIUnit_SetSkinId, METH_KEYWORDS | METH_VARARGS, "SetSkinId(Id)\n\ntype: Id: int" },
	{ (char *) "PhysicalDamage", (PyCFunction)_wrap_PyIUnit_PhysicalDamage, METH_NOARGS, "PhysicalDamage()\n\n" },
	{ (char *) "GetSpellLevel", (PyCFunction)_wrap_PyIUnit_GetSpellLevel, METH_KEYWORDS | METH_VARARGS, "GetSpellLevel(value)\n\ntype: value: int" },
	{ (char *) "GetSpellBook", (PyCFunction)_wrap_PyIUnit_GetSpellBook, METH_NOARGS, "GetSpellBook()\n\n" },
	{ (char *) "ArmorPenetrationPercent", (PyCFunction)_wrap_PyIUnit_ArmorPenetrationPercent, METH_NOARGS, "ArmorPenetrationPercent()\n\n" },
	{ (char *) "GetSpellName", (PyCFunction)_wrap_PyIUnit_GetSpellName, METH_KEYWORDS | METH_VARARGS, "GetSpellName(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetExperience", (PyCFunction)_wrap_PyIUnit_GetExperience, METH_NOARGS, "GetExperience()\n\n" },
	{ (char *) "HasBuff", (PyCFunction)_wrap_PyIUnit_HasBuff, METH_KEYWORDS | METH_VARARGS, "HasBuff(buff)\n\ntype: buff: char const *" },
	{ (char *) "IsChasing", (PyCFunction)_wrap_PyIUnit_IsChasing, METH_KEYWORDS | METH_VARARGS, "IsChasing(Other)\n\ntype: Other: IUnit *" },
	{ (char *) "GetCharacterState", (PyCFunction)_wrap_PyIUnit_GetCharacterState, METH_NOARGS, "GetCharacterState()\n\n" },
	{ (char *) "IsClone", (PyCFunction)_wrap_PyIUnit_IsClone, METH_NOARGS, "IsClone()\n\n" },
	{ (char *) "IsRanged", (PyCFunction)_wrap_PyIUnit_IsRanged, METH_NOARGS, "IsRanged()\n\n" },
	{ (char *) "GetHPBarPosition", (PyCFunction)_wrap_PyIUnit_GetHPBarPosition, METH_KEYWORDS | METH_VARARGS, "GetHPBarPosition(Out)\n\ntype: Out: Vec2 &" },
	{ (char *) "IsCastingImportantSpell", (PyCFunction)_wrap_PyIUnit_IsCastingImportantSpell, METH_KEYWORDS | METH_VARARGS, "IsCastingImportantSpell(EndTime)\n\ntype: EndTime: float *" },
	{ (char *) "MagicReductionPercent", (PyCFunction)_wrap_PyIUnit_MagicReductionPercent, METH_NOARGS, "MagicReductionPercent()\n\n" },
	{ (char *) "ArmorPenetrationFlat", (PyCFunction)_wrap_PyIUnit_ArmorPenetrationFlat, METH_NOARGS, "ArmorPenetrationFlat()\n\n" },
	{ (char *) "GetMasteries", (PyCFunction)_wrap_PyIUnit_GetMasteries, METH_KEYWORDS | METH_VARARGS, "GetMasteries(Out)\n\ntype: Out: std::vector< HeroMastery > &" },
	{ (char *) "IsDead", (PyCFunction)_wrap_PyIUnit_IsDead, METH_NOARGS, "IsDead()\n\n" },
	{ (char *) "ArmorReductionPercent", (PyCFunction)_wrap_PyIUnit_ArmorReductionPercent, METH_NOARGS, "ArmorReductionPercent()\n\n" },
	{ (char *) "GetTimeVisibleMs", (PyCFunction)_wrap_PyIUnit_GetTimeVisibleMs, METH_NOARGS, "GetTimeVisibleMs()\n\n" },
	{ (char *) "MagicReductionFlat", (PyCFunction)_wrap_PyIUnit_MagicReductionFlat, METH_NOARGS, "MagicReductionFlat()\n\n" },
	{ (char *) "IsHpBarBeingRendered", (PyCFunction)_wrap_PyIUnit_IsHpBarBeingRendered, METH_NOARGS, "IsHpBarBeingRendered()\n\n" },
	{ (char *) "MagicResist", (PyCFunction)_wrap_PyIUnit_MagicResist, METH_NOARGS, "MagicResist()\n\n" },
	{ (char *) "GetType", (PyCFunction)_wrap_PyIUnit_GetType, METH_NOARGS, "GetType()\n\n" },
	{ (char *) "GetClassId", (PyCFunction)_wrap_PyIUnit_GetClassId, METH_NOARGS, "GetClassId()\n\n" },
	{ (char *) "ManaPercent", (PyCFunction)_wrap_PyIUnit_ManaPercent, METH_NOARGS, "ManaPercent()\n\n" },
	{ (char *) "GetPosition", (PyCFunction)_wrap_PyIUnit_GetPosition, METH_NOARGS, "GetPosition()\n\n" },
	{ (char *) "GetLastCastedSpell", (PyCFunction)_wrap_PyIUnit_GetLastCastedSpell, METH_NOARGS, "GetLastCastedSpell()\n\n" },
	{ (char *) "HasItemId", (PyCFunction)_wrap_PyIUnit_HasItemId, METH_KEYWORDS | METH_VARARGS, "HasItemId(item)\n\ntype: item: int" },
	{ (char *) "IsMelee", (PyCFunction)_wrap_PyIUnit_IsMelee, METH_NOARGS, "IsMelee()\n\n" },
	{ (char *) "GetAssists", (PyCFunction)_wrap_PyIUnit_GetAssists, METH_NOARGS, "GetAssists()\n\n" },
	{ (char *) "WindupTime", (PyCFunction)_wrap_PyIUnit_WindupTime, METH_NOARGS, "WindupTime()\n\n" },
	{ (char *) "IsTargetable", (PyCFunction)_wrap_PyIUnit_IsTargetable, METH_NOARGS, "IsTargetable()\n\n" },
	{ (char *) "BonusDamage", (PyCFunction)_wrap_PyIUnit_BonusDamage, METH_NOARGS, "BonusDamage()\n\n" },
	{ (char *) "GetClassIdentifier", (PyCFunction)_wrap_PyIUnit_GetClassIdentifier, METH_NOARGS, "GetClassIdentifier()\n\n" },
	{ (char *) "GetMana", (PyCFunction)_wrap_PyIUnit_GetMana, METH_NOARGS, "GetMana()\n\n" },
	{ (char *) "PercentMagicDamageMod", (PyCFunction)_wrap_PyIUnit_PercentMagicDamageMod, METH_NOARGS, "PercentMagicDamageMod()\n\n" },
	{ (char *) "IsWindingUp", (PyCFunction)_wrap_PyIUnit_IsWindingUp, METH_NOARGS, "IsWindingUp()\n\n" },
	{ (char *) "IsOnScreen", (PyCFunction)_wrap_PyIUnit_IsOnScreen, METH_NOARGS, "IsOnScreen()\n\n" },
	{ (char *) "IsHero", (PyCFunction)_wrap_PyIUnit_IsHero, METH_NOARGS, "IsHero()\n\n" },
	{ (char *) "GetDashData", (PyCFunction)_wrap_PyIUnit_GetDashData, METH_KEYWORDS | METH_VARARGS, "GetDashData(Out)\n\ntype: Out: UnitDash *" },
	{ (char *) "GetNavigationPath", (PyCFunction)_wrap_PyIUnit_GetNavigationPath, METH_NOARGS, "GetNavigationPath()\n\n" },
	{ (char *) "IsWard", (PyCFunction)_wrap_PyIUnit_IsWard, METH_NOARGS, "IsWard()\n\n" },
	{ (char *) "HasBuffOfType", (PyCFunction)_wrap_PyIUnit_HasBuffOfType, METH_KEYWORDS | METH_VARARGS, "HasBuffOfType(Type)\n\ntype: Type: eBuffType" },
	{ (char *) "GetSpellTotalCooldown", (PyCFunction)_wrap_PyIUnit_GetSpellTotalCooldown, METH_KEYWORDS | METH_VARARGS, "GetSpellTotalCooldown(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetNetworkId", (PyCFunction)_wrap_PyIUnit_GetNetworkId, METH_NOARGS, "GetNetworkId()\n\n" },
	{ (char *) "GetSpellSlot", (PyCFunction)_wrap_PyIUnit_GetSpellSlot, METH_KEYWORDS | METH_VARARGS, "GetSpellSlot(name)\n\ntype: name: char const *" },
	{ (char *) "HasIncomingDamage", (PyCFunction)_wrap_PyIUnit_HasIncomingDamage, METH_NOARGS, "HasIncomingDamage()\n\n" },
	{ (char *) "GetBonusMana", (PyCFunction)_wrap_PyIUnit_GetBonusMana, METH_NOARGS, "GetBonusMana()\n\n" },
	{ (char *) "IsMoving", (PyCFunction)_wrap_PyIUnit_IsMoving, METH_NOARGS, "IsMoving()\n\n" },
	{ (char *) "IsCreep", (PyCFunction)_wrap_PyIUnit_IsCreep, METH_NOARGS, "IsCreep()\n\n" },
	{ (char *) "HealthPercent", (PyCFunction)_wrap_PyIUnit_HealthPercent, METH_NOARGS, "HealthPercent()\n\n" },
	{ (char *) "ChampionName", (PyCFunction)_wrap_PyIUnit_ChampionName, METH_NOARGS, "ChampionName()\n\n" },
	{ (char *) "GetAutoAttack", (PyCFunction)_wrap_PyIUnit_GetAutoAttack, METH_NOARGS, "GetAutoAttack()\n\n" },
	{ (char *) "AllItems", (PyCFunction)_wrap_PyIUnit_AllItems, METH_NOARGS, "AllItems()\n\n" },
	{ (char *) "GetClone", (PyCFunction)_wrap_PyIUnit_GetClone, METH_NOARGS, "GetClone()\n\n" },
	{ (char *) "GetBounds", (PyCFunction)_wrap_PyIUnit_GetBounds, METH_KEYWORDS | METH_VARARGS, "GetBounds(Out_Min, Out_Max)\n\ntype: Out_Min: Vec3 *\ntype: Out_Max: Vec3 *" },
	{ (char *) "GetBaseSkinName", (PyCFunction)_wrap_PyIUnit_GetBaseSkinName, METH_NOARGS, "GetBaseSkinName()\n\n" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIUnit__tp_dealloc(PyIUnit *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIUnit__tp_richcompare(PyIUnit *PYBINDGEN_UNUSED(self), PyIUnit *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIUnit_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIUnit_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IUnit",            /* tp_name */
	sizeof(PyIUnit),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIUnit__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIUnit__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIUnit_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIUnit__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyCastedSpell__get_Caster_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *py_IUnit;

	if (!(self->obj->Caster_)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = self->obj->Caster_;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Caster_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Caster_ = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Target_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *py_IUnit;

	if (!(self->obj->Target_)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = self->obj->Target_;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Target_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Target_ = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_AutoAttack_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(self->obj->AutoAttack_));
	return py_retval;
}
static int _wrap_PyCastedSpell__set_AutoAttack_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyObject *py_boolretval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->AutoAttack_ = PyObject_IsTrue(py_boolretval);
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Name_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "c", (int)self->obj->Name_);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Name_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "c", &self->obj->Name_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Windup_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Windup_);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Windup_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Windup_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Animation_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Animation_);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Animation_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Animation_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Position_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->Position_);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Position_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Position_ = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Radius_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Radius_);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Radius_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Radius_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Speed_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Speed_);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Speed_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Speed_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Damage_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Damage_);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Damage_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Damage_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_Range_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Range_);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_Range_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Range_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyCastedSpell__get_EndPosition_(PyCastedSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->EndPosition_);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyCastedSpell__set_EndPosition_(PyCastedSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->EndPosition_ = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyCastedSpell__getsets[] = {
	{
		(char*) "AutoAttack_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_AutoAttack_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_AutoAttack_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Position_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Position_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Position_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Windup_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Windup_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Windup_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Caster_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Caster_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Caster_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Radius_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Radius_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Radius_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Target_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Target_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Target_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Speed_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Speed_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Speed_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Damage_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Damage_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Damage_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Name_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Name_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Name_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Animation_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Animation_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Animation_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Range_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_Range_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_Range_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "EndPosition_", /* attribute name */
		(getter)_wrap_PyCastedSpell__get_EndPosition_, /* C function to get the attribute */
		(setter)_wrap_PyCastedSpell__set_EndPosition_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyCastedSpell__tp_init__0(PyCastedSpell *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new CastedSpell();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyCastedSpell__tp_init__1(PyCastedSpell *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyCastedSpell *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyCastedSpell_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new CastedSpell(*((PyCastedSpell *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyCastedSpell__tp_init(PyCastedSpell *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyCastedSpell__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyCastedSpell__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyCastedSpell__copy__(PyCastedSpell *self)
{

	PyCastedSpell *py_copy;
	py_copy = PyObject_New(PyCastedSpell, &PyCastedSpell_Type);
	py_copy->obj = new CastedSpell(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyCastedSpell_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyCastedSpell__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyCastedSpell__tp_dealloc(PyCastedSpell *self)
{
	CastedSpell *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyCastedSpell__tp_richcompare(PyCastedSpell *PYBINDGEN_UNUSED(self), PyCastedSpell *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyCastedSpell_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyCastedSpell_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.CastedSpell",            /* tp_name */
	sizeof(PyCastedSpell),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyCastedSpell__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"CastedSpell(ctor_arg)\nCastedSpell()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyCastedSpell__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyCastedSpell_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyCastedSpell__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyCastedSpell__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyLastCastedSpellArgs__get_Data(PyLastCastedSpellArgs *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyCastedSpell *py_CastedSpell;

	py_CastedSpell = PyObject_New(PyCastedSpell, &PyCastedSpell_Type);
	py_CastedSpell->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_CastedSpell->obj = new CastedSpell(self->obj->Data);
	py_retval = Py_BuildValue((char *) "N", py_CastedSpell);
	return py_retval;
}
static int _wrap_PyLastCastedSpellArgs__set_Data(PyLastCastedSpellArgs *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyCastedSpell *tmp_CastedSpell;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyCastedSpell_Type, &tmp_CastedSpell)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Data = *tmp_CastedSpell->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyLastCastedSpellArgs__get_Tick(PyLastCastedSpellArgs *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Tick);
	return py_retval;
}
static int _wrap_PyLastCastedSpellArgs__set_Tick(PyLastCastedSpellArgs *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Tick)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyLastCastedSpellArgs__getsets[] = {
	{
		(char*) "Tick", /* attribute name */
		(getter)_wrap_PyLastCastedSpellArgs__get_Tick, /* C function to get the attribute */
		(setter)_wrap_PyLastCastedSpellArgs__set_Tick, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Data", /* attribute name */
		(getter)_wrap_PyLastCastedSpellArgs__get_Data, /* C function to get the attribute */
		(setter)_wrap_PyLastCastedSpellArgs__set_Data, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyLastCastedSpellArgs__tp_init__0(PyLastCastedSpellArgs *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new LastCastedSpellArgs();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyLastCastedSpellArgs__tp_init__1(PyLastCastedSpellArgs *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyLastCastedSpellArgs *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyLastCastedSpellArgs_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new LastCastedSpellArgs(*((PyLastCastedSpellArgs *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyLastCastedSpellArgs__tp_init(PyLastCastedSpellArgs *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyLastCastedSpellArgs__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyLastCastedSpellArgs__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyLastCastedSpellArgs__copy__(PyLastCastedSpellArgs *self)
{

	PyLastCastedSpellArgs *py_copy;
	py_copy = PyObject_New(PyLastCastedSpellArgs, &PyLastCastedSpellArgs_Type);
	py_copy->obj = new LastCastedSpellArgs(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyLastCastedSpellArgs_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyLastCastedSpellArgs__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyLastCastedSpellArgs__tp_dealloc(PyLastCastedSpellArgs *self)
{
	LastCastedSpellArgs *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyLastCastedSpellArgs__tp_richcompare(PyLastCastedSpellArgs *PYBINDGEN_UNUSED(self), PyLastCastedSpellArgs *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyLastCastedSpellArgs_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyLastCastedSpellArgs_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.LastCastedSpellArgs",            /* tp_name */
	sizeof(PyLastCastedSpellArgs),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyLastCastedSpellArgs__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"LastCastedSpellArgs(ctor_arg)\nLastCastedSpellArgs()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyLastCastedSpellArgs__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyLastCastedSpellArgs_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyLastCastedSpellArgs__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyLastCastedSpellArgs__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyNavigationPath__get_CurrentWaypoint_(PyNavigationPath *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->CurrentWaypoint_);
	return py_retval;
}
static int _wrap_PyNavigationPath__set_CurrentWaypoint_(PyNavigationPath *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->CurrentWaypoint_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyNavigationPath__get_StartPosition_(PyNavigationPath *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->StartPosition_);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyNavigationPath__set_StartPosition_(PyNavigationPath *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->StartPosition_ = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyNavigationPath__get_EndPosition(PyNavigationPath *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->EndPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyNavigationPath__set_EndPosition(PyNavigationPath *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->EndPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyNavigationPath__get_WaypointStart_(PyNavigationPath *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	if (!(self->obj->WaypointStart_)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->obj = self->obj->WaypointStart_;
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyNavigationPath__set_WaypointStart_(PyNavigationPath *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->WaypointStart_ = new Vec3(*tmp_Vec3->obj);
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyNavigationPath__get_WaypointEnd_(PyNavigationPath *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	if (!(self->obj->WaypointEnd_)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->obj = self->obj->WaypointEnd_;
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyNavigationPath__set_WaypointEnd_(PyNavigationPath *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->WaypointEnd_ = new Vec3(*tmp_Vec3->obj);
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyNavigationPath__getsets[] = {
	{
		(char*) "WaypointEnd_", /* attribute name */
		(getter)_wrap_PyNavigationPath__get_WaypointEnd_, /* C function to get the attribute */
		(setter)_wrap_PyNavigationPath__set_WaypointEnd_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "WaypointStart_", /* attribute name */
		(getter)_wrap_PyNavigationPath__get_WaypointStart_, /* C function to get the attribute */
		(setter)_wrap_PyNavigationPath__set_WaypointStart_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "CurrentWaypoint_", /* attribute name */
		(getter)_wrap_PyNavigationPath__get_CurrentWaypoint_, /* C function to get the attribute */
		(setter)_wrap_PyNavigationPath__set_CurrentWaypoint_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "StartPosition_", /* attribute name */
		(getter)_wrap_PyNavigationPath__get_StartPosition_, /* C function to get the attribute */
		(setter)_wrap_PyNavigationPath__set_StartPosition_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "EndPosition", /* attribute name */
		(getter)_wrap_PyNavigationPath__get_EndPosition, /* C function to get the attribute */
		(setter)_wrap_PyNavigationPath__set_EndPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNavigationPath__tp_init__0(PyNavigationPath *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new NavigationPath();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyNavigationPath__tp_init__1(PyNavigationPath *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyNavigationPath *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyNavigationPath_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new NavigationPath(*((PyNavigationPath *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyNavigationPath__tp_init(PyNavigationPath *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyNavigationPath__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyNavigationPath__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyNavigationPath__copy__(PyNavigationPath *self)
{

	PyNavigationPath *py_copy;
	py_copy = PyObject_New(PyNavigationPath, &PyNavigationPath_Type);
	py_copy->obj = new NavigationPath(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyNavigationPath_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyNavigationPath__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyNavigationPath__tp_dealloc(PyNavigationPath *self)
{
	NavigationPath *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNavigationPath__tp_richcompare(PyNavigationPath *PYBINDGEN_UNUSED(self), PyNavigationPath *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyNavigationPath_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyNavigationPath_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.NavigationPath",            /* tp_name */
	sizeof(PyNavigationPath),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyNavigationPath__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"NavigationPath(ctor_arg)\nNavigationPath()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyNavigationPath__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyNavigationPath_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyNavigationPath__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyNavigationPath__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyUnitDash__get_Source(PyUnitDash *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *py_IUnit;

	if (!(self->obj->Source)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = self->obj->Source;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}
static int _wrap_PyUnitDash__set_Source(PyUnitDash *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Source = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyUnitDash__get_StartPosition(PyUnitDash *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->StartPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyUnitDash__set_StartPosition(PyUnitDash *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->StartPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyUnitDash__get_EndPosition(PyUnitDash *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->EndPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyUnitDash__set_EndPosition(PyUnitDash *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->EndPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyUnitDash__get_StartTick(PyUnitDash *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->StartTick);
	return py_retval;
}
static int _wrap_PyUnitDash__set_StartTick(PyUnitDash *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->StartTick)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyUnitDash__get_EndTick(PyUnitDash *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->EndTick);
	return py_retval;
}
static int _wrap_PyUnitDash__set_EndTick(PyUnitDash *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->EndTick)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyUnitDash__get_Duration(PyUnitDash *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Duration);
	return py_retval;
}
static int _wrap_PyUnitDash__set_Duration(PyUnitDash *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Duration)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyUnitDash__get_Speed(PyUnitDash *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Speed);
	return py_retval;
}
static int _wrap_PyUnitDash__set_Speed(PyUnitDash *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Speed)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyUnitDash__getsets[] = {
	{
		(char*) "EndPosition", /* attribute name */
		(getter)_wrap_PyUnitDash__get_EndPosition, /* C function to get the attribute */
		(setter)_wrap_PyUnitDash__set_EndPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "StartPosition", /* attribute name */
		(getter)_wrap_PyUnitDash__get_StartPosition, /* C function to get the attribute */
		(setter)_wrap_PyUnitDash__set_StartPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Source", /* attribute name */
		(getter)_wrap_PyUnitDash__get_Source, /* C function to get the attribute */
		(setter)_wrap_PyUnitDash__set_Source, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "StartTick", /* attribute name */
		(getter)_wrap_PyUnitDash__get_StartTick, /* C function to get the attribute */
		(setter)_wrap_PyUnitDash__set_StartTick, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Duration", /* attribute name */
		(getter)_wrap_PyUnitDash__get_Duration, /* C function to get the attribute */
		(setter)_wrap_PyUnitDash__set_Duration, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "EndTick", /* attribute name */
		(getter)_wrap_PyUnitDash__get_EndTick, /* C function to get the attribute */
		(setter)_wrap_PyUnitDash__set_EndTick, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Speed", /* attribute name */
		(getter)_wrap_PyUnitDash__get_Speed, /* C function to get the attribute */
		(setter)_wrap_PyUnitDash__set_Speed, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyUnitDash__tp_init__0(PyUnitDash *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new UnitDash();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyUnitDash__tp_init__1(PyUnitDash *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyUnitDash *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyUnitDash_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new UnitDash(*((PyUnitDash *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyUnitDash__tp_init(PyUnitDash *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyUnitDash__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyUnitDash__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyUnitDash__copy__(PyUnitDash *self)
{

	PyUnitDash *py_copy;
	py_copy = PyObject_New(PyUnitDash, &PyUnitDash_Type);
	py_copy->obj = new UnitDash(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyUnitDash_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyUnitDash__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyUnitDash__tp_dealloc(PyUnitDash *self)
{
	UnitDash *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyUnitDash__tp_richcompare(PyUnitDash *PYBINDGEN_UNUSED(self), PyUnitDash *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyUnitDash_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyUnitDash_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.UnitDash",            /* tp_name */
	sizeof(PyUnitDash),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyUnitDash__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"UnitDash(ctor_arg)\nUnitDash()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyUnitDash__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyUnitDash_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyUnitDash__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyUnitDash__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyOnTeleportArgs__get_Source(PyOnTeleportArgs *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *py_IUnit;

	if (!(self->obj->Source)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = self->obj->Source;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}
static int _wrap_PyOnTeleportArgs__set_Source(PyOnTeleportArgs *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Source = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyOnTeleportArgs__get_Type(PyOnTeleportArgs *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Type);
	return py_retval;
}
static int _wrap_PyOnTeleportArgs__set_Type(PyOnTeleportArgs *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Type)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyOnTeleportArgs__get_Status(PyOnTeleportArgs *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Status);
	return py_retval;
}
static int _wrap_PyOnTeleportArgs__set_Status(PyOnTeleportArgs *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Status)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyOnTeleportArgs__get_Duration(PyOnTeleportArgs *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Duration);
	return py_retval;
}
static int _wrap_PyOnTeleportArgs__set_Duration(PyOnTeleportArgs *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Duration)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyOnTeleportArgs__getsets[] = {
	{
		(char*) "Status", /* attribute name */
		(getter)_wrap_PyOnTeleportArgs__get_Status, /* C function to get the attribute */
		(setter)_wrap_PyOnTeleportArgs__set_Status, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Source", /* attribute name */
		(getter)_wrap_PyOnTeleportArgs__get_Source, /* C function to get the attribute */
		(setter)_wrap_PyOnTeleportArgs__set_Source, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Type", /* attribute name */
		(getter)_wrap_PyOnTeleportArgs__get_Type, /* C function to get the attribute */
		(setter)_wrap_PyOnTeleportArgs__set_Type, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Duration", /* attribute name */
		(getter)_wrap_PyOnTeleportArgs__get_Duration, /* C function to get the attribute */
		(setter)_wrap_PyOnTeleportArgs__set_Duration, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyOnTeleportArgs__tp_init__0(PyOnTeleportArgs *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new OnTeleportArgs();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyOnTeleportArgs__tp_init__1(PyOnTeleportArgs *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyOnTeleportArgs *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyOnTeleportArgs_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new OnTeleportArgs(*((PyOnTeleportArgs *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyOnTeleportArgs__tp_init(PyOnTeleportArgs *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyOnTeleportArgs__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyOnTeleportArgs__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyOnTeleportArgs__copy__(PyOnTeleportArgs *self)
{

	PyOnTeleportArgs *py_copy;
	py_copy = PyObject_New(PyOnTeleportArgs, &PyOnTeleportArgs_Type);
	py_copy->obj = new OnTeleportArgs(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyOnTeleportArgs_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyOnTeleportArgs__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyOnTeleportArgs__tp_dealloc(PyOnTeleportArgs *self)
{
	OnTeleportArgs *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyOnTeleportArgs__tp_richcompare(PyOnTeleportArgs *PYBINDGEN_UNUSED(self), PyOnTeleportArgs *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyOnTeleportArgs_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyOnTeleportArgs_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.OnTeleportArgs",            /* tp_name */
	sizeof(PyOnTeleportArgs),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyOnTeleportArgs__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"OnTeleportArgs(ctor_arg)\nOnTeleportArgs()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyOnTeleportArgs__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyOnTeleportArgs_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyOnTeleportArgs__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyOnTeleportArgs__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyAdvPredictionInput__get_FromPosition(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->FromPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_FromPosition(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->FromPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_RangeCheckFromPosition(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->RangeCheckFromPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_RangeCheckFromPosition(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->RangeCheckFromPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_IsAoE(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(self->obj->IsAoE));
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_IsAoE(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyObject *py_boolretval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->IsAoE = PyObject_IsTrue(py_boolretval);
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_AddBoundingRadius(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(self->obj->AddBoundingRadius));
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_AddBoundingRadius(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyObject *py_boolretval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->AddBoundingRadius = PyObject_IsTrue(py_boolretval);
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_CollisionFlags(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->CollisionFlags);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_CollisionFlags(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->CollisionFlags)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_Delay(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Delay);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_Delay(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Delay)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_Radius(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Radius);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_Radius(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Radius)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_Range(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Range);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_Range(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Range)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_Speed(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Speed);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_Speed(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Speed)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_Type(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->Type);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_Type(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->Type)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionInput__get_Target(PyAdvPredictionInput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *py_IUnit;

	if (!(self->obj->Target)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = self->obj->Target;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}
static int _wrap_PyAdvPredictionInput__set_Target(PyAdvPredictionInput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Target = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyAdvPredictionInput__getsets[] = {
	{
		(char*) "Target", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_Target, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_Target, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "AddBoundingRadius", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_AddBoundingRadius, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_AddBoundingRadius, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "CollisionFlags", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_CollisionFlags, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_CollisionFlags, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Type", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_Type, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_Type, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "IsAoE", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_IsAoE, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_IsAoE, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Delay", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_Delay, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_Delay, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Range", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_Range, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_Range, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Radius", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_Radius, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_Radius, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Speed", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_Speed, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_Speed, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "FromPosition", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_FromPosition, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_FromPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "RangeCheckFromPosition", /* attribute name */
		(getter)_wrap_PyAdvPredictionInput__get_RangeCheckFromPosition, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionInput__set_RangeCheckFromPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyAdvPredictionInput__tp_init__0(PyAdvPredictionInput *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new AdvPredictionInput();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyAdvPredictionInput__tp_init__1(PyAdvPredictionInput *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyAdvPredictionInput *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyAdvPredictionInput_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new AdvPredictionInput(*((PyAdvPredictionInput *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyAdvPredictionInput__tp_init(PyAdvPredictionInput *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyAdvPredictionInput__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyAdvPredictionInput__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyAdvPredictionInput__copy__(PyAdvPredictionInput *self)
{

	PyAdvPredictionInput *py_copy;
	py_copy = PyObject_New(PyAdvPredictionInput, &PyAdvPredictionInput_Type);
	py_copy->obj = new AdvPredictionInput(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyAdvPredictionInput_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyAdvPredictionInput__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyAdvPredictionInput__tp_dealloc(PyAdvPredictionInput *self)
{
	AdvPredictionInput *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyAdvPredictionInput__tp_richcompare(PyAdvPredictionInput *PYBINDGEN_UNUSED(self), PyAdvPredictionInput *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyAdvPredictionInput_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyAdvPredictionInput_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.AdvPredictionInput",            /* tp_name */
	sizeof(PyAdvPredictionInput),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyAdvPredictionInput__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"AdvPredictionInput(ctor_arg)\nAdvPredictionInput()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyAdvPredictionInput__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyAdvPredictionInput_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyAdvPredictionInput__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyAdvPredictionInput__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyAdvPredictionOutput__get_HitChance(PyAdvPredictionOutput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->HitChance);
	return py_retval;
}
static int _wrap_PyAdvPredictionOutput__set_HitChance(PyAdvPredictionOutput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->HitChance)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionOutput__get_CastPosition(PyAdvPredictionOutput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->CastPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyAdvPredictionOutput__set_CastPosition(PyAdvPredictionOutput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->CastPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionOutput__get_TargetPosition(PyAdvPredictionOutput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->TargetPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyAdvPredictionOutput__set_TargetPosition(PyAdvPredictionOutput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->TargetPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyAdvPredictionOutput__get_AoETargetsHit(PyAdvPredictionOutput *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(self->obj->AoETargetsHit);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}
static int _wrap_PyAdvPredictionOutput__set_AoETargetsHit(PyAdvPredictionOutput *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	std::vector< IUnit * > retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O&", _wrap_convert_py2c__std__vector__lt___IUnit___star_____gt__, &self->obj->AoETargetsHit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyAdvPredictionOutput__getsets[] = {
	{
		(char*) "CastPosition", /* attribute name */
		(getter)_wrap_PyAdvPredictionOutput__get_CastPosition, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionOutput__set_CastPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "HitChance", /* attribute name */
		(getter)_wrap_PyAdvPredictionOutput__get_HitChance, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionOutput__set_HitChance, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "TargetPosition", /* attribute name */
		(getter)_wrap_PyAdvPredictionOutput__get_TargetPosition, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionOutput__set_TargetPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "AoETargetsHit", /* attribute name */
		(getter)_wrap_PyAdvPredictionOutput__get_AoETargetsHit, /* C function to get the attribute */
		(setter)_wrap_PyAdvPredictionOutput__set_AoETargetsHit, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyAdvPredictionOutput__tp_init__0(PyAdvPredictionOutput *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new AdvPredictionOutput();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyAdvPredictionOutput__tp_init__1(PyAdvPredictionOutput *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyAdvPredictionOutput *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyAdvPredictionOutput_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new AdvPredictionOutput(*((PyAdvPredictionOutput *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyAdvPredictionOutput__tp_init(PyAdvPredictionOutput *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyAdvPredictionOutput__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyAdvPredictionOutput__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyAdvPredictionOutput__copy__(PyAdvPredictionOutput *self)
{

	PyAdvPredictionOutput *py_copy;
	py_copy = PyObject_New(PyAdvPredictionOutput, &PyAdvPredictionOutput_Type);
	py_copy->obj = new AdvPredictionOutput(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyAdvPredictionOutput_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyAdvPredictionOutput__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyAdvPredictionOutput__tp_dealloc(PyAdvPredictionOutput *self)
{
	AdvPredictionOutput *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyAdvPredictionOutput__tp_richcompare(PyAdvPredictionOutput *PYBINDGEN_UNUSED(self), PyAdvPredictionOutput *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyAdvPredictionOutput_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyAdvPredictionOutput_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.AdvPredictionOutput",            /* tp_name */
	sizeof(PyAdvPredictionOutput),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyAdvPredictionOutput__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"AdvPredictionOutput(ctor_arg)\nAdvPredictionOutput()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyAdvPredictionOutput__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyAdvPredictionOutput_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyAdvPredictionOutput__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyAdvPredictionOutput__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyInterruptibleSpell__get_Source(PyInterruptibleSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *py_IUnit;

	if (!(self->obj->Source)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = self->obj->Source;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}
static int _wrap_PyInterruptibleSpell__set_Source(PyInterruptibleSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Source = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyInterruptibleSpell__get_DangerLevel(PyInterruptibleSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->DangerLevel);
	return py_retval;
}
static int _wrap_PyInterruptibleSpell__set_DangerLevel(PyInterruptibleSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->DangerLevel)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyInterruptibleSpell__get_EndTime(PyInterruptibleSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "f", self->obj->EndTime);
	return py_retval;
}
static int _wrap_PyInterruptibleSpell__set_EndTime(PyInterruptibleSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->EndTime)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyInterruptibleSpell__get_MovementInterupts(PyInterruptibleSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(self->obj->MovementInterupts));
	return py_retval;
}
static int _wrap_PyInterruptibleSpell__set_MovementInterupts(PyInterruptibleSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyObject *py_boolretval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->MovementInterupts = PyObject_IsTrue(py_boolretval);
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyInterruptibleSpell__getsets[] = {
	{
		(char*) "Source", /* attribute name */
		(getter)_wrap_PyInterruptibleSpell__get_Source, /* C function to get the attribute */
		(setter)_wrap_PyInterruptibleSpell__set_Source, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "DangerLevel", /* attribute name */
		(getter)_wrap_PyInterruptibleSpell__get_DangerLevel, /* C function to get the attribute */
		(setter)_wrap_PyInterruptibleSpell__set_DangerLevel, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "EndTime", /* attribute name */
		(getter)_wrap_PyInterruptibleSpell__get_EndTime, /* C function to get the attribute */
		(setter)_wrap_PyInterruptibleSpell__set_EndTime, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "MovementInterupts", /* attribute name */
		(getter)_wrap_PyInterruptibleSpell__get_MovementInterupts, /* C function to get the attribute */
		(setter)_wrap_PyInterruptibleSpell__set_MovementInterupts, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyInterruptibleSpell__tp_init__0(PyInterruptibleSpell *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new InterruptibleSpell();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyInterruptibleSpell__tp_init__1(PyInterruptibleSpell *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyInterruptibleSpell *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyInterruptibleSpell_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new InterruptibleSpell(*((PyInterruptibleSpell *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyInterruptibleSpell__tp_init(PyInterruptibleSpell *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyInterruptibleSpell__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyInterruptibleSpell__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyInterruptibleSpell__copy__(PyInterruptibleSpell *self)
{

	PyInterruptibleSpell *py_copy;
	py_copy = PyObject_New(PyInterruptibleSpell, &PyInterruptibleSpell_Type);
	py_copy->obj = new InterruptibleSpell(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyInterruptibleSpell_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyInterruptibleSpell__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyInterruptibleSpell__tp_dealloc(PyInterruptibleSpell *self)
{
	InterruptibleSpell *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyInterruptibleSpell__tp_richcompare(PyInterruptibleSpell *PYBINDGEN_UNUSED(self), PyInterruptibleSpell *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyInterruptibleSpell_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyInterruptibleSpell_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.InterruptibleSpell",            /* tp_name */
	sizeof(PyInterruptibleSpell),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyInterruptibleSpell__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"InterruptibleSpell(ctor_arg)\nInterruptibleSpell()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyInterruptibleSpell__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyInterruptibleSpell_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyInterruptibleSpell__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyInterruptibleSpell__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyGapCloserSpell__get_Source(PyGapCloserSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *py_IUnit;

	if (!(self->obj->Source)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = self->obj->Source;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}
static int _wrap_PyGapCloserSpell__set_Source(PyGapCloserSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Source = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyGapCloserSpell__get_StartPosition(PyGapCloserSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->StartPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyGapCloserSpell__set_StartPosition(PyGapCloserSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->StartPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyGapCloserSpell__get_EndPosition(PyGapCloserSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->EndPosition);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyGapCloserSpell__set_EndPosition(PyGapCloserSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->EndPosition = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyGapCloserSpell__get_IsTargeted(PyGapCloserSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(self->obj->IsTargeted));
	return py_retval;
}
static int _wrap_PyGapCloserSpell__set_IsTargeted(PyGapCloserSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyObject *py_boolretval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->IsTargeted = PyObject_IsTrue(py_boolretval);
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyGapCloserSpell__get_StartTick(PyGapCloserSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->StartTick);
	return py_retval;
}
static int _wrap_PyGapCloserSpell__set_StartTick(PyGapCloserSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->StartTick)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyGapCloserSpell__get_Slot(PyGapCloserSpell *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Slot);
	return py_retval;
}
static int _wrap_PyGapCloserSpell__set_Slot(PyGapCloserSpell *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Slot)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyGapCloserSpell__getsets[] = {
	{
		(char*) "Slot", /* attribute name */
		(getter)_wrap_PyGapCloserSpell__get_Slot, /* C function to get the attribute */
		(setter)_wrap_PyGapCloserSpell__set_Slot, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "IsTargeted", /* attribute name */
		(getter)_wrap_PyGapCloserSpell__get_IsTargeted, /* C function to get the attribute */
		(setter)_wrap_PyGapCloserSpell__set_IsTargeted, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "EndPosition", /* attribute name */
		(getter)_wrap_PyGapCloserSpell__get_EndPosition, /* C function to get the attribute */
		(setter)_wrap_PyGapCloserSpell__set_EndPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "StartPosition", /* attribute name */
		(getter)_wrap_PyGapCloserSpell__get_StartPosition, /* C function to get the attribute */
		(setter)_wrap_PyGapCloserSpell__set_StartPosition, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Source", /* attribute name */
		(getter)_wrap_PyGapCloserSpell__get_Source, /* C function to get the attribute */
		(setter)_wrap_PyGapCloserSpell__set_Source, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "StartTick", /* attribute name */
		(getter)_wrap_PyGapCloserSpell__get_StartTick, /* C function to get the attribute */
		(setter)_wrap_PyGapCloserSpell__set_StartTick, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyGapCloserSpell__tp_init__0(PyGapCloserSpell *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new GapCloserSpell();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyGapCloserSpell__tp_init__1(PyGapCloserSpell *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyGapCloserSpell *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyGapCloserSpell_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new GapCloserSpell(*((PyGapCloserSpell *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyGapCloserSpell__tp_init(PyGapCloserSpell *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyGapCloserSpell__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyGapCloserSpell__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyGapCloserSpell__copy__(PyGapCloserSpell *self)
{

	PyGapCloserSpell *py_copy;
	py_copy = PyObject_New(PyGapCloserSpell, &PyGapCloserSpell_Type);
	py_copy->obj = new GapCloserSpell(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyGapCloserSpell_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyGapCloserSpell__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyGapCloserSpell__tp_dealloc(PyGapCloserSpell *self)
{
	GapCloserSpell *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyGapCloserSpell__tp_richcompare(PyGapCloserSpell *PYBINDGEN_UNUSED(self), PyGapCloserSpell *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyGapCloserSpell_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyGapCloserSpell_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.GapCloserSpell",            /* tp_name */
	sizeof(PyGapCloserSpell),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyGapCloserSpell__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"GapCloserSpell(ctor_arg)\nGapCloserSpell()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyGapCloserSpell__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyGapCloserSpell_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyGapCloserSpell__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyGapCloserSpell__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyItemData__get_Name_(PyItemData *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "c", (int)self->obj->Name_);
	return py_retval;
}
static int _wrap_PyItemData__set_Name_(PyItemData *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "c", &self->obj->Name_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyItemData__get_Id_(PyItemData *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Id_);
	return py_retval;
}
static int _wrap_PyItemData__set_Id_(PyItemData *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Id_)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyItemData__getsets[] = {
	{
		(char*) "Name_", /* attribute name */
		(getter)_wrap_PyItemData__get_Name_, /* C function to get the attribute */
		(setter)_wrap_PyItemData__set_Name_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Id_", /* attribute name */
		(getter)_wrap_PyItemData__get_Id_, /* C function to get the attribute */
		(setter)_wrap_PyItemData__set_Id_, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyItemData__tp_init__0(PyItemData *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new ItemData();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyItemData__tp_init__1(PyItemData *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyItemData *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyItemData_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new ItemData(*((PyItemData *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyItemData__tp_init(PyItemData *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyItemData__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyItemData__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyItemData__copy__(PyItemData *self)
{

	PyItemData *py_copy;
	py_copy = PyObject_New(PyItemData, &PyItemData_Type);
	py_copy->obj = new ItemData(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyItemData_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyItemData__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyItemData__tp_dealloc(PyItemData *self)
{
	ItemData *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyItemData__tp_richcompare(PyItemData *PYBINDGEN_UNUSED(self), PyItemData *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyItemData_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyItemData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.ItemData",            /* tp_name */
	sizeof(PyItemData),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyItemData__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"ItemData(ctor_arg)\nItemData()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyItemData__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyItemData_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyItemData__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyItemData__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyJungleNotifyData__get_Position(PyJungleNotifyData *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(self->obj->Position);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}
static int _wrap_PyJungleNotifyData__set_Position(PyJungleNotifyData *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;
	PyVec3 *tmp_Vec3;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyVec3_Type, &tmp_Vec3)) {
		Py_DECREF(py_retval);
		return -1;
	}
	self->obj->Position = *tmp_Vec3->obj;
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyJungleNotifyData__getsets[] = {
	{
		(char*) "Position", /* attribute name */
		(getter)_wrap_PyJungleNotifyData__get_Position, /* C function to get the attribute */
		(setter)_wrap_PyJungleNotifyData__set_Position, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyJungleNotifyData__tp_init__0(PyJungleNotifyData *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new JungleNotifyData();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyJungleNotifyData__tp_init__1(PyJungleNotifyData *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyJungleNotifyData *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyJungleNotifyData_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new JungleNotifyData(*((PyJungleNotifyData *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyJungleNotifyData__tp_init(PyJungleNotifyData *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyJungleNotifyData__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyJungleNotifyData__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyJungleNotifyData__copy__(PyJungleNotifyData *self)
{

	PyJungleNotifyData *py_copy;
	py_copy = PyObject_New(PyJungleNotifyData, &PyJungleNotifyData_Type);
	py_copy->obj = new JungleNotifyData(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyJungleNotifyData_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyJungleNotifyData__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyJungleNotifyData__tp_dealloc(PyJungleNotifyData *self)
{
	JungleNotifyData *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyJungleNotifyData__tp_richcompare(PyJungleNotifyData *PYBINDGEN_UNUSED(self), PyJungleNotifyData *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyJungleNotifyData_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyJungleNotifyData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.JungleNotifyData",            /* tp_name */
	sizeof(PyJungleNotifyData),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyJungleNotifyData__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"JungleNotifyData(ctor_arg)\nJungleNotifyData()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyJungleNotifyData__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyJungleNotifyData_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyJungleNotifyData__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyJungleNotifyData__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};



static PyObject* _wrap_PyHeroMastery__get_PageId(PyHeroMastery *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->PageId);
	return py_retval;
}
static int _wrap_PyHeroMastery__set_PageId(PyHeroMastery *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->PageId)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyHeroMastery__get_MasteryId(PyHeroMastery *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->MasteryId);
	return py_retval;
}
static int _wrap_PyHeroMastery__set_MasteryId(PyHeroMastery *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->MasteryId)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyObject* _wrap_PyHeroMastery__get_Points(PyHeroMastery *self, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "i", self->obj->Points);
	return py_retval;
}
static int _wrap_PyHeroMastery__set_Points(PyHeroMastery *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->Points)) {
		Py_DECREF(py_retval);
		return -1;
	}
	Py_DECREF(py_retval);
	return 0;
}
static PyGetSetDef PyHeroMastery__getsets[] = {
	{
		(char*) "MasteryId", /* attribute name */
		(getter)_wrap_PyHeroMastery__get_MasteryId, /* C function to get the attribute */
		(setter)_wrap_PyHeroMastery__set_MasteryId, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "Points", /* attribute name */
		(getter)_wrap_PyHeroMastery__get_Points, /* C function to get the attribute */
		(setter)_wrap_PyHeroMastery__set_Points, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{
		(char*) "PageId", /* attribute name */
		(getter)_wrap_PyHeroMastery__get_PageId, /* C function to get the attribute */
		(setter)_wrap_PyHeroMastery__set_PageId, /* C function to set the attribute */
		NULL, /* optional doc string */
		NULL /* optional additional data for getter and setter */
	},
	{ NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyHeroMastery__tp_init__0(PyHeroMastery *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new HeroMastery();
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

static int
_wrap_PyHeroMastery__tp_init__1(PyHeroMastery *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyHeroMastery *ctor_arg;
	const char *keywords[] = { "ctor_arg", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyHeroMastery_Type, &ctor_arg)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return -1;
	}
	self->obj = new HeroMastery(*((PyHeroMastery *)ctor_arg)->obj);
	self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return 0;
}

int _wrap_PyHeroMastery__tp_init(PyHeroMastery *self, PyObject *args, PyObject *kwargs)
{
	int retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyHeroMastery__tp_init__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyHeroMastery__tp_init__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return -1;
}


static PyObject*
_wrap_PyHeroMastery__copy__(PyHeroMastery *self)
{

	PyHeroMastery *py_copy;
	py_copy = PyObject_New(PyHeroMastery, &PyHeroMastery_Type);
	py_copy->obj = new HeroMastery(*self->obj);
	py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	return (PyObject*)py_copy;
}

static PyMethodDef PyHeroMastery_methods[] = {
	{ (char *) "__copy__", (PyCFunction)_wrap_PyHeroMastery__copy__, METH_NOARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyHeroMastery__tp_dealloc(PyHeroMastery *self)
{
	HeroMastery *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyHeroMastery__tp_richcompare(PyHeroMastery *PYBINDGEN_UNUSED(self), PyHeroMastery *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyHeroMastery_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyHeroMastery_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.HeroMastery",            /* tp_name */
	sizeof(PyHeroMastery),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyHeroMastery__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"HeroMastery(ctor_arg)\nHeroMastery()",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyHeroMastery__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyHeroMastery_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	PyHeroMastery__getsets,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyHeroMastery__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyISpellBook__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'ISpellBook' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyISpellBook_GetCastTime(PyISpellBook *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetCastTime();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_IsCharging(PyISpellBook *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsCharging();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetAmmo(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetAmmo(Slot);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetSpellCastTime(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetSpellCastTime(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetCastEndTime(PyISpellBook *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetCastEndTime();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetCastConeAngle(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetCastConeAngle(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetNextCastTime(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetNextCastTime(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetRange(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetRange(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetAmmoUsed(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetAmmoUsed(Slot);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetSpeed(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetSpeed(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetManaCost(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetManaCost(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetRadius(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetRadius(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetSpellState(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetSpellState(Slot);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetName(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetName(Slot);
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_IsChanneling(PyISpellBook *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsChanneling();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetTotalCooldown(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetTotalCooldown(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetLevel(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetLevel(Slot);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_IsValidSpell(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->IsValidSpell(Slot);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetMaxAmmo(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetMaxAmmo(Slot);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetAmmoRechargeTime(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetAmmoRechargeTime(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetBaseDamage(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetBaseDamage(Slot);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpellBook_GetToggleState(PyISpellBook *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->GetToggleState(Slot);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}

static PyMethodDef PyISpellBook_methods[] = {
	{ (char *) "GetCastTime", (PyCFunction)_wrap_PyISpellBook_GetCastTime, METH_NOARGS, "GetCastTime()\n\n" },
	{ (char *) "IsCharging", (PyCFunction)_wrap_PyISpellBook_IsCharging, METH_NOARGS, "IsCharging()\n\n" },
	{ (char *) "GetAmmo", (PyCFunction)_wrap_PyISpellBook_GetAmmo, METH_KEYWORDS | METH_VARARGS, "GetAmmo(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetSpellCastTime", (PyCFunction)_wrap_PyISpellBook_GetSpellCastTime, METH_KEYWORDS | METH_VARARGS, "GetSpellCastTime(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetCastEndTime", (PyCFunction)_wrap_PyISpellBook_GetCastEndTime, METH_NOARGS, "GetCastEndTime()\n\n" },
	{ (char *) "GetCastConeAngle", (PyCFunction)_wrap_PyISpellBook_GetCastConeAngle, METH_KEYWORDS | METH_VARARGS, "GetCastConeAngle(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetNextCastTime", (PyCFunction)_wrap_PyISpellBook_GetNextCastTime, METH_KEYWORDS | METH_VARARGS, "GetNextCastTime(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetRange", (PyCFunction)_wrap_PyISpellBook_GetRange, METH_KEYWORDS | METH_VARARGS, "GetRange(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetAmmoUsed", (PyCFunction)_wrap_PyISpellBook_GetAmmoUsed, METH_KEYWORDS | METH_VARARGS, "GetAmmoUsed(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetSpeed", (PyCFunction)_wrap_PyISpellBook_GetSpeed, METH_KEYWORDS | METH_VARARGS, "GetSpeed(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetManaCost", (PyCFunction)_wrap_PyISpellBook_GetManaCost, METH_KEYWORDS | METH_VARARGS, "GetManaCost(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetRadius", (PyCFunction)_wrap_PyISpellBook_GetRadius, METH_KEYWORDS | METH_VARARGS, "GetRadius(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetSpellState", (PyCFunction)_wrap_PyISpellBook_GetSpellState, METH_KEYWORDS | METH_VARARGS, "GetSpellState(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetName", (PyCFunction)_wrap_PyISpellBook_GetName, METH_KEYWORDS | METH_VARARGS, "GetName(Slot)\n\ntype: Slot: int" },
	{ (char *) "IsChanneling", (PyCFunction)_wrap_PyISpellBook_IsChanneling, METH_NOARGS, "IsChanneling()\n\n" },
	{ (char *) "GetTotalCooldown", (PyCFunction)_wrap_PyISpellBook_GetTotalCooldown, METH_KEYWORDS | METH_VARARGS, "GetTotalCooldown(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetLevel", (PyCFunction)_wrap_PyISpellBook_GetLevel, METH_KEYWORDS | METH_VARARGS, "GetLevel(Slot)\n\ntype: Slot: int" },
	{ (char *) "IsValidSpell", (PyCFunction)_wrap_PyISpellBook_IsValidSpell, METH_KEYWORDS | METH_VARARGS, "IsValidSpell(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetMaxAmmo", (PyCFunction)_wrap_PyISpellBook_GetMaxAmmo, METH_KEYWORDS | METH_VARARGS, "GetMaxAmmo(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetAmmoRechargeTime", (PyCFunction)_wrap_PyISpellBook_GetAmmoRechargeTime, METH_KEYWORDS | METH_VARARGS, "GetAmmoRechargeTime(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetBaseDamage", (PyCFunction)_wrap_PyISpellBook_GetBaseDamage, METH_KEYWORDS | METH_VARARGS, "GetBaseDamage(Slot)\n\ntype: Slot: int" },
	{ (char *) "GetToggleState", (PyCFunction)_wrap_PyISpellBook_GetToggleState, METH_KEYWORDS | METH_VARARGS, "GetToggleState(Slot)\n\ntype: Slot: int" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyISpellBook__tp_dealloc(PyISpellBook *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyISpellBook__tp_richcompare(PyISpellBook *PYBINDGEN_UNUSED(self), PyISpellBook *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyISpellBook_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyISpellBook_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.ISpellBook",            /* tp_name */
	sizeof(PyISpellBook),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyISpellBook__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyISpellBook__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyISpellBook_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyISpellBook__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIFont__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IFont' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIFont_SetOutline(PyIFont *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Enabled;
	PyObject *py_Enabled;
	const char *keywords[] = { "Enabled", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **)keywords, &py_Enabled)) {
		return NULL;
	}
	Enabled = (bool)PyObject_IsTrue(py_Enabled);
	self->obj->SetOutline(Enabled);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIFont_SetLocationFlags(PyIFont *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int Flags;
	const char *keywords[] = { "Flags", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Flags)) {
		return NULL;
	}
	self->obj->SetLocationFlags(Flags);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIFont_SetColor(PyIFont *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec4 *Color;
	const char *keywords[] = { "Color", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec4_Type, &Color)) {
		return NULL;
	}
	self->obj->SetColor(*((PyVec4 *)Color)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIFont_Render(PyIFont *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float XPosition;
	float YPosition;
	char const *Message;
	const char *keywords[] = { "XPosition", "YPosition", "Message", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ffs", (char **)keywords, &XPosition, &YPosition, &Message)) {
		return NULL;
	}
	self->obj->Render(XPosition, YPosition, Message);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

static PyMethodDef PyIFont_methods[] = {
	{ (char *) "SetOutline", (PyCFunction)_wrap_PyIFont_SetOutline, METH_KEYWORDS | METH_VARARGS, "SetOutline(Enabled)\n\ntype: Enabled: bool" },
	{ (char *) "SetLocationFlags", (PyCFunction)_wrap_PyIFont_SetLocationFlags, METH_KEYWORDS | METH_VARARGS, "SetLocationFlags(Flags)\n\ntype: Flags: int" },
	{ (char *) "SetColor", (PyCFunction)_wrap_PyIFont_SetColor, METH_KEYWORDS | METH_VARARGS, "SetColor(Color)\n\ntype: Color: Vec4 const &" },
	{ (char *) "Render", (PyCFunction)_wrap_PyIFont_Render, METH_KEYWORDS | METH_VARARGS, "Render(XPosition, YPosition, Message)\n\ntype: XPosition: float\ntype: YPosition: float\ntype: Message: char const *" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIFont__tp_dealloc(PyIFont *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIFont__tp_richcompare(PyIFont *PYBINDGEN_UNUSED(self), PyIFont *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIFont_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIFont_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IFont",            /* tp_name */
	sizeof(PyIFont),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIFont__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIFont__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIFont_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIFont__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyITexture__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'ITexture' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyITexture_SetScaleBySize(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *WantedSize;
	const char *keywords[] = { "WantedSize", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &WantedSize)) {
		return NULL;
	}
	self->obj->SetScaleBySize(*((PyVec2 *)WantedSize)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyITexture_Draw(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float XPosition;
	float YPosition;
	const char *keywords[] = { "XPosition", "YPosition", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ff", (char **)keywords, &XPosition, &YPosition)) {
		return NULL;
	}
	self->obj->Draw(XPosition, YPosition);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}



PyObject *
_wrap_PyITexture_Scale__0(PyITexture *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float ScaledPercent;
	const char *keywords[] = { "ScaledPercent", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &ScaledPercent)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->Scale(ScaledPercent);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyITexture_Scale__1(PyITexture *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float WidthPercent;
	float HeightPercent;
	const char *keywords[] = { "WidthPercent", "HeightPercent", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ff", (char **)keywords, &WidthPercent, &HeightPercent)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->Scale(WidthPercent, HeightPercent);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyITexture_Scale(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyITexture_Scale__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyITexture_Scale__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyITexture_GetScaledOffset(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *NewSize;
	const char *keywords[] = { "NewSize", NULL };
	PyVec2 *py_Vec2;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &NewSize)) {
		return NULL;
	}
	Vec2 const & retval = self->obj->GetScaledOffset(*((PyVec2 *)NewSize)->obj);
	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}


PyObject *
_wrap_PyITexture_SetColor(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec4 *Color;
	const char *keywords[] = { "Color", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec4_Type, &Color)) {
		return NULL;
	}
	self->obj->SetColor(*((PyVec4 *)Color)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyITexture_GetScaledSize(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *OriginalSize;
	const char *keywords[] = { "OriginalSize", NULL };
	PyVec2 *py_Vec2;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &OriginalSize)) {
		return NULL;
	}
	Vec2 const & retval = self->obj->GetScaledSize(*((PyVec2 *)OriginalSize)->obj);
	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}


PyObject *
_wrap_PyITexture_GetSize(PyITexture *self)
{
	PyObject *py_retval;
	PyVec2 *py_Vec2;

	Vec2 const & retval = self->obj->GetSize();
	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}


PyObject *
_wrap_PyITexture_DrawCircle(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float XPosition;
	float YPosition;
	float Radius;
	const char *keywords[] = { "XPosition", "YPosition", "Radius", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "fff", (char **)keywords, &XPosition, &YPosition, &Radius)) {
		return NULL;
	}
	self->obj->DrawCircle(XPosition, YPosition, Radius);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}



PyObject *
_wrap_PyITexture_Resize__0(PyITexture *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float Size;
	const char *keywords[] = { "Size", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &Size)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->Resize(Size);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyITexture_Resize__1(PyITexture *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float WidthSize;
	float HeightSize;
	const char *keywords[] = { "WidthSize", "HeightSize", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ff", (char **)keywords, &WidthSize, &HeightSize)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->Resize(WidthSize, HeightSize);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyITexture_Resize(PyITexture *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyITexture_Resize__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyITexture_Resize__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}

static PyMethodDef PyITexture_methods[] = {
	{ (char *) "SetScaleBySize", (PyCFunction)_wrap_PyITexture_SetScaleBySize, METH_KEYWORDS | METH_VARARGS, "SetScaleBySize(WantedSize)\n\ntype: WantedSize: Vec2 const &" },
	{ (char *) "Draw", (PyCFunction)_wrap_PyITexture_Draw, METH_KEYWORDS | METH_VARARGS, "Draw(XPosition, YPosition)\n\ntype: XPosition: float\ntype: YPosition: float" },
	{ (char *) "Scale", (PyCFunction)_wrap_PyITexture_Scale, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "GetScaledOffset", (PyCFunction)_wrap_PyITexture_GetScaledOffset, METH_KEYWORDS | METH_VARARGS, "GetScaledOffset(NewSize)\n\ntype: NewSize: Vec2 const &" },
	{ (char *) "SetColor", (PyCFunction)_wrap_PyITexture_SetColor, METH_KEYWORDS | METH_VARARGS, "SetColor(Color)\n\ntype: Color: Vec4 const &" },
	{ (char *) "GetScaledSize", (PyCFunction)_wrap_PyITexture_GetScaledSize, METH_KEYWORDS | METH_VARARGS, "GetScaledSize(OriginalSize)\n\ntype: OriginalSize: Vec2 const &" },
	{ (char *) "GetSize", (PyCFunction)_wrap_PyITexture_GetSize, METH_NOARGS, "GetSize()\n\n" },
	{ (char *) "DrawCircle", (PyCFunction)_wrap_PyITexture_DrawCircle, METH_KEYWORDS | METH_VARARGS, "DrawCircle(XPosition, YPosition, Radius)\n\ntype: XPosition: float\ntype: YPosition: float\ntype: Radius: float" },
	{ (char *) "Resize", (PyCFunction)_wrap_PyITexture_Resize, METH_KEYWORDS | METH_VARARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyITexture__tp_dealloc(PyITexture *self)
{
	ITexture *tmp = self->obj;
	self->obj = NULL;
	if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
		delete tmp;
	}
	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyITexture__tp_richcompare(PyITexture *PYBINDGEN_UNUSED(self), PyITexture *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyITexture_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyITexture_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.ITexture",            /* tp_name */
	sizeof(PyITexture),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyITexture__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyITexture__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyITexture_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyITexture__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIRender__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IRender' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIRender_CreateFont(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IFont *retval;
	char const *Typeface;
	float Size;
	int Weight;
	const char *keywords[] = { "Typeface", "Size", "Weight", NULL };
	PyIFont *py_IFont;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sfi", (char **)keywords, &Typeface, &Size, &Weight)) {
		return NULL;
	}
	retval = self->obj->CreateFont(Typeface, Size, Weight);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IFont = PyObject_New(PyIFont, &PyIFont_Type);
	py_IFont->obj = retval;
	py_IFont->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IFont);
	return py_retval;
}


PyObject *
_wrap_PyIRender_DrawFilledCircle(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec3 *Position;
	PyVec4 *Color;
	float Radius;
	const char *keywords[] = { "Position", "Color", "Radius", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!f", (char **)keywords, &PyVec3_Type, &Position, &PyVec4_Type, &Color, &Radius)) {
		return NULL;
	}
	self->obj->DrawFilledCircle(*((PyVec3 *)Position)->obj, *((PyVec4 *)Color)->obj, Radius);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIRender_DrawFilledBox(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *Position;
	PyVec2 *size;
	PyVec4 *Color;
	const char *keywords[] = { "Position", "size", "Color", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **)keywords, &PyVec2_Type, &Position, &PyVec2_Type, &size, &PyVec4_Type, &Color)) {
		return NULL;
	}
	self->obj->DrawFilledBox(*((PyVec2 *)Position)->obj, *((PyVec2 *)size)->obj, *((PyVec4 *)Color)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}



PyObject *
_wrap_PyIRender_DrawOutlinedCircle__0(PyIRender *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	PyVec3 *Position;
	PyVec4 *Color;
	float Radius;
	const char *keywords[] = { "Position", "Color", "Radius", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!f", (char **)keywords, &PyVec3_Type, &Position, &PyVec4_Type, &Color, &Radius)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->DrawOutlinedCircle(*((PyVec3 *)Position)->obj, *((PyVec4 *)Color)->obj, Radius);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyIRender_DrawOutlinedCircle__1(PyIRender *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	PyVec2 *Position;
	PyVec4 *Color;
	float Radius;
	const char *keywords[] = { "Position", "Color", "Radius", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!f", (char **)keywords, &PyVec2_Type, &Position, &PyVec4_Type, &Color, &Radius)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->DrawOutlinedCircle(*((PyVec2 *)Position)->obj, *((PyVec4 *)Color)->obj, Radius);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyIRender_DrawOutlinedCircle(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIRender_DrawOutlinedCircle__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIRender_DrawOutlinedCircle__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIRender_DrawLine(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *Position1;
	PyVec2 *Position2;
	PyVec4 *Color;
	const char *keywords[] = { "Position1", "Position2", "Color", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **)keywords, &PyVec2_Type, &Position1, &PyVec2_Type, &Position2, &PyVec4_Type, &Color)) {
		return NULL;
	}
	self->obj->DrawLine(*((PyVec2 *)Position1)->obj, *((PyVec2 *)Position2)->obj, *((PyVec4 *)Color)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIRender_Notification(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec4 *color;
	unsigned long SecondsToShow;
	char const *Message;
	const char *keywords[] = { "color", "SecondsToShow", "Message", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!ks", (char **)keywords, &PyVec4_Type, &color, &SecondsToShow, &Message)) {
		return NULL;
	}
	self->obj->Notification(*((PyVec4 *)color)->obj, SecondsToShow, Message);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIRender_CreateTextureFromFile(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	ITexture *retval;
	char const *TextureName;
	const char *keywords[] = { "TextureName", NULL };
	PyITexture *py_ITexture;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &TextureName)) {
		return NULL;
	}
	retval = self->obj->CreateTextureFromFile(TextureName);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_ITexture = PyObject_New(PyITexture, &PyITexture_Type);
	py_ITexture->obj = retval;
	py_ITexture->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_ITexture);
	return py_retval;
}


PyObject *
_wrap_PyIRender_DrawText(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *Position;
	PyVec4 *Color;
	char const *Text;
	const char *keywords[] = { "Position", "Color", "Text", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!s", (char **)keywords, &PyVec2_Type, &Position, &PyVec4_Type, &Color, &Text)) {
		return NULL;
	}
	self->obj->DrawText(*((PyVec2 *)Position)->obj, *((PyVec4 *)Color)->obj, Text);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIRender_NotificationEx(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec4 *Color;
	unsigned long SecondsToShow;
	bool PrintInChat;
	PyObject *py_PrintInChat;
	bool ShowInCorner;
	PyObject *py_ShowInCorner;
	char const *Message;
	const char *keywords[] = { "Color", "SecondsToShow", "PrintInChat", "ShowInCorner", "Message", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!kOOs", (char **)keywords, &PyVec4_Type, &Color, &SecondsToShow, &py_PrintInChat, &py_ShowInCorner, &Message)) {
		return NULL;
	}
	PrintInChat = (bool)PyObject_IsTrue(py_PrintInChat);
	ShowInCorner = (bool)PyObject_IsTrue(py_ShowInCorner);
	self->obj->NotificationEx(*((PyVec4 *)Color)->obj, SecondsToShow, PrintInChat, ShowInCorner, Message);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIRender_CreateTextureFromMemory(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	ITexture *retval;
	uint8_t Data;
	unsigned int DataLength;
	char const *TextureName;
	const char *keywords[] = { "Data", "DataLength", "TextureName", NULL };
	PyITexture *py_ITexture;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "BIs", (char **)keywords, &Data, &DataLength, &TextureName)) {
		return NULL;
	}
	retval = self->obj->CreateTextureFromMemory(&Data, DataLength, TextureName);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_ITexture = PyObject_New(PyITexture, &PyITexture_Type);
	py_ITexture->obj = retval;
	py_ITexture->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_ITexture);
	return py_retval;
}


PyObject *
_wrap_PyIRender_DrawCircle(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec3 *Position;
	float Radius;
	PyVec4 *Color;
	float Width;
	bool FillCircle;
	PyObject *py_FillCircle = NULL;
	bool ZEnable;
	PyObject *py_ZEnable = NULL;
	const char *keywords[] = { "Position", "Radius", "Color", "Width", "FillCircle", "ZEnable", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!fO!f|OO", (char **)keywords, &PyVec3_Type, &Position, &Radius, &PyVec4_Type, &Color, &Width, &py_FillCircle, &py_ZEnable)) {
		return NULL;
	}
	FillCircle = py_FillCircle ? (bool)PyObject_IsTrue(py_FillCircle) : false;
	ZEnable = py_ZEnable ? (bool)PyObject_IsTrue(py_ZEnable) : false;
	self->obj->DrawCircle(*((PyVec3 *)Position)->obj, Radius, *((PyVec4 *)Color)->obj, Width, FillCircle, ZEnable);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIRender_ScreenSize(PyIRender *self)
{
	PyObject *py_retval;
	PyVec2 *py_Vec2;

	Vec2 const & retval = self->obj->ScreenSize();
	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}


PyObject *
_wrap_PyIRender_DrawOutinedBox(PyIRender *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *Position;
	PyVec2 *size;
	float Width;
	PyVec4 *Color;
	const char *keywords[] = { "Position", "size", "Width", "Color", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!fO!", (char **)keywords, &PyVec2_Type, &Position, &PyVec2_Type, &size, &Width, &PyVec4_Type, &Color)) {
		return NULL;
	}
	self->obj->DrawOutinedBox(*((PyVec2 *)Position)->obj, *((PyVec2 *)size)->obj, Width, *((PyVec4 *)Color)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

static PyMethodDef PyIRender_methods[] = {
	{ (char *) "CreateFont", (PyCFunction)_wrap_PyIRender_CreateFont, METH_KEYWORDS | METH_VARARGS, "CreateFont(Typeface, Size, Weight)\n\ntype: Typeface: char const *\ntype: Size: float\ntype: Weight: int" },
	{ (char *) "DrawFilledCircle", (PyCFunction)_wrap_PyIRender_DrawFilledCircle, METH_KEYWORDS | METH_VARARGS, "DrawFilledCircle(Position, Color, Radius)\n\ntype: Position: Vec3 const &\ntype: Color: Vec4 const &\ntype: Radius: float" },
	{ (char *) "DrawFilledBox", (PyCFunction)_wrap_PyIRender_DrawFilledBox, METH_KEYWORDS | METH_VARARGS, "DrawFilledBox(Position, size, Color)\n\ntype: Position: Vec2 const &\ntype: size: Vec2 const &\ntype: Color: Vec4 const &" },
	{ (char *) "DrawOutlinedCircle", (PyCFunction)_wrap_PyIRender_DrawOutlinedCircle, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "DrawLine", (PyCFunction)_wrap_PyIRender_DrawLine, METH_KEYWORDS | METH_VARARGS, "DrawLine(Position1, Position2, Color)\n\ntype: Position1: Vec2 const &\ntype: Position2: Vec2 const &\ntype: Color: Vec4 const &" },
	{ (char *) "Notification", (PyCFunction)_wrap_PyIRender_Notification, METH_KEYWORDS | METH_VARARGS, "Notification(color, SecondsToShow, Message)\n\ntype: color: Vec4 const &\ntype: SecondsToShow: unsigned long\ntype: Message: char const *" },
	{ (char *) "CreateTextureFromFile", (PyCFunction)_wrap_PyIRender_CreateTextureFromFile, METH_KEYWORDS | METH_VARARGS, "CreateTextureFromFile(TextureName)\n\ntype: TextureName: char const *" },
	{ (char *) "DrawText", (PyCFunction)_wrap_PyIRender_DrawText, METH_KEYWORDS | METH_VARARGS, "DrawText(Position, Color, Text)\n\ntype: Position: Vec2 const &\ntype: Color: Vec4 const &\ntype: Text: char const *" },
	{ (char *) "NotificationEx", (PyCFunction)_wrap_PyIRender_NotificationEx, METH_KEYWORDS | METH_VARARGS, "NotificationEx(Color, SecondsToShow, PrintInChat, ShowInCorner, Message)\n\ntype: Color: Vec4 const &\ntype: SecondsToShow: unsigned long\ntype: PrintInChat: bool\ntype: ShowInCorner: bool\ntype: Message: char const *" },
	{ (char *) "CreateTextureFromMemory", (PyCFunction)_wrap_PyIRender_CreateTextureFromMemory, METH_KEYWORDS | METH_VARARGS, "CreateTextureFromMemory(Data, DataLength, TextureName)\n\ntype: Data: uint8_t *\ntype: DataLength: uint32_t\ntype: TextureName: char const *" },
	{ (char *) "DrawCircle", (PyCFunction)_wrap_PyIRender_DrawCircle, METH_KEYWORDS | METH_VARARGS, "DrawCircle(Position, Radius, Color, Width, FillCircle, ZEnable)\n\ntype: Position: Vec3 const &\ntype: Radius: float\ntype: Color: Vec4 const &\ntype: Width: float\ntype: FillCircle: bool\ntype: ZEnable: bool" },
	{ (char *) "ScreenSize", (PyCFunction)_wrap_PyIRender_ScreenSize, METH_NOARGS, "ScreenSize()\n\n" },
	{ (char *) "DrawOutinedBox", (PyCFunction)_wrap_PyIRender_DrawOutinedBox, METH_KEYWORDS | METH_VARARGS, "DrawOutinedBox(Position, size, Width, Color)\n\ntype: Position: Vec2 const &\ntype: size: Vec2 const &\ntype: Width: float\ntype: Color: Vec4 const &" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIRender__tp_dealloc(PyIRender *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIRender__tp_richcompare(PyIRender *PYBINDGEN_UNUSED(self), PyIRender *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIRender_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIRender_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IRender",            /* tp_name */
	sizeof(PyIRender),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIRender__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIRender__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIRender_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIRender__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyITargetSelector__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'ITargetSelector' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyITargetSelector_FindTarget(PyITargetSelector *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	eTargetPriority Priority;
	eDamageType Type;
	float Range;
	const char *keywords[] = { "Priority", "Type", "Range", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iif", (char **)keywords, &Priority, &Type, &Range)) {
		return NULL;
	}
	retval = self->obj->FindTarget(Priority, Type, Range);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyITargetSelector_GetFocusedTarget(PyITargetSelector *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->GetFocusedTarget();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyITargetSelector_GetHeroPriority(PyITargetSelector *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	PyIUnit *Hero;
	IUnit *Hero_ptr;
	const char *keywords[] = { "Hero", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Hero)) {
		return NULL;
	}
	Hero_ptr = (Hero ? Hero->obj : NULL);
	retval = self->obj->GetHeroPriority(Hero_ptr);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}



PyObject *
_wrap_PyITargetSelector_SetOverrideFocusedTarget__0(PyITargetSelector *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	PyIUnit *Focused;
	IUnit *Focused_ptr;
	const char *keywords[] = { "Focused", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Focused)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Focused_ptr = (Focused ? Focused->obj : NULL);
	self->obj->SetOverrideFocusedTarget(Focused_ptr);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyITargetSelector_SetOverrideFocusedTarget__1(PyITargetSelector *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	PyIUnit *Focused;
	IUnit *Focused_ptr;
	const char *keywords[] = { "Focused", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Focused)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Focused_ptr = (Focused ? Focused->obj : NULL);
	self->obj->SetOverrideFocusedTarget(Focused_ptr);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyITargetSelector_SetOverrideFocusedTarget(PyITargetSelector *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyITargetSelector_SetOverrideFocusedTarget__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyITargetSelector_SetOverrideFocusedTarget__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}

static PyMethodDef PyITargetSelector_methods[] = {
	{ (char *) "FindTarget", (PyCFunction)_wrap_PyITargetSelector_FindTarget, METH_KEYWORDS | METH_VARARGS, "FindTarget(Priority, Type, Range)\n\ntype: Priority: eTargetPriority\ntype: Type: eDamageType\ntype: Range: float" },
	{ (char *) "GetFocusedTarget", (PyCFunction)_wrap_PyITargetSelector_GetFocusedTarget, METH_NOARGS, "GetFocusedTarget()\n\n" },
	{ (char *) "GetHeroPriority", (PyCFunction)_wrap_PyITargetSelector_GetHeroPriority, METH_KEYWORDS | METH_VARARGS, "GetHeroPriority(Hero)\n\ntype: Hero: IUnit *" },
	{ (char *) "SetOverrideFocusedTarget", (PyCFunction)_wrap_PyITargetSelector_SetOverrideFocusedTarget, METH_KEYWORDS | METH_VARARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyITargetSelector__tp_dealloc(PyITargetSelector *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyITargetSelector__tp_richcompare(PyITargetSelector *PYBINDGEN_UNUSED(self), PyITargetSelector *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyITargetSelector_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyITargetSelector_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.ITargetSelector",            /* tp_name */
	sizeof(PyITargetSelector),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyITargetSelector__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyITargetSelector__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyITargetSelector_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyITargetSelector__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIPrediction__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IPrediction' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIPrediction_IsPointWall(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->IsPointWall(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIPrediction_FindBestCastPositionEx(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec3 *StartPosition;
	float Delay;
	float Range;
	float Radius;
	bool IsMissile;
	PyObject *py_IsMissile;
	bool CheckMinions;
	PyObject *py_CheckMinions;
	bool CheckHeroes;
	PyObject *py_CheckHeroes;
	PyVec3 *CastPosition;
	std::vector<IUnit*> EnemiesHit_value;
	const char *keywords[] = { "StartPosition", "Delay", "Range", "Radius", "IsMissile", "CheckMinions", "CheckHeroes", "CastPosition", "EnemiesHit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!fffOOOO!O&", (char **)keywords, &PyVec3_Type, &StartPosition, &Delay, &Range, &Radius, &py_IsMissile, &py_CheckMinions, &py_CheckHeroes, &PyVec3_Type, &CastPosition, _wrap_convert_py2c__std__vector__lt___IUnit___star_____gt__, &EnemiesHit_value)) {
		return NULL;
	}
	IsMissile = (bool)PyObject_IsTrue(py_IsMissile);
	CheckMinions = (bool)PyObject_IsTrue(py_CheckMinions);
	CheckHeroes = (bool)PyObject_IsTrue(py_CheckHeroes);
	self->obj->FindBestCastPositionEx(*((PyVec3 *)StartPosition)->obj, Delay, Range, Radius, IsMissile, CheckMinions, CheckHeroes, *((PyVec3 *)CastPosition)->obj, EnemiesHit_value);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIPrediction_TestLineOfSight(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *StartPosition;
	PyVec3 *EndPosition;
	PyVec3 *CollisionPositionOut;
	int  CollisionFlagsOut;
	const char *keywords[] = { "StartPosition", "EndPosition", "CollisionPositionOut", "CollisionFlagsOut", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **)keywords, &PyVec3_Type, &StartPosition, &PyVec3_Type, &EndPosition, &PyVec3_Type, &CollisionPositionOut, &CollisionFlagsOut)) {
		return NULL;
	}
	retval = self->obj->TestLineOfSight(*((PyVec3 *)StartPosition)->obj, *((PyVec3 *)EndPosition)->obj, *((PyVec3 *)CollisionPositionOut)->obj, CollisionFlagsOut);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIPrediction_SimulateMissile(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	PyVec3 *StartPosition;
	PyIUnit *Target;
	IUnit *Target_ptr;
	float Speed;
	float Radius;
	float Range;
	float Delay;
	int CollisionFlags;
	PyVec3 *CastPosition;
	const char *keywords[] = { "StartPosition", "Target", "Speed", "Radius", "Range", "Delay", "CollisionFlags", "CastPosition", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!ffffiO!", (char **)keywords, &PyVec3_Type, &StartPosition, &PyIUnit_Type, &Target, &Speed, &Radius, &Range, &Delay, &CollisionFlags, &PyVec3_Type, &CastPosition)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->SimulateMissile(*((PyVec3 *)StartPosition)->obj, Target_ptr, Speed, Radius, Range, Delay, CollisionFlags, *((PyVec3 *)CastPosition)->obj);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIPrediction_RunPrediction(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyAdvPredictionInput *Input;
	AdvPredictionInput *Input_ptr;
	PyAdvPredictionOutput *Output;
	AdvPredictionOutput *Output_ptr;
	unsigned int PredictionVersion = 1;
	const char *keywords[] = { "Input", "Output", "PredictionVersion", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!|I", (char **)keywords, &PyAdvPredictionInput_Type, &Input, &PyAdvPredictionOutput_Type, &Output, &PredictionVersion)) {
		return NULL;
	}
	Input_ptr = (Input ? Input->obj : NULL);
	Output_ptr = (Output ? Output->obj : NULL);
	self->obj->RunPrediction(Input_ptr, Output_ptr, PredictionVersion);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIPrediction_GetCollisionFlagsForPoint(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->GetCollisionFlagsForPoint(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIPrediction_IsPointGrass(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->IsPointGrass(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIPrediction_GetFutureUnitPosition(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyIUnit *Player;
	IUnit *Player_ptr;
	float FutureSeconds;
	bool IncludeLatency;
	PyObject *py_IncludeLatency;
	PyVec3 *Out;
	const char *keywords[] = { "Player", "FutureSeconds", "IncludeLatency", "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!fOO!", (char **)keywords, &PyIUnit_Type, &Player, &FutureSeconds, &py_IncludeLatency, &PyVec3_Type, &Out)) {
		return NULL;
	}
	Player_ptr = (Player ? Player->obj : NULL);
	IncludeLatency = (bool)PyObject_IsTrue(py_IncludeLatency);
	self->obj->GetFutureUnitPosition(Player_ptr, FutureSeconds, IncludeLatency, *((PyVec3 *)Out)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}



PyObject *
_wrap_PyIPrediction_FindBestCastPosition__0(PyIPrediction *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float Range;
	float Radius;
	bool IsMissile;
	PyObject *py_IsMissile;
	bool CheckMinions;
	PyObject *py_CheckMinions;
	bool CheckHeroes;
	PyObject *py_CheckHeroes;
	PyVec3 *CastPosition;
	int  EnemiesHit;
	const char *keywords[] = { "Range", "Radius", "IsMissile", "CheckMinions", "CheckHeroes", "CastPosition", "EnemiesHit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ffOOOO!i", (char **)keywords, &Range, &Radius, &py_IsMissile, &py_CheckMinions, &py_CheckHeroes, &PyVec3_Type, &CastPosition, &EnemiesHit)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	IsMissile = (bool)PyObject_IsTrue(py_IsMissile);
	CheckMinions = (bool)PyObject_IsTrue(py_CheckMinions);
	CheckHeroes = (bool)PyObject_IsTrue(py_CheckHeroes);
	self->obj->FindBestCastPosition(Range, Radius, IsMissile, CheckMinions, CheckHeroes, *((PyVec3 *)CastPosition)->obj, EnemiesHit);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyIPrediction_FindBestCastPosition__1(PyIPrediction *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	float Range;
	float Radius;
	bool IsMissile;
	PyObject *py_IsMissile;
	bool CheckMinions;
	PyObject *py_CheckMinions;
	bool CheckHeroes;
	PyObject *py_CheckHeroes;
	PyVec3 *CastPosition;
	int  EnemiesHit;
	float Delay;
	const char *keywords[] = { "Range", "Radius", "IsMissile", "CheckMinions", "CheckHeroes", "CastPosition", "EnemiesHit", "Delay", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ffOOOO!if", (char **)keywords, &Range, &Radius, &py_IsMissile, &py_CheckMinions, &py_CheckHeroes, &PyVec3_Type, &CastPosition, &EnemiesHit, &Delay)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	IsMissile = (bool)PyObject_IsTrue(py_IsMissile);
	CheckMinions = (bool)PyObject_IsTrue(py_CheckMinions);
	CheckHeroes = (bool)PyObject_IsTrue(py_CheckHeroes);
	self->obj->FindBestCastPosition(Range, Radius, IsMissile, CheckMinions, CheckHeroes, *((PyVec3 *)CastPosition)->obj, EnemiesHit, Delay);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyIPrediction_FindBestCastPosition(PyIPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIPrediction_FindBestCastPosition__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIPrediction_FindBestCastPosition__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}

static PyMethodDef PyIPrediction_methods[] = {
	{ (char *) "IsPointWall", (PyCFunction)_wrap_PyIPrediction_IsPointWall, METH_KEYWORDS | METH_VARARGS, "IsPointWall(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "FindBestCastPositionEx", (PyCFunction)_wrap_PyIPrediction_FindBestCastPositionEx, METH_KEYWORDS | METH_VARARGS, "FindBestCastPositionEx(StartPosition, Delay, Range, Radius, IsMissile, CheckMinions, CheckHeroes, CastPosition, EnemiesHit)\n\ntype: StartPosition: Vec3 const &\ntype: Delay: float\ntype: Range: float\ntype: Radius: float\ntype: IsMissile: bool\ntype: CheckMinions: bool\ntype: CheckHeroes: bool\ntype: CastPosition: Vec3 &\ntype: EnemiesHit: std::vector< IUnit * > &" },
	{ (char *) "TestLineOfSight", (PyCFunction)_wrap_PyIPrediction_TestLineOfSight, METH_KEYWORDS | METH_VARARGS, "TestLineOfSight(StartPosition, EndPosition, CollisionPositionOut, CollisionFlagsOut)\n\ntype: StartPosition: Vec3 const &\ntype: EndPosition: Vec3 const &\ntype: CollisionPositionOut: Vec3 &\ntype: CollisionFlagsOut: int &" },
	{ (char *) "SimulateMissile", (PyCFunction)_wrap_PyIPrediction_SimulateMissile, METH_KEYWORDS | METH_VARARGS, "SimulateMissile(StartPosition, Target, Speed, Radius, Range, Delay, CollisionFlags, CastPosition)\n\ntype: StartPosition: Vec3 const &\ntype: Target: IUnit *\ntype: Speed: float\ntype: Radius: float\ntype: Range: float\ntype: Delay: float\ntype: CollisionFlags: int\ntype: CastPosition: Vec3 &" },
	{ (char *) "RunPrediction", (PyCFunction)_wrap_PyIPrediction_RunPrediction, METH_KEYWORDS | METH_VARARGS, "RunPrediction(Input, Output, PredictionVersion)\n\ntype: Input: AdvPredictionInput *\ntype: Output: AdvPredictionOutput *\ntype: PredictionVersion: uint32_t" },
	{ (char *) "GetCollisionFlagsForPoint", (PyCFunction)_wrap_PyIPrediction_GetCollisionFlagsForPoint, METH_KEYWORDS | METH_VARARGS, "GetCollisionFlagsForPoint(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "IsPointGrass", (PyCFunction)_wrap_PyIPrediction_IsPointGrass, METH_KEYWORDS | METH_VARARGS, "IsPointGrass(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "GetFutureUnitPosition", (PyCFunction)_wrap_PyIPrediction_GetFutureUnitPosition, METH_KEYWORDS | METH_VARARGS, "GetFutureUnitPosition(Player, FutureSeconds, IncludeLatency, Out)\n\ntype: Player: IUnit *\ntype: FutureSeconds: float\ntype: IncludeLatency: bool\ntype: Out: Vec3 &" },
	{ (char *) "FindBestCastPosition", (PyCFunction)_wrap_PyIPrediction_FindBestCastPosition, METH_KEYWORDS | METH_VARARGS, NULL },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIPrediction__tp_dealloc(PyIPrediction *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIPrediction__tp_richcompare(PyIPrediction *PYBINDGEN_UNUSED(self), PyIPrediction *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIPrediction_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIPrediction_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IPrediction",            /* tp_name */
	sizeof(PyIPrediction),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIPrediction__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIPrediction__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIPrediction_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIPrediction__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIMenuOption__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IMenuOption' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIMenuOption_GetFloat(PyIMenuOption *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetFloat();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMenuOption_UpdateInteger(PyIMenuOption *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int NewValue;
	const char *keywords[] = { "NewValue", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &NewValue)) {
		return NULL;
	}
	self->obj->UpdateInteger(NewValue);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIMenuOption_UpdateColor(PyIMenuOption *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	unsigned long NewValue;
	const char *keywords[] = { "NewValue", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "k", (char **)keywords, &NewValue)) {
		return NULL;
	}
	self->obj->UpdateColor(NewValue);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIMenuOption_GetInteger(PyIMenuOption *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetInteger();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}



PyObject *
_wrap_PyIMenuOption_GetColor__0(PyIMenuOption *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	unsigned long retval;
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	retval = self->obj->GetColor();
	py_retval = Py_BuildValue((char *) "k", retval);
	return py_retval;
}

PyObject *
_wrap_PyIMenuOption_GetColor__1(PyIMenuOption *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	PyVec4 *OutColor;
	Vec4 *OutColor_ptr;
	const char *keywords[] = { "OutColor", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec4_Type, &OutColor)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	OutColor_ptr = (OutColor ? OutColor->obj : NULL);
	self->obj->GetColor(OutColor_ptr);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyIMenuOption_GetColor(PyIMenuOption *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIMenuOption_GetColor__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIMenuOption_GetColor__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIMenuOption_Enabled(PyIMenuOption *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->Enabled();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIMenuOption_UpdateFloat(PyIMenuOption *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float NewValue;
	const char *keywords[] = { "NewValue", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &NewValue)) {
		return NULL;
	}
	self->obj->UpdateFloat(NewValue);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

static PyMethodDef PyIMenuOption_methods[] = {
	{ (char *) "GetFloat", (PyCFunction)_wrap_PyIMenuOption_GetFloat, METH_NOARGS, "GetFloat()\n\n" },
	{ (char *) "UpdateInteger", (PyCFunction)_wrap_PyIMenuOption_UpdateInteger, METH_KEYWORDS | METH_VARARGS, "UpdateInteger(NewValue)\n\ntype: NewValue: int" },
	{ (char *) "UpdateColor", (PyCFunction)_wrap_PyIMenuOption_UpdateColor, METH_KEYWORDS | METH_VARARGS, "UpdateColor(NewValue)\n\ntype: NewValue: unsigned long" },
	{ (char *) "GetInteger", (PyCFunction)_wrap_PyIMenuOption_GetInteger, METH_NOARGS, "GetInteger()\n\n" },
	{ (char *) "GetColor", (PyCFunction)_wrap_PyIMenuOption_GetColor, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "Enabled", (PyCFunction)_wrap_PyIMenuOption_Enabled, METH_NOARGS, "Enabled()\n\n" },
	{ (char *) "UpdateFloat", (PyCFunction)_wrap_PyIMenuOption_UpdateFloat, METH_KEYWORDS | METH_VARARGS, "UpdateFloat(NewValue)\n\ntype: NewValue: float" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIMenuOption__tp_dealloc(PyIMenuOption *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIMenuOption__tp_richcompare(PyIMenuOption *PYBINDGEN_UNUSED(self), PyIMenuOption *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIMenuOption_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIMenuOption_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IMenuOption",            /* tp_name */
	sizeof(PyIMenuOption),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIMenuOption__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIMenuOption__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIMenuOption_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIMenuOption__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIMenu__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IMenu' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIMenu_CheckBox(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	bool Value;
	PyObject *py_Value;
	const char *keywords[] = { "Name", "Value", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sO", (char **)keywords, &Name, &py_Value)) {
		return NULL;
	}
	Value = (bool)PyObject_IsTrue(py_Value);
	retval = self->obj->CheckBox(Name, Value);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}


PyObject *
_wrap_PyIMenu_Remove(PyIMenu *self)
{
	PyObject *py_retval;

	self->obj->Remove();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIMenu_AddMenu(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenu *retval;
	char const *Title;
	const char *keywords[] = { "Title", NULL };
	PyIMenu *py_IMenu;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Title)) {
		return NULL;
	}
	retval = self->obj->AddMenu(Title);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenu = PyObject_New(PyIMenu, &PyIMenu_Type);
	py_IMenu->obj = retval;
	py_IMenu->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenu);
	return py_retval;
}


PyObject *
_wrap_PyIMenu_SaveSettings(PyIMenu *self)
{
	PyObject *py_retval;

	self->obj->SaveSettings();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}



PyObject *
_wrap_PyIMenu_AddColor__0(PyIMenu *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	unsigned long Value;
	const char *keywords[] = { "Name", "Value", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sk", (char **)keywords, &Name, &Value)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	retval = self->obj->AddColor(Name, Value);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}

PyObject *
_wrap_PyIMenu_AddColor__1(PyIMenu *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	float Red;
	float Green;
	float Blue;
	float Alpha;
	const char *keywords[] = { "Name", "Red", "Green", "Blue", "Alpha", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sffff", (char **)keywords, &Name, &Red, &Green, &Blue, &Alpha)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	retval = self->obj->AddColor(Name, Red, Green, Blue, Alpha);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}

PyObject * _wrap_PyIMenu_AddColor(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIMenu_AddColor__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIMenu_AddColor__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIMenu_AddSelection(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	int DefaultIdx;
	std::vector<std::string> Names_value;
	const char *keywords[] = { "Name", "DefaultIdx", "Names", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "siO&", (char **)keywords, &Name, &DefaultIdx, _wrap_convert_py2c__std__vector__lt___std__string___gt__, &Names_value)) {
		return NULL;
	}
	retval = self->obj->AddSelection(Name, DefaultIdx, Names_value);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}


PyObject *
_wrap_PyIMenu_AddFloat(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	float MinValue;
	float MaxValue;
	float Value;
	const char *keywords[] = { "Name", "MinValue", "MaxValue", "Value", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sfff", (char **)keywords, &Name, &MinValue, &MaxValue, &Value)) {
		return NULL;
	}
	retval = self->obj->AddFloat(Name, MinValue, MaxValue, Value);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}


PyObject *
_wrap_PyIMenu_AddKey(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	int DefaultKey;
	const char *keywords[] = { "Name", "DefaultKey", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "si", (char **)keywords, &Name, &DefaultKey)) {
		return NULL;
	}
	retval = self->obj->AddKey(Name, DefaultKey);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}


PyObject *
_wrap_PyIMenu_AddInteger(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	int MinValue;
	int MaxValue;
	int Value;
	const char *keywords[] = { "Name", "MinValue", "MaxValue", "Value", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "siii", (char **)keywords, &Name, &MinValue, &MaxValue, &Value)) {
		return NULL;
	}
	retval = self->obj->AddInteger(Name, MinValue, MaxValue, Value);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}


PyObject *
_wrap_PyIMenu_GetOption(PyIMenu *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenuOption *retval;
	char const *Name;
	const char *keywords[] = { "Name", NULL };
	PyIMenuOption *py_IMenuOption;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Name)) {
		return NULL;
	}
	retval = self->obj->GetOption(Name);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenuOption = PyObject_New(PyIMenuOption, &PyIMenuOption_Type);
	py_IMenuOption->obj = retval;
	py_IMenuOption->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenuOption);
	return py_retval;
}

static PyMethodDef PyIMenu_methods[] = {
	{ (char *) "CheckBox", (PyCFunction)_wrap_PyIMenu_CheckBox, METH_KEYWORDS | METH_VARARGS, "CheckBox(Name, Value)\n\ntype: Name: char const *\ntype: Value: bool" },
	{ (char *) "Remove", (PyCFunction)_wrap_PyIMenu_Remove, METH_NOARGS, "Remove()\n\n" },
	{ (char *) "AddMenu", (PyCFunction)_wrap_PyIMenu_AddMenu, METH_KEYWORDS | METH_VARARGS, "AddMenu(Title)\n\ntype: Title: char const *" },
	{ (char *) "SaveSettings", (PyCFunction)_wrap_PyIMenu_SaveSettings, METH_NOARGS, "SaveSettings()\n\n" },
	{ (char *) "AddColor", (PyCFunction)_wrap_PyIMenu_AddColor, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "AddSelection", (PyCFunction)_wrap_PyIMenu_AddSelection, METH_KEYWORDS | METH_VARARGS, "AddSelection(Name, DefaultIdx, Names)\n\ntype: Name: char const *\ntype: DefaultIdx: int\ntype: Names: std::vector< std::string > const &" },
	{ (char *) "AddFloat", (PyCFunction)_wrap_PyIMenu_AddFloat, METH_KEYWORDS | METH_VARARGS, "AddFloat(Name, MinValue, MaxValue, Value)\n\ntype: Name: char const *\ntype: MinValue: float\ntype: MaxValue: float\ntype: Value: float" },
	{ (char *) "AddKey", (PyCFunction)_wrap_PyIMenu_AddKey, METH_KEYWORDS | METH_VARARGS, "AddKey(Name, DefaultKey)\n\ntype: Name: char const *\ntype: DefaultKey: int" },
	{ (char *) "AddInteger", (PyCFunction)_wrap_PyIMenu_AddInteger, METH_KEYWORDS | METH_VARARGS, "AddInteger(Name, MinValue, MaxValue, Value)\n\ntype: Name: char const *\ntype: MinValue: int\ntype: MaxValue: int\ntype: Value: int" },
	{ (char *) "GetOption", (PyCFunction)_wrap_PyIMenu_GetOption, METH_KEYWORDS | METH_VARARGS, "GetOption(Name)\n\ntype: Name: char const *" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIMenu__tp_dealloc(PyIMenu *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIMenu__tp_richcompare(PyIMenu *PYBINDGEN_UNUSED(self), PyIMenu *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIMenu_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIMenu_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IMenu",            /* tp_name */
	sizeof(PyIMenu),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIMenu__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIMenu__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIMenu_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIMenu__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIHealthPrediction__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IHealthPrediction' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIHealthPrediction_GetPredictedHealth(PyIHealthPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	eHealthPredictionType Prediction;
	int TimeMs;
	int DelayMs;
	const char *keywords[] = { "Source", "Prediction", "TimeMs", "DelayMs", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!iii", (char **)keywords, &PyIUnit_Type, &Source, &Prediction, &TimeMs, &DelayMs)) {
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	retval = self->obj->GetPredictedHealth(Source_ptr, Prediction, TimeMs, DelayMs);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIHealthPrediction_GetKSDamage(PyIHealthPrediction *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	int SpellSlot;
	float Delay;
	bool IncludeSkillshots;
	PyObject *py_IncludeSkillshots;
	const char *keywords[] = { "Target", "SpellSlot", "Delay", "IncludeSkillshots", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!ifO", (char **)keywords, &PyIUnit_Type, &Target, &SpellSlot, &Delay, &py_IncludeSkillshots)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	IncludeSkillshots = (bool)PyObject_IsTrue(py_IncludeSkillshots);
	retval = self->obj->GetKSDamage(Target_ptr, SpellSlot, Delay, IncludeSkillshots);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}

static PyMethodDef PyIHealthPrediction_methods[] = {
	{ (char *) "GetPredictedHealth", (PyCFunction)_wrap_PyIHealthPrediction_GetPredictedHealth, METH_KEYWORDS | METH_VARARGS, "GetPredictedHealth(Source, Prediction, TimeMs, DelayMs)\n\ntype: Source: IUnit *\ntype: Prediction: eHealthPredictionType\ntype: TimeMs: int\ntype: DelayMs: int" },
	{ (char *) "GetKSDamage", (PyCFunction)_wrap_PyIHealthPrediction_GetKSDamage, METH_KEYWORDS | METH_VARARGS, "GetKSDamage(Target, SpellSlot, Delay, IncludeSkillshots)\n\ntype: Target: IUnit *\ntype: SpellSlot: int\ntype: Delay: float\ntype: IncludeSkillshots: bool" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIHealthPrediction__tp_dealloc(PyIHealthPrediction *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIHealthPrediction__tp_richcompare(PyIHealthPrediction *PYBINDGEN_UNUSED(self), PyIHealthPrediction *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIHealthPrediction_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIHealthPrediction_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IHealthPrediction",            /* tp_name */
	sizeof(PyIHealthPrediction),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIHealthPrediction__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIHealthPrediction__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIHealthPrediction_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIHealthPrediction__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyISpell2__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'ISpell2' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyISpell2_GetDelay(PyISpell2 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetDelay();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_GetType(PyISpell2 *self)
{
	PyObject *py_retval;
	eSpellType retval;

	retval = self->obj->GetType();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_GetChargedBuffName(PyISpell2 *self)
{
	PyObject *py_retval;
	std::string retval;

	retval = self->obj->GetChargedBuffName();
	py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
	return py_retval;
}


PyObject *
_wrap_PyISpell2_IsCharging(PyISpell2 *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsCharging();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_AttackMinions(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	int MinimumEnemiesHit = 3;
	const char *keywords[] = { "MinimumEnemiesHit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|i", (char **)keywords, &MinimumEnemiesHit)) {
		return NULL;
	}
	retval = self->obj->AttackMinions(MinimumEnemiesHit);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_CastOnTargetAoE(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	int MinimumChampionsHit = 2;
	int MinimumHitChance = kHitChanceHigh;
	const char *keywords[] = { "Target", "MinimumChampionsHit", "MinimumHitChance", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!|ii", (char **)keywords, &PyIUnit_Type, &Target, &MinimumChampionsHit, &MinimumHitChance)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->CastOnTargetAoE(Target_ptr, MinimumChampionsHit, MinimumHitChance);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_GetSpellName(PyISpell2 *self)
{
	PyObject *py_retval;
	std::string retval;

	retval = self->obj->GetSpellName();
	py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
	return py_retval;
}


PyObject *
_wrap_PyISpell2_CastOnPlayer(PyISpell2 *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->CastOnPlayer();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetTriggerEvents(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool TriggerEvents;
	PyObject *py_TriggerEvents;
	const char *keywords[] = { "TriggerEvents", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **)keywords, &py_TriggerEvents)) {
		return NULL;
	}
	TriggerEvents = (bool)PyObject_IsTrue(py_TriggerEvents);
	self->obj->SetTriggerEvents(TriggerEvents);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetOverrideSpeed(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float Value;
	const char *keywords[] = { "Value", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &Value)) {
		return NULL;
	}
	self->obj->SetOverrideSpeed(Value);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_GetCollisionFlags(PyISpell2 *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetCollisionFlags();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_FindBestCastPosition(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool IncludeMinions;
	PyObject *py_IncludeMinions;
	bool IncludeHeroes;
	PyObject *py_IncludeHeroes;
	PyVec3 *CastPosition;
	int  EnemiesHit;
	const char *keywords[] = { "IncludeMinions", "IncludeHeroes", "CastPosition", "EnemiesHit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OOO!i", (char **)keywords, &py_IncludeMinions, &py_IncludeHeroes, &PyVec3_Type, &CastPosition, &EnemiesHit)) {
		return NULL;
	}
	IncludeMinions = (bool)PyObject_IsTrue(py_IncludeMinions);
	IncludeHeroes = (bool)PyObject_IsTrue(py_IncludeHeroes);
	self->obj->FindBestCastPosition(IncludeMinions, IncludeHeroes, *((PyVec3 *)CastPosition)->obj, EnemiesHit);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_IsReady(PyISpell2 *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsReady();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetSkillshot(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float OverrideDelay;
	float OverrideRadius;
	float OverrideSpeed;
	float OverrideRange;
	const char *keywords[] = { "OverrideDelay", "OverrideRadius", "OverrideSpeed", "OverrideRange", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ffff", (char **)keywords, &OverrideDelay, &OverrideRadius, &OverrideSpeed, &OverrideRange)) {
		return NULL;
	}
	self->obj->SetSkillshot(OverrideDelay, OverrideRadius, OverrideSpeed, OverrideRange);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_CastOnTarget(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	int MinimumHitChance = kHitChanceHigh;
	const char *keywords[] = { "Target", "MinimumHitChance", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!|i", (char **)keywords, &PyIUnit_Type, &Target, &MinimumHitChance)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->CastOnTarget(Target_ptr, MinimumHitChance);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_GetSlot(PyISpell2 *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetSlot();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetRangeCheckFrom(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	self->obj->SetRangeCheckFrom(*((PyVec3 *)Position)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_RunPrediction(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	bool IsAoE;
	PyObject *py_IsAoE;
	int CollisionFlags;
	PyAdvPredictionOutput *Output;
	AdvPredictionOutput *Output_ptr;
	unsigned int PredictionVersion = 1;
	const char *keywords[] = { "Target", "IsAoE", "CollisionFlags", "Output", "PredictionVersion", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!OiO!|I", (char **)keywords, &PyIUnit_Type, &Target, &py_IsAoE, &CollisionFlags, &PyAdvPredictionOutput_Type, &Output, &PredictionVersion)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	IsAoE = (bool)PyObject_IsTrue(py_IsAoE);
	Output_ptr = (Output ? Output->obj : NULL);
	retval = self->obj->RunPrediction(Target_ptr, IsAoE, CollisionFlags, Output_ptr, PredictionVersion);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_CastFrom(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *StartPosition;
	PyVec3 *EndPosition;
	const char *keywords[] = { "StartPosition", "EndPosition", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **)keywords, &PyVec3_Type, &StartPosition, &PyVec3_Type, &EndPosition)) {
		return NULL;
	}
	retval = self->obj->CastFrom(*((PyVec3 *)StartPosition)->obj, *((PyVec3 *)EndPosition)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetChargedBuffName(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	const char *BuffName = NULL;
	Py_ssize_t BuffName_len;
	std::string BuffName_std;
	const char *keywords[] = { "BuffName", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **)keywords, &BuffName, &BuffName_len)) {
		return NULL;
	}
	BuffName_std = std::string(BuffName, BuffName_len);
	self->obj->SetChargedBuffName(BuffName_std);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}



PyObject *
_wrap_PyISpell2_StartCharging__0(PyISpell2 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	const char *keywords[] = { NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **)keywords)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->StartCharging();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyISpell2_StartCharging__1(PyISpell2 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->StartCharging(*((PyVec3 *)Position)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyISpell2_StartCharging(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyISpell2_StartCharging__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyISpell2_StartCharging__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyISpell2_IsTriggeringEvents(PyISpell2 *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsTriggeringEvents();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_CastOnPosition(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->CastOnPosition(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_LastHitMinion(PyISpell2 *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->LastHitMinion();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyISpell2_Range(PyISpell2 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Range();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetOverrideRadius(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float Value;
	const char *keywords[] = { "Value", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &Value)) {
		return NULL;
	}
	self->obj->SetOverrideRadius(Value);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_GetRangeCheckFrom(PyISpell2 *self)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	Vec3 const & retval = self->obj->GetRangeCheckFrom();
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetOverrideDelay(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float Value;
	const char *keywords[] = { "Value", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &Value)) {
		return NULL;
	}
	self->obj->SetOverrideDelay(Value);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetOverrideRange(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float Value;
	const char *keywords[] = { "Value", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &Value)) {
		return NULL;
	}
	self->obj->SetOverrideRange(Value);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_ManaCost(PyISpell2 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->ManaCost();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_GetChargePercent(PyISpell2 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->GetChargePercent();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetFrom(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	self->obj->SetFrom(*((PyVec3 *)Position)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_FindTarget(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	eDamageType DamageType;
	const char *keywords[] = { "DamageType", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &DamageType)) {
		return NULL;
	}
	retval = self->obj->FindTarget(DamageType);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetCharged(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float RangeMin;
	float RangeMax;
	float DeltaTime;
	const char *keywords[] = { "RangeMin", "RangeMax", "DeltaTime", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "fff", (char **)keywords, &RangeMin, &RangeMax, &DeltaTime)) {
		return NULL;
	}
	self->obj->SetCharged(RangeMin, RangeMax, DeltaTime);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_Radius(PyISpell2 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Radius();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_SetSpellName(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	const char *SpellName = NULL;
	Py_ssize_t SpellName_len;
	std::string SpellName_std;
	const char *keywords[] = { "SpellName", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **)keywords, &SpellName, &SpellName_len)) {
		return NULL;
	}
	SpellName_std = std::string(SpellName, SpellName_len);
	self->obj->SetSpellName(SpellName_std);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyISpell2_Speed(PyISpell2 *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Speed();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyISpell2_CastOnUnit(PyISpell2 *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	const char *keywords[] = { "Target", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Target)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->CastOnUnit(Target_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

static PyMethodDef PyISpell2_methods[] = {
	{ (char *) "GetDelay", (PyCFunction)_wrap_PyISpell2_GetDelay, METH_NOARGS, "GetDelay()\n\n" },
	{ (char *) "GetType", (PyCFunction)_wrap_PyISpell2_GetType, METH_NOARGS, "GetType()\n\n" },
	{ (char *) "GetChargedBuffName", (PyCFunction)_wrap_PyISpell2_GetChargedBuffName, METH_NOARGS, "GetChargedBuffName()\n\n" },
	{ (char *) "IsCharging", (PyCFunction)_wrap_PyISpell2_IsCharging, METH_NOARGS, "IsCharging()\n\n" },
	{ (char *) "AttackMinions", (PyCFunction)_wrap_PyISpell2_AttackMinions, METH_KEYWORDS | METH_VARARGS, "AttackMinions(MinimumEnemiesHit)\n\ntype: MinimumEnemiesHit: int" },
	{ (char *) "CastOnTargetAoE", (PyCFunction)_wrap_PyISpell2_CastOnTargetAoE, METH_KEYWORDS | METH_VARARGS, "CastOnTargetAoE(Target, MinimumChampionsHit, MinimumHitChance)\n\ntype: Target: IUnit *\ntype: MinimumChampionsHit: int\ntype: MinimumHitChance: int" },
	{ (char *) "GetSpellName", (PyCFunction)_wrap_PyISpell2_GetSpellName, METH_NOARGS, "GetSpellName()\n\n" },
	{ (char *) "CastOnPlayer", (PyCFunction)_wrap_PyISpell2_CastOnPlayer, METH_NOARGS, "CastOnPlayer()\n\n" },
	{ (char *) "SetTriggerEvents", (PyCFunction)_wrap_PyISpell2_SetTriggerEvents, METH_KEYWORDS | METH_VARARGS, "SetTriggerEvents(TriggerEvents)\n\ntype: TriggerEvents: bool" },
	{ (char *) "SetOverrideSpeed", (PyCFunction)_wrap_PyISpell2_SetOverrideSpeed, METH_KEYWORDS | METH_VARARGS, "SetOverrideSpeed(Value)\n\ntype: Value: float" },
	{ (char *) "GetCollisionFlags", (PyCFunction)_wrap_PyISpell2_GetCollisionFlags, METH_NOARGS, "GetCollisionFlags()\n\n" },
	{ (char *) "FindBestCastPosition", (PyCFunction)_wrap_PyISpell2_FindBestCastPosition, METH_KEYWORDS | METH_VARARGS, "FindBestCastPosition(IncludeMinions, IncludeHeroes, CastPosition, EnemiesHit)\n\ntype: IncludeMinions: bool\ntype: IncludeHeroes: bool\ntype: CastPosition: Vec3 &\ntype: EnemiesHit: int &" },
	{ (char *) "IsReady", (PyCFunction)_wrap_PyISpell2_IsReady, METH_NOARGS, "IsReady()\n\n" },
	{ (char *) "SetSkillshot", (PyCFunction)_wrap_PyISpell2_SetSkillshot, METH_KEYWORDS | METH_VARARGS, "SetSkillshot(OverrideDelay, OverrideRadius, OverrideSpeed, OverrideRange)\n\ntype: OverrideDelay: float\ntype: OverrideRadius: float\ntype: OverrideSpeed: float\ntype: OverrideRange: float" },
	{ (char *) "CastOnTarget", (PyCFunction)_wrap_PyISpell2_CastOnTarget, METH_KEYWORDS | METH_VARARGS, "CastOnTarget(Target, MinimumHitChance)\n\ntype: Target: IUnit *\ntype: MinimumHitChance: int" },
	{ (char *) "GetSlot", (PyCFunction)_wrap_PyISpell2_GetSlot, METH_NOARGS, "GetSlot()\n\n" },
	{ (char *) "SetRangeCheckFrom", (PyCFunction)_wrap_PyISpell2_SetRangeCheckFrom, METH_KEYWORDS | METH_VARARGS, "SetRangeCheckFrom(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "RunPrediction", (PyCFunction)_wrap_PyISpell2_RunPrediction, METH_KEYWORDS | METH_VARARGS, "RunPrediction(Target, IsAoE, CollisionFlags, Output, PredictionVersion)\n\ntype: Target: IUnit *\ntype: IsAoE: bool\ntype: CollisionFlags: int\ntype: Output: AdvPredictionOutput *\ntype: PredictionVersion: uint32_t" },
	{ (char *) "CastFrom", (PyCFunction)_wrap_PyISpell2_CastFrom, METH_KEYWORDS | METH_VARARGS, "CastFrom(StartPosition, EndPosition)\n\ntype: StartPosition: Vec3 const &\ntype: EndPosition: Vec3 const &" },
	{ (char *) "SetChargedBuffName", (PyCFunction)_wrap_PyISpell2_SetChargedBuffName, METH_KEYWORDS | METH_VARARGS, "SetChargedBuffName(BuffName)\n\ntype: BuffName: std::string const &" },
	{ (char *) "StartCharging", (PyCFunction)_wrap_PyISpell2_StartCharging, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "IsTriggeringEvents", (PyCFunction)_wrap_PyISpell2_IsTriggeringEvents, METH_NOARGS, "IsTriggeringEvents()\n\n" },
	{ (char *) "CastOnPosition", (PyCFunction)_wrap_PyISpell2_CastOnPosition, METH_KEYWORDS | METH_VARARGS, "CastOnPosition(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "LastHitMinion", (PyCFunction)_wrap_PyISpell2_LastHitMinion, METH_NOARGS, "LastHitMinion()\n\n" },
	{ (char *) "Range", (PyCFunction)_wrap_PyISpell2_Range, METH_NOARGS, "Range()\n\n" },
	{ (char *) "SetOverrideRadius", (PyCFunction)_wrap_PyISpell2_SetOverrideRadius, METH_KEYWORDS | METH_VARARGS, "SetOverrideRadius(Value)\n\ntype: Value: float" },
	{ (char *) "GetRangeCheckFrom", (PyCFunction)_wrap_PyISpell2_GetRangeCheckFrom, METH_NOARGS, "GetRangeCheckFrom()\n\n" },
	{ (char *) "SetOverrideDelay", (PyCFunction)_wrap_PyISpell2_SetOverrideDelay, METH_KEYWORDS | METH_VARARGS, "SetOverrideDelay(Value)\n\ntype: Value: float" },
	{ (char *) "SetOverrideRange", (PyCFunction)_wrap_PyISpell2_SetOverrideRange, METH_KEYWORDS | METH_VARARGS, "SetOverrideRange(Value)\n\ntype: Value: float" },
	{ (char *) "ManaCost", (PyCFunction)_wrap_PyISpell2_ManaCost, METH_NOARGS, "ManaCost()\n\n" },
	{ (char *) "GetChargePercent", (PyCFunction)_wrap_PyISpell2_GetChargePercent, METH_NOARGS, "GetChargePercent()\n\n" },
	{ (char *) "SetFrom", (PyCFunction)_wrap_PyISpell2_SetFrom, METH_KEYWORDS | METH_VARARGS, "SetFrom(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "FindTarget", (PyCFunction)_wrap_PyISpell2_FindTarget, METH_KEYWORDS | METH_VARARGS, "FindTarget(DamageType)\n\ntype: DamageType: eDamageType" },
	{ (char *) "SetCharged", (PyCFunction)_wrap_PyISpell2_SetCharged, METH_KEYWORDS | METH_VARARGS, "SetCharged(RangeMin, RangeMax, DeltaTime)\n\ntype: RangeMin: float\ntype: RangeMax: float\ntype: DeltaTime: float" },
	{ (char *) "Radius", (PyCFunction)_wrap_PyISpell2_Radius, METH_NOARGS, "Radius()\n\n" },
	{ (char *) "SetSpellName", (PyCFunction)_wrap_PyISpell2_SetSpellName, METH_KEYWORDS | METH_VARARGS, "SetSpellName(SpellName)\n\ntype: SpellName: std::string const &" },
	{ (char *) "Speed", (PyCFunction)_wrap_PyISpell2_Speed, METH_NOARGS, "Speed()\n\n" },
	{ (char *) "CastOnUnit", (PyCFunction)_wrap_PyISpell2_CastOnUnit, METH_KEYWORDS | METH_VARARGS, "CastOnUnit(Target)\n\ntype: Target: IUnit *" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyISpell2__tp_dealloc(PyISpell2 *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyISpell2__tp_richcompare(PyISpell2 *PYBINDGEN_UNUSED(self), PyISpell2 *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyISpell2_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyISpell2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.ISpell2",            /* tp_name */
	sizeof(PyISpell2),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyISpell2__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyISpell2__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyISpell2_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyISpell2__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIOrbwalking__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IOrbwalking' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIOrbwalking_SetOverrideTarget(PyIOrbwalking *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	const char *keywords[] = { "Target", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Target)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	self->obj->SetOverrideTarget(Target_ptr);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_SetMovementAllowed(PyIOrbwalking *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Enabled;
	PyObject *py_Enabled;
	const char *keywords[] = { "Enabled", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **)keywords, &py_Enabled)) {
		return NULL;
	}
	Enabled = (bool)PyObject_IsTrue(py_Enabled);
	self->obj->SetMovementAllowed(Enabled);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_ResetAA(PyIOrbwalking *self)
{
	PyObject *py_retval;

	self->obj->ResetAA();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_GetLastTarget(PyIOrbwalking *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->GetLastTarget();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_GetOrbwalkingMode(PyIOrbwalking *self)
{
	PyObject *py_retval;
	eOrbwalkingMode retval;

	retval = self->obj->GetOrbwalkingMode();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_CanMove(PyIOrbwalking *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	float Delay;
	const char *keywords[] = { "Delay", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &Delay)) {
		return NULL;
	}
	retval = self->obj->CanMove(Delay);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_DisableNextAttack(PyIOrbwalking *self)
{
	PyObject *py_retval;

	self->obj->DisableNextAttack();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_SetOverridePosition(PyIOrbwalking *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	self->obj->SetOverridePosition(*((PyVec3 *)Position)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_CanAttack(PyIOrbwalking *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->CanAttack();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_SetAttacksAllowed(PyIOrbwalking *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Enabled;
	PyObject *py_Enabled;
	const char *keywords[] = { "Enabled", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **)keywords, &py_Enabled)) {
		return NULL;
	}
	Enabled = (bool)PyObject_IsTrue(py_Enabled);
	self->obj->SetAttacksAllowed(Enabled);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_GetLastPosition(PyIOrbwalking *self)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	Vec3 retval = self->obj->GetLastPosition();
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_GetAutoAttackRange(PyIOrbwalking *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	const char *keywords[] = { "Target", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Target)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->GetAutoAttackRange(Target_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIOrbwalking_Orbwalk(PyIOrbwalking *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	PyVec3 *Position;
	const char *keywords[] = { "Target", "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **)keywords, &PyIUnit_Type, &Target, &PyVec3_Type, &Position)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	self->obj->Orbwalk(Target_ptr, *((PyVec3 *)Position)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

static PyMethodDef PyIOrbwalking_methods[] = {
	{ (char *) "SetOverrideTarget", (PyCFunction)_wrap_PyIOrbwalking_SetOverrideTarget, METH_KEYWORDS | METH_VARARGS, "SetOverrideTarget(Target)\n\ntype: Target: IUnit *" },
	{ (char *) "SetMovementAllowed", (PyCFunction)_wrap_PyIOrbwalking_SetMovementAllowed, METH_KEYWORDS | METH_VARARGS, "SetMovementAllowed(Enabled)\n\ntype: Enabled: bool" },
	{ (char *) "ResetAA", (PyCFunction)_wrap_PyIOrbwalking_ResetAA, METH_NOARGS, "ResetAA()\n\n" },
	{ (char *) "GetLastTarget", (PyCFunction)_wrap_PyIOrbwalking_GetLastTarget, METH_NOARGS, "GetLastTarget()\n\n" },
	{ (char *) "GetOrbwalkingMode", (PyCFunction)_wrap_PyIOrbwalking_GetOrbwalkingMode, METH_NOARGS, "GetOrbwalkingMode()\n\n" },
	{ (char *) "CanMove", (PyCFunction)_wrap_PyIOrbwalking_CanMove, METH_KEYWORDS | METH_VARARGS, "CanMove(Delay)\n\ntype: Delay: float" },
	{ (char *) "DisableNextAttack", (PyCFunction)_wrap_PyIOrbwalking_DisableNextAttack, METH_NOARGS, "DisableNextAttack()\n\n" },
	{ (char *) "SetOverridePosition", (PyCFunction)_wrap_PyIOrbwalking_SetOverridePosition, METH_KEYWORDS | METH_VARARGS, "SetOverridePosition(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "CanAttack", (PyCFunction)_wrap_PyIOrbwalking_CanAttack, METH_NOARGS, "CanAttack()\n\n" },
	{ (char *) "SetAttacksAllowed", (PyCFunction)_wrap_PyIOrbwalking_SetAttacksAllowed, METH_KEYWORDS | METH_VARARGS, "SetAttacksAllowed(Enabled)\n\ntype: Enabled: bool" },
	{ (char *) "GetLastPosition", (PyCFunction)_wrap_PyIOrbwalking_GetLastPosition, METH_NOARGS, "GetLastPosition()\n\n" },
	{ (char *) "GetAutoAttackRange", (PyCFunction)_wrap_PyIOrbwalking_GetAutoAttackRange, METH_KEYWORDS | METH_VARARGS, "GetAutoAttackRange(Target)\n\ntype: Target: IUnit *" },
	{ (char *) "Orbwalk", (PyCFunction)_wrap_PyIOrbwalking_Orbwalk, METH_KEYWORDS | METH_VARARGS, "Orbwalk(Target, Position)\n\ntype: Target: IUnit *\ntype: Position: Vec3 const &" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIOrbwalking__tp_dealloc(PyIOrbwalking *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIOrbwalking__tp_richcompare(PyIOrbwalking *PYBINDGEN_UNUSED(self), PyIOrbwalking *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIOrbwalking_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIOrbwalking_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IOrbwalking",            /* tp_name */
	sizeof(PyIOrbwalking),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIOrbwalking__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIOrbwalking__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIOrbwalking_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIOrbwalking__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIInventoryItem__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IInventoryItem' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIInventoryItem_ItemId(PyIInventoryItem *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->ItemId();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_DisplayName(PyIInventoryItem *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->DisplayName();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_CastOnPlayer(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->CastOnPlayer();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_ItemSpellSlot(PyIInventoryItem *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->ItemSpellSlot();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_RequiredLevel(PyIInventoryItem *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->RequiredLevel();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_SellBackModifier(PyIInventoryItem *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->SellBackModifier();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_IsTargetInRange(PyIInventoryItem *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	const char *keywords[] = { "Target", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Target)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->IsTargetInRange(Target_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_IsReady(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsReady();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_IsOwned(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsOwned();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_CastOnTarget(PyIInventoryItem *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Target;
	IUnit *Target_ptr;
	const char *keywords[] = { "Target", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Target)) {
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->CastOnTarget(Target_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_ShowInActiveItemDisplay(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->ShowInActiveItemDisplay();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_Price(PyIInventoryItem *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->Price();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_InStore(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->InStore();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_Clickable(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->Clickable();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_RequiredSpellName(PyIInventoryItem *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->RequiredSpellName();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_Consumed(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->Consumed();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_MaxStack(PyIInventoryItem *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->MaxStack();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_Charges(PyIInventoryItem *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->Charges();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_CastOnPosition(PyIInventoryItem *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->CastOnPosition(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_GetName(PyIInventoryItem *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->GetName();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_IsPointInRange(PyIInventoryItem *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->IsPointInRange(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_CanBeSold(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->CanBeSold();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_Stacks(PyIInventoryItem *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->Stacks();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_SetItemId(PyIInventoryItem *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int Id;
	const char *keywords[] = { "Id", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Id)) {
		return NULL;
	}
	self->obj->SetItemId(Id);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_RequiredChampion(PyIInventoryItem *self)
{
	PyObject *py_retval;
	char const *retval;

	retval = self->obj->RequiredChampion();
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_UsableInStore(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->UsableInStore();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_ConsumeOnAcquire(PyIInventoryItem *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->ConsumeOnAcquire();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIInventoryItem_SetRange(PyIInventoryItem *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float Range;
	const char *keywords[] = { "Range", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "f", (char **)keywords, &Range)) {
		return NULL;
	}
	self->obj->SetRange(Range);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

static PyMethodDef PyIInventoryItem_methods[] = {
	{ (char *) "ItemId", (PyCFunction)_wrap_PyIInventoryItem_ItemId, METH_NOARGS, "ItemId()\n\n" },
	{ (char *) "DisplayName", (PyCFunction)_wrap_PyIInventoryItem_DisplayName, METH_NOARGS, "DisplayName()\n\n" },
	{ (char *) "CastOnPlayer", (PyCFunction)_wrap_PyIInventoryItem_CastOnPlayer, METH_NOARGS, "CastOnPlayer()\n\n" },
	{ (char *) "ItemSpellSlot", (PyCFunction)_wrap_PyIInventoryItem_ItemSpellSlot, METH_NOARGS, "ItemSpellSlot()\n\n" },
	{ (char *) "RequiredLevel", (PyCFunction)_wrap_PyIInventoryItem_RequiredLevel, METH_NOARGS, "RequiredLevel()\n\n" },
	{ (char *) "SellBackModifier", (PyCFunction)_wrap_PyIInventoryItem_SellBackModifier, METH_NOARGS, "SellBackModifier()\n\n" },
	{ (char *) "IsTargetInRange", (PyCFunction)_wrap_PyIInventoryItem_IsTargetInRange, METH_KEYWORDS | METH_VARARGS, "IsTargetInRange(Target)\n\ntype: Target: IUnit *" },
	{ (char *) "IsReady", (PyCFunction)_wrap_PyIInventoryItem_IsReady, METH_NOARGS, "IsReady()\n\n" },
	{ (char *) "IsOwned", (PyCFunction)_wrap_PyIInventoryItem_IsOwned, METH_NOARGS, "IsOwned()\n\n" },
	{ (char *) "CastOnTarget", (PyCFunction)_wrap_PyIInventoryItem_CastOnTarget, METH_KEYWORDS | METH_VARARGS, "CastOnTarget(Target)\n\ntype: Target: IUnit *" },
	{ (char *) "ShowInActiveItemDisplay", (PyCFunction)_wrap_PyIInventoryItem_ShowInActiveItemDisplay, METH_NOARGS, "ShowInActiveItemDisplay()\n\n" },
	{ (char *) "Price", (PyCFunction)_wrap_PyIInventoryItem_Price, METH_NOARGS, "Price()\n\n" },
	{ (char *) "InStore", (PyCFunction)_wrap_PyIInventoryItem_InStore, METH_NOARGS, "InStore()\n\n" },
	{ (char *) "Clickable", (PyCFunction)_wrap_PyIInventoryItem_Clickable, METH_NOARGS, "Clickable()\n\n" },
	{ (char *) "RequiredSpellName", (PyCFunction)_wrap_PyIInventoryItem_RequiredSpellName, METH_NOARGS, "RequiredSpellName()\n\n" },
	{ (char *) "Consumed", (PyCFunction)_wrap_PyIInventoryItem_Consumed, METH_NOARGS, "Consumed()\n\n" },
	{ (char *) "MaxStack", (PyCFunction)_wrap_PyIInventoryItem_MaxStack, METH_NOARGS, "MaxStack()\n\n" },
	{ (char *) "Charges", (PyCFunction)_wrap_PyIInventoryItem_Charges, METH_NOARGS, "Charges()\n\n" },
	{ (char *) "CastOnPosition", (PyCFunction)_wrap_PyIInventoryItem_CastOnPosition, METH_KEYWORDS | METH_VARARGS, "CastOnPosition(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "GetName", (PyCFunction)_wrap_PyIInventoryItem_GetName, METH_NOARGS, "GetName()\n\n" },
	{ (char *) "IsPointInRange", (PyCFunction)_wrap_PyIInventoryItem_IsPointInRange, METH_KEYWORDS | METH_VARARGS, "IsPointInRange(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "CanBeSold", (PyCFunction)_wrap_PyIInventoryItem_CanBeSold, METH_NOARGS, "CanBeSold()\n\n" },
	{ (char *) "Stacks", (PyCFunction)_wrap_PyIInventoryItem_Stacks, METH_NOARGS, "Stacks()\n\n" },
	{ (char *) "SetItemId", (PyCFunction)_wrap_PyIInventoryItem_SetItemId, METH_KEYWORDS | METH_VARARGS, "SetItemId(Id)\n\ntype: Id: int" },
	{ (char *) "RequiredChampion", (PyCFunction)_wrap_PyIInventoryItem_RequiredChampion, METH_NOARGS, "RequiredChampion()\n\n" },
	{ (char *) "UsableInStore", (PyCFunction)_wrap_PyIInventoryItem_UsableInStore, METH_NOARGS, "UsableInStore()\n\n" },
	{ (char *) "ConsumeOnAcquire", (PyCFunction)_wrap_PyIInventoryItem_ConsumeOnAcquire, METH_NOARGS, "ConsumeOnAcquire()\n\n" },
	{ (char *) "SetRange", (PyCFunction)_wrap_PyIInventoryItem_SetRange, METH_KEYWORDS | METH_VARARGS, "SetRange(Range)\n\ntype: Range: float" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIInventoryItem__tp_dealloc(PyIInventoryItem *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIInventoryItem__tp_richcompare(PyIInventoryItem *PYBINDGEN_UNUSED(self), PyIInventoryItem *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIInventoryItem_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIInventoryItem_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IInventoryItem",            /* tp_name */
	sizeof(PyIInventoryItem),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIInventoryItem__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIInventoryItem__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIInventoryItem_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIInventoryItem__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIMissileData__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IMissileData' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIMissileData_GetStartPosition(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };
	PyVec3 *py_Vec3;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	Vec3 retval = self->obj->GetStartPosition(MissileUnit_ptr);
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetRange(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetRange(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetCastConeAngle(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetCastConeAngle(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetBaseDamage(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetBaseDamage(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_IsAutoAttack(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->IsAutoAttack(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetSpellSlot(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetSpellSlot(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetEndPosition(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };
	PyVec3 *py_Vec3;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	Vec3 retval = self->obj->GetEndPosition(MissileUnit_ptr);
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetTarget(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetTarget(MissileUnit_ptr);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetSpellCastTime(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetSpellCastTime(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetCaster(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetCaster(MissileUnit_ptr);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetSpeed(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetSpeed(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetName(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetName(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "s", retval);
	return py_retval;
}


PyObject *
_wrap_PyIMissileData_GetRadius(PyIMissileData *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyIUnit *MissileUnit;
	IUnit *MissileUnit_ptr;
	const char *keywords[] = { "MissileUnit", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &MissileUnit)) {
		return NULL;
	}
	MissileUnit_ptr = (MissileUnit ? MissileUnit->obj : NULL);
	retval = self->obj->GetRadius(MissileUnit_ptr);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}

static PyMethodDef PyIMissileData_methods[] = {
	{ (char *) "GetStartPosition", (PyCFunction)_wrap_PyIMissileData_GetStartPosition, METH_KEYWORDS | METH_VARARGS, "GetStartPosition(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetRange", (PyCFunction)_wrap_PyIMissileData_GetRange, METH_KEYWORDS | METH_VARARGS, "GetRange(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetCastConeAngle", (PyCFunction)_wrap_PyIMissileData_GetCastConeAngle, METH_KEYWORDS | METH_VARARGS, "GetCastConeAngle(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetBaseDamage", (PyCFunction)_wrap_PyIMissileData_GetBaseDamage, METH_KEYWORDS | METH_VARARGS, "GetBaseDamage(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "IsAutoAttack", (PyCFunction)_wrap_PyIMissileData_IsAutoAttack, METH_KEYWORDS | METH_VARARGS, "IsAutoAttack(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetSpellSlot", (PyCFunction)_wrap_PyIMissileData_GetSpellSlot, METH_KEYWORDS | METH_VARARGS, "GetSpellSlot(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetEndPosition", (PyCFunction)_wrap_PyIMissileData_GetEndPosition, METH_KEYWORDS | METH_VARARGS, "GetEndPosition(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetTarget", (PyCFunction)_wrap_PyIMissileData_GetTarget, METH_KEYWORDS | METH_VARARGS, "GetTarget(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetSpellCastTime", (PyCFunction)_wrap_PyIMissileData_GetSpellCastTime, METH_KEYWORDS | METH_VARARGS, "GetSpellCastTime(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetCaster", (PyCFunction)_wrap_PyIMissileData_GetCaster, METH_KEYWORDS | METH_VARARGS, "GetCaster(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetSpeed", (PyCFunction)_wrap_PyIMissileData_GetSpeed, METH_KEYWORDS | METH_VARARGS, "GetSpeed(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetName", (PyCFunction)_wrap_PyIMissileData_GetName, METH_KEYWORDS | METH_VARARGS, "GetName(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ (char *) "GetRadius", (PyCFunction)_wrap_PyIMissileData_GetRadius, METH_KEYWORDS | METH_VARARGS, "GetRadius(MissileUnit)\n\ntype: MissileUnit: IUnit *" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIMissileData__tp_dealloc(PyIMissileData *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIMissileData__tp_richcompare(PyIMissileData *PYBINDGEN_UNUSED(self), PyIMissileData *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIMissileData_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIMissileData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IMissileData",            /* tp_name */
	sizeof(PyIMissileData),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIMissileData__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIMissileData__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIMissileData_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIMissileData__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyINavMesh__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'INavMesh' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyINavMesh_IsPointGrass(PyINavMesh *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->IsPointGrass(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyINavMesh_IsPointWall(PyINavMesh *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->IsPointWall(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyINavMesh_TestLineOfSight(PyINavMesh *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *StartPosition;
	PyVec3 *EndPosition;
	PyVec3 *CollisionPositionOut;
	int  CollisionFlagsOut;
	const char *keywords[] = { "StartPosition", "EndPosition", "CollisionPositionOut", "CollisionFlagsOut", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **)keywords, &PyVec3_Type, &StartPosition, &PyVec3_Type, &EndPosition, &PyVec3_Type, &CollisionPositionOut, &CollisionFlagsOut)) {
		return NULL;
	}
	retval = self->obj->TestLineOfSight(*((PyVec3 *)StartPosition)->obj, *((PyVec3 *)EndPosition)->obj, *((PyVec3 *)CollisionPositionOut)->obj, CollisionFlagsOut);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyINavMesh_GetCollisionFlagsForPoint(PyINavMesh *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->GetCollisionFlagsForPoint(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyINavMesh_GetHeightForPoint(PyINavMesh *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	PyVec2 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->GetHeightForPoint(*((PyVec2 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}

static PyMethodDef PyINavMesh_methods[] = {
	{ (char *) "IsPointGrass", (PyCFunction)_wrap_PyINavMesh_IsPointGrass, METH_KEYWORDS | METH_VARARGS, "IsPointGrass(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "IsPointWall", (PyCFunction)_wrap_PyINavMesh_IsPointWall, METH_KEYWORDS | METH_VARARGS, "IsPointWall(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "TestLineOfSight", (PyCFunction)_wrap_PyINavMesh_TestLineOfSight, METH_KEYWORDS | METH_VARARGS, "TestLineOfSight(StartPosition, EndPosition, CollisionPositionOut, CollisionFlagsOut)\n\ntype: StartPosition: Vec3 const &\ntype: EndPosition: Vec3 const &\ntype: CollisionPositionOut: Vec3 const &\ntype: CollisionFlagsOut: int &" },
	{ (char *) "GetCollisionFlagsForPoint", (PyCFunction)_wrap_PyINavMesh_GetCollisionFlagsForPoint, METH_KEYWORDS | METH_VARARGS, "GetCollisionFlagsForPoint(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "GetHeightForPoint", (PyCFunction)_wrap_PyINavMesh_GetHeightForPoint, METH_KEYWORDS | METH_VARARGS, "GetHeightForPoint(Position)\n\ntype: Position: Vec2 const &" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyINavMesh__tp_dealloc(PyINavMesh *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyINavMesh__tp_richcompare(PyINavMesh *PYBINDGEN_UNUSED(self), PyINavMesh *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyINavMesh_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyINavMesh_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.INavMesh",            /* tp_name */
	sizeof(PyINavMesh),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyINavMesh__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyINavMesh__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyINavMesh_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyINavMesh__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIUtility__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IUtility' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIUtility_IsPositionInFountain(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Source;
	bool CheckTeamFountain;
	PyObject *py_CheckTeamFountain = NULL;
	bool CheckEnemyFountain;
	PyObject *py_CheckEnemyFountain = NULL;
	const char *keywords[] = { "Source", "CheckTeamFountain", "CheckEnemyFountain", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!|OO", (char **)keywords, &PyVec3_Type, &Source, &py_CheckTeamFountain, &py_CheckEnemyFountain)) {
		return NULL;
	}
	CheckTeamFountain = py_CheckTeamFountain ? (bool)PyObject_IsTrue(py_CheckTeamFountain) : true;
	CheckEnemyFountain = py_CheckEnemyFountain ? (bool)PyObject_IsTrue(py_CheckEnemyFountain) : false;
	retval = self->obj->IsPositionInFountain(*((PyVec3 *)Source)->obj, CheckTeamFountain, CheckEnemyFountain);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUtility_IsLeagueWindowFocused(PyIUtility *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsLeagueWindowFocused();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUtility_ClearLogFile(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *Filename;
	const char *keywords[] = { "Filename", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Filename)) {
		return NULL;
	}
	self->obj->ClearLogFile(Filename);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIUtility_CreateDebugConsole(PyIUtility *self)
{
	PyObject *py_retval;

	self->obj->CreateDebugConsole();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIUtility_GetExperienceRequiredForLevel(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	float retval;
	int Level;
	const char *keywords[] = { "Level", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Level)) {
		return NULL;
	}
	retval = self->obj->GetExperienceRequiredForLevel(Level);
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUtility_LogConsole(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *Message;
	const char *keywords[] = { "Message", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Message)) {
		return NULL;
	}
	self->obj->LogConsole(Message);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIUtility_DestroyDebugConsole(PyIUtility *self)
{
	PyObject *py_retval;

	self->obj->DestroyDebugConsole();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIUtility_IsPositionUnderTurret(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Source;
	bool CheckTeamTurrets;
	PyObject *py_CheckTeamTurrets = NULL;
	bool CheckEnemyTurrets;
	PyObject *py_CheckEnemyTurrets = NULL;
	const char *keywords[] = { "Source", "CheckTeamTurrets", "CheckEnemyTurrets", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!|OO", (char **)keywords, &PyVec3_Type, &Source, &py_CheckTeamTurrets, &py_CheckEnemyTurrets)) {
		return NULL;
	}
	CheckTeamTurrets = py_CheckTeamTurrets ? (bool)PyObject_IsTrue(py_CheckTeamTurrets) : false;
	CheckEnemyTurrets = py_CheckEnemyTurrets ? (bool)PyObject_IsTrue(py_CheckEnemyTurrets) : true;
	retval = self->obj->IsPositionUnderTurret(*((PyVec3 *)Source)->obj, CheckTeamTurrets, CheckEnemyTurrets);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIUtility_LogFile(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *Filename;
	char const *Message;
	const char *keywords[] = { "Filename", "Message", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ss", (char **)keywords, &Filename, &Message)) {
		return NULL;
	}
	self->obj->LogFile(Filename, Message);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIUtility_GetRecallDuration(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int retval;
	char const *RecallSpellName;
	const char *keywords[] = { "RecallSpellName", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &RecallSpellName)) {
		return NULL;
	}
	retval = self->obj->GetRecallDuration(RecallSpellName);
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIUtility_To3D(PyIUtility *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *Other;
	const char *keywords[] = { "Other", NULL };
	PyVec3 *py_Vec3;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec2_Type, &Other)) {
		return NULL;
	}
	Vec3 retval = self->obj->To3D(*((PyVec2 *)Other)->obj);
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}

static PyMethodDef PyIUtility_methods[] = {
	{ (char *) "IsPositionInFountain", (PyCFunction)_wrap_PyIUtility_IsPositionInFountain, METH_KEYWORDS | METH_VARARGS, "IsPositionInFountain(Source, CheckTeamFountain, CheckEnemyFountain)\n\ntype: Source: Vec3 const &\ntype: CheckTeamFountain: bool\ntype: CheckEnemyFountain: bool" },
	{ (char *) "IsLeagueWindowFocused", (PyCFunction)_wrap_PyIUtility_IsLeagueWindowFocused, METH_NOARGS, "IsLeagueWindowFocused()\n\n" },
	{ (char *) "ClearLogFile", (PyCFunction)_wrap_PyIUtility_ClearLogFile, METH_KEYWORDS | METH_VARARGS, "ClearLogFile(Filename)\n\ntype: Filename: char const *" },
	{ (char *) "CreateDebugConsole", (PyCFunction)_wrap_PyIUtility_CreateDebugConsole, METH_NOARGS, "CreateDebugConsole()\n\n" },
	{ (char *) "GetExperienceRequiredForLevel", (PyCFunction)_wrap_PyIUtility_GetExperienceRequiredForLevel, METH_KEYWORDS | METH_VARARGS, "GetExperienceRequiredForLevel(Level)\n\ntype: Level: int" },
	{ (char *) "LogConsole", (PyCFunction)_wrap_PyIUtility_LogConsole, METH_KEYWORDS | METH_VARARGS, "LogConsole(Message)\n\ntype: Message: char const *" },
	{ (char *) "DestroyDebugConsole", (PyCFunction)_wrap_PyIUtility_DestroyDebugConsole, METH_NOARGS, "DestroyDebugConsole()\n\n" },
	{ (char *) "IsPositionUnderTurret", (PyCFunction)_wrap_PyIUtility_IsPositionUnderTurret, METH_KEYWORDS | METH_VARARGS, "IsPositionUnderTurret(Source, CheckTeamTurrets, CheckEnemyTurrets)\n\ntype: Source: Vec3 const &\ntype: CheckTeamTurrets: bool\ntype: CheckEnemyTurrets: bool" },
	{ (char *) "LogFile", (PyCFunction)_wrap_PyIUtility_LogFile, METH_KEYWORDS | METH_VARARGS, "LogFile(Filename, Message)\n\ntype: Filename: char const *\ntype: Message: char const *" },
	{ (char *) "GetRecallDuration", (PyCFunction)_wrap_PyIUtility_GetRecallDuration, METH_KEYWORDS | METH_VARARGS, "GetRecallDuration(RecallSpellName)\n\ntype: RecallSpellName: char const *" },
	{ (char *) "To3D", (PyCFunction)_wrap_PyIUtility_To3D, METH_KEYWORDS | METH_VARARGS, "To3D(Other)\n\ntype: Other: Vec2 const &" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIUtility__tp_dealloc(PyIUtility *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIUtility__tp_richcompare(PyIUtility *PYBINDGEN_UNUSED(self), PyIUtility *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIUtility_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIUtility_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IUtility",            /* tp_name */
	sizeof(PyIUtility),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIUtility__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIUtility__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIUtility_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIUtility__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIPluginSDK__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IPluginSDK' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIPluginSDK_CreateSpell2(PyIPluginSDK *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	ISpell2 *retval;
	eSpellSlot Slot;
	eSpellType Type;
	bool IsMissile;
	PyObject *py_IsMissile;
	bool IsAoE;
	PyObject *py_IsAoE;
	int CollisionFlags;
	const char *keywords[] = { "Slot", "Type", "IsMissile", "IsAoE", "CollisionFlags", NULL };
	PyISpell2 *py_ISpell2;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iiOOi", (char **)keywords, &Slot, &Type, &py_IsMissile, &py_IsAoE, &CollisionFlags)) {
		return NULL;
	}
	IsMissile = (bool)PyObject_IsTrue(py_IsMissile);
	IsAoE = (bool)PyObject_IsTrue(py_IsAoE);
	retval = self->obj->CreateSpell2(Slot, Type, IsMissile, IsAoE, CollisionFlags);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_ISpell2 = PyObject_New(PyISpell2, &PyISpell2_Type);
	py_ISpell2->obj = retval;
	py_ISpell2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_ISpell2);
	return py_retval;
}


PyObject *
_wrap_PyIPluginSDK_ReadFileFromURL(PyIPluginSDK *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	const char *Url = NULL;
	Py_ssize_t Url_len;
	std::string Url_std;
	const char *Out = NULL;
	Py_ssize_t Out_len;
	std::string Out_std;
	const char *keywords[] = { "Url", "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **)keywords, &Url, &Url_len, &Out, &Out_len)) {
		return NULL;
	}
	Url_std = std::string(Url, Url_len);
	Out_std = std::string(Out, Out_len);
	retval = self->obj->ReadFileFromURL(Url_std, Out_std);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIPluginSDK_AddMenu(PyIPluginSDK *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IMenu *retval;
	char const *MenuTitle;
	const char *keywords[] = { "MenuTitle", NULL };
	PyIMenu *py_IMenu;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &MenuTitle)) {
		return NULL;
	}
	retval = self->obj->AddMenu(MenuTitle);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IMenu = PyObject_New(PyIMenu, &PyIMenu_Type);
	py_IMenu->obj = retval;
	py_IMenu->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IMenu);
	return py_retval;
}



PyObject *
_wrap_PyIPluginSDK_GetBaseDirectory__0(PyIPluginSDK *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	const char *Out = NULL;
	Py_ssize_t Out_len;
	std::string Out_std;
	const char *keywords[] = { "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **)keywords, &Out, &Out_len)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Out_std = std::string(Out, Out_len);
	self->obj->GetBaseDirectory(Out_std);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyIPluginSDK_GetBaseDirectory__1(PyIPluginSDK *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	const char *Out = NULL;
	Py_ssize_t Out_len;
	std::string Out_std;
	const char *keywords[] = { "Out", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **)keywords, &Out, &Out_len)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Out_std = std::string(Out, Out_len);
	self->obj->GetBaseDirectory(Out_std);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyIPluginSDK_GetBaseDirectory(PyIPluginSDK *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIPluginSDK_GetBaseDirectory__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIPluginSDK_GetBaseDirectory__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIPluginSDK_CreateItemForId(PyIPluginSDK *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IInventoryItem *retval;
	int ItemId;
	float Range;
	const char *keywords[] = { "ItemId", "Range", NULL };
	PyIInventoryItem *py_IInventoryItem;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "if", (char **)keywords, &ItemId, &Range)) {
		return NULL;
	}
	retval = self->obj->CreateItemForId(ItemId, Range);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IInventoryItem = PyObject_New(PyIInventoryItem, &PyIInventoryItem_Type);
	py_IInventoryItem->obj = retval;
	py_IInventoryItem->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IInventoryItem);
	return py_retval;
}

static PyMethodDef PyIPluginSDK_methods[] = {
	{ (char *) "CreateSpell2", (PyCFunction)_wrap_PyIPluginSDK_CreateSpell2, METH_KEYWORDS | METH_VARARGS, "CreateSpell2(Slot, Type, IsMissile, IsAoE, CollisionFlags)\n\ntype: Slot: eSpellSlot\ntype: Type: eSpellType\ntype: IsMissile: bool\ntype: IsAoE: bool\ntype: CollisionFlags: int" },
	{ (char *) "ReadFileFromURL", (PyCFunction)_wrap_PyIPluginSDK_ReadFileFromURL, METH_KEYWORDS | METH_VARARGS, "ReadFileFromURL(Url, Out)\n\ntype: Url: std::string const &\ntype: Out: std::string &" },
	{ (char *) "AddMenu", (PyCFunction)_wrap_PyIPluginSDK_AddMenu, METH_KEYWORDS | METH_VARARGS, "AddMenu(MenuTitle)\n\ntype: MenuTitle: char const *" },
	{ (char *) "GetBaseDirectory", (PyCFunction)_wrap_PyIPluginSDK_GetBaseDirectory, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "CreateItemForId", (PyCFunction)_wrap_PyIPluginSDK_CreateItemForId, METH_KEYWORDS | METH_VARARGS, "CreateItemForId(ItemId, Range)\n\ntype: ItemId: int\ntype: Range: float" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIPluginSDK__tp_dealloc(PyIPluginSDK *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIPluginSDK__tp_richcompare(PyIPluginSDK *PYBINDGEN_UNUSED(self), PyIPluginSDK *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIPluginSDK_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIPluginSDK_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IPluginSDK",            /* tp_name */
	sizeof(PyIPluginSDK),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIPluginSDK__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIPluginSDK__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIPluginSDK_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIPluginSDK__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIEntityList__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IEntityList' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIEntityList_GetEntityByNetworkId(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	int NetworkId;
	const char *keywords[] = { "NetworkId", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &NetworkId)) {
		return NULL;
	}
	retval = self->obj->GetEntityByNetworkId(NetworkId);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllInhibitors(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Friendly;
	PyObject *py_Friendly;
	bool Enemy;
	PyObject *py_Enemy;
	const char *keywords[] = { "Friendly", "Enemy", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO", (char **)keywords, &py_Friendly, &py_Enemy)) {
		return NULL;
	}
	Friendly = (bool)PyObject_IsTrue(py_Friendly);
	Enemy = (bool)PyObject_IsTrue(py_Enemy);
	retval = self->obj->GetAllInhibitors(Friendly, Enemy);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_DoesObjectExist(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	const char *keywords[] = { "Source", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyIUnit_Type, &Source)) {
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	retval = self->obj->DoesObjectExist(Source_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllHeros(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Friendly;
	PyObject *py_Friendly;
	bool Enemy;
	PyObject *py_Enemy;
	const char *keywords[] = { "Friendly", "Enemy", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO", (char **)keywords, &py_Friendly, &py_Enemy)) {
		return NULL;
	}
	Friendly = (bool)PyObject_IsTrue(py_Friendly);
	Enemy = (bool)PyObject_IsTrue(py_Enemy);
	retval = self->obj->GetAllHeros(Friendly, Enemy);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetTeamNexus(PyIEntityList *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->GetTeamNexus();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetEntityAt(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	int Idx;
	const char *keywords[] = { "Idx", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Idx)) {
		return NULL;
	}
	retval = self->obj->GetEntityAt(Idx);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetEnemyNexus(PyIEntityList *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->GetEnemyNexus();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_Player(PyIEntityList *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->Player();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllUnitsOfType(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	eGameObjectClassId ClassId;
	const char *keywords[] = { "ClassId", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &ClassId)) {
		return NULL;
	}
	retval = self->obj->GetAllUnitsOfType(ClassId);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllMissiles(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Friendly;
	PyObject *py_Friendly;
	bool Enemy;
	PyObject *py_Enemy;
	const char *keywords[] = { "Friendly", "Enemy", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO", (char **)keywords, &py_Friendly, &py_Enemy)) {
		return NULL;
	}
	Friendly = (bool)PyObject_IsTrue(py_Friendly);
	Enemy = (bool)PyObject_IsTrue(py_Enemy);
	retval = self->obj->GetAllMissiles(Friendly, Enemy);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllMinionsAndWards(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Friendly;
	PyObject *py_Friendly;
	bool Enemy;
	PyObject *py_Enemy;
	bool Neutral;
	PyObject *py_Neutral;
	const char *keywords[] = { "Friendly", "Enemy", "Neutral", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OOO", (char **)keywords, &py_Friendly, &py_Enemy, &py_Neutral)) {
		return NULL;
	}
	Friendly = (bool)PyObject_IsTrue(py_Friendly);
	Enemy = (bool)PyObject_IsTrue(py_Enemy);
	Neutral = (bool)PyObject_IsTrue(py_Neutral);
	retval = self->obj->GetAllMinionsAndWards(Friendly, Enemy, Neutral);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetEntityByTargetId(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	IUnit *retval;
	int TargetId;
	const char *keywords[] = { "TargetId", NULL };
	PyIUnit *py_IUnit;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &TargetId)) {
		return NULL;
	}
	retval = self->obj->GetEntityByTargetId(TargetId);
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllUnitsOfTypes(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	std::vector<eGameObjectClassId> ClassIdList_value;
	const char *keywords[] = { "ClassIdList", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **)keywords, _wrap_convert_py2c__std__vector__lt___eGameObjectClassId___gt__, &ClassIdList_value)) {
		return NULL;
	}
	retval = self->obj->GetAllUnitsOfTypes(ClassIdList_value);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllTurrets(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Friendly;
	PyObject *py_Friendly;
	bool Enemy;
	PyObject *py_Enemy;
	const char *keywords[] = { "Friendly", "Enemy", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO", (char **)keywords, &py_Friendly, &py_Enemy)) {
		return NULL;
	}
	Friendly = (bool)PyObject_IsTrue(py_Friendly);
	Enemy = (bool)PyObject_IsTrue(py_Enemy);
	retval = self->obj->GetAllTurrets(Friendly, Enemy);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_NumberOfEntities(PyIEntityList *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->NumberOfEntities();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllUnits(PyIEntityList *self)
{
	PyObject *py_retval;
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	retval = self->obj->GetAllUnits();
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}


PyObject *
_wrap_PyIEntityList_GetAllMinions(PyIEntityList *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool Friendly;
	PyObject *py_Friendly;
	bool Enemy;
	PyObject *py_Enemy;
	bool Neutral;
	PyObject *py_Neutral;
	const char *keywords[] = { "Friendly", "Enemy", "Neutral", NULL };
	std::vector< IUnit * > retval;
	Pystd__vector__lt__IUnit__star____gt__ *py_std__vector__lt__IUnit__star____gt__;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OOO", (char **)keywords, &py_Friendly, &py_Enemy, &py_Neutral)) {
		return NULL;
	}
	Friendly = (bool)PyObject_IsTrue(py_Friendly);
	Enemy = (bool)PyObject_IsTrue(py_Enemy);
	Neutral = (bool)PyObject_IsTrue(py_Neutral);
	retval = self->obj->GetAllMinions(Friendly, Enemy, Neutral);
	py_std__vector__lt__IUnit__star____gt__ = PyObject_New(Pystd__vector__lt__IUnit__star____gt__, &Pystd__vector__lt__IUnit__star____gt___Type);
	py_std__vector__lt__IUnit__star____gt__->obj = new std::vector<IUnit*>(retval);
	py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__IUnit__star____gt__);
	return py_retval;
}

static PyMethodDef PyIEntityList_methods[] = {
	{ (char *) "GetEntityByNetworkId", (PyCFunction)_wrap_PyIEntityList_GetEntityByNetworkId, METH_KEYWORDS | METH_VARARGS, "GetEntityByNetworkId(NetworkId)\n\ntype: NetworkId: int" },
	{ (char *) "GetAllInhibitors", (PyCFunction)_wrap_PyIEntityList_GetAllInhibitors, METH_KEYWORDS | METH_VARARGS, "GetAllInhibitors(Friendly, Enemy)\n\ntype: Friendly: bool\ntype: Enemy: bool" },
	{ (char *) "DoesObjectExist", (PyCFunction)_wrap_PyIEntityList_DoesObjectExist, METH_KEYWORDS | METH_VARARGS, "DoesObjectExist(Source)\n\ntype: Source: IUnit *" },
	{ (char *) "GetAllHeros", (PyCFunction)_wrap_PyIEntityList_GetAllHeros, METH_KEYWORDS | METH_VARARGS, "GetAllHeros(Friendly, Enemy)\n\ntype: Friendly: bool\ntype: Enemy: bool" },
	{ (char *) "GetTeamNexus", (PyCFunction)_wrap_PyIEntityList_GetTeamNexus, METH_NOARGS, "GetTeamNexus()\n\n" },
	{ (char *) "GetEntityAt", (PyCFunction)_wrap_PyIEntityList_GetEntityAt, METH_KEYWORDS | METH_VARARGS, "GetEntityAt(Idx)\n\ntype: Idx: int" },
	{ (char *) "GetEnemyNexus", (PyCFunction)_wrap_PyIEntityList_GetEnemyNexus, METH_NOARGS, "GetEnemyNexus()\n\n" },
	{ (char *) "Player", (PyCFunction)_wrap_PyIEntityList_Player, METH_NOARGS, "Player()\n\n" },
	{ (char *) "GetAllUnitsOfType", (PyCFunction)_wrap_PyIEntityList_GetAllUnitsOfType, METH_KEYWORDS | METH_VARARGS, "GetAllUnitsOfType(ClassId)\n\ntype: ClassId: eGameObjectClassId" },
	{ (char *) "GetAllMissiles", (PyCFunction)_wrap_PyIEntityList_GetAllMissiles, METH_KEYWORDS | METH_VARARGS, "GetAllMissiles(Friendly, Enemy)\n\ntype: Friendly: bool\ntype: Enemy: bool" },
	{ (char *) "GetAllMinionsAndWards", (PyCFunction)_wrap_PyIEntityList_GetAllMinionsAndWards, METH_KEYWORDS | METH_VARARGS, "GetAllMinionsAndWards(Friendly, Enemy, Neutral)\n\ntype: Friendly: bool\ntype: Enemy: bool\ntype: Neutral: bool" },
	{ (char *) "GetEntityByTargetId", (PyCFunction)_wrap_PyIEntityList_GetEntityByTargetId, METH_KEYWORDS | METH_VARARGS, "GetEntityByTargetId(TargetId)\n\ntype: TargetId: int" },
	{ (char *) "GetAllUnitsOfTypes", (PyCFunction)_wrap_PyIEntityList_GetAllUnitsOfTypes, METH_KEYWORDS | METH_VARARGS, "GetAllUnitsOfTypes(ClassIdList)\n\ntype: ClassIdList: std::vector< eGameObjectClassId >" },
	{ (char *) "GetAllTurrets", (PyCFunction)_wrap_PyIEntityList_GetAllTurrets, METH_KEYWORDS | METH_VARARGS, "GetAllTurrets(Friendly, Enemy)\n\ntype: Friendly: bool\ntype: Enemy: bool" },
	{ (char *) "NumberOfEntities", (PyCFunction)_wrap_PyIEntityList_NumberOfEntities, METH_NOARGS, "NumberOfEntities()\n\n" },
	{ (char *) "GetAllUnits", (PyCFunction)_wrap_PyIEntityList_GetAllUnits, METH_NOARGS, "GetAllUnits()\n\n" },
	{ (char *) "GetAllMinions", (PyCFunction)_wrap_PyIEntityList_GetAllMinions, METH_KEYWORDS | METH_VARARGS, "GetAllMinions(Friendly, Enemy, Neutral)\n\ntype: Friendly: bool\ntype: Enemy: bool\ntype: Neutral: bool" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIEntityList__tp_dealloc(PyIEntityList *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIEntityList__tp_richcompare(PyIEntityList *PYBINDGEN_UNUSED(self), PyIEntityList *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIEntityList_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIEntityList_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IEntityList",            /* tp_name */
	sizeof(PyIEntityList),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIEntityList__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIEntityList__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIEntityList_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIEntityList__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIGame__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IGame' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIGame_Latency(PyIGame *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->Latency();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_Quit(PyIGame *self)
{
	PyObject *py_retval;

	self->obj->Quit();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_Time(PyIGame *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->Time();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_TickCount(PyIGame *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->TickCount();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_SellItem(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->SellItem(Slot);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIGame_WithinFogOfWar(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *Position;
	const char *keywords[] = { "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **)keywords, &PyVec3_Type, &Position)) {
		return NULL;
	}
	retval = self->obj->WithinFogOfWar(*((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}



PyObject *
_wrap_PyIGame_SendPing__0(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	int PingType;
	PyIUnit *Target;
	IUnit *Target_ptr;
	const char *keywords[] = { "PingType", "Target", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!", (char **)keywords, &PingType, &PyIUnit_Type, &Target)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	self->obj->SendPing(PingType, Target_ptr);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyIGame_SendPing__1(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	int PingType;
	PyVec3 *Position;
	const char *keywords[] = { "PingType", "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!", (char **)keywords, &PingType, &PyVec3_Type, &Position)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	self->obj->SendPing(PingType, *((PyVec3 *)Position)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyIGame_SendPing(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIGame_SendPing__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIGame_SendPing__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIGame_Status(PyIGame *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->Status();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_Taunt(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int TauntId;
	const char *keywords[] = { "TauntId", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &TauntId)) {
		return NULL;
	}
	self->obj->Taunt(TauntId);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_PrintChat(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *Input;
	const char *keywords[] = { "Input", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Input)) {
		return NULL;
	}
	self->obj->PrintChat(Input);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_ScreenToWorld(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	PyVec2 *ScreenPosition;
	PyVec3 *WorldPosition;
	Vec3 *WorldPosition_ptr;
	const char *keywords[] = { "ScreenPosition", "WorldPosition", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **)keywords, &PyVec2_Type, &ScreenPosition, &PyVec3_Type, &WorldPosition)) {
		return NULL;
	}
	WorldPosition_ptr = (WorldPosition ? WorldPosition->obj : NULL);
	self->obj->ScreenToWorld(*((PyVec2 *)ScreenPosition)->obj, WorldPosition_ptr);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_BuyItem(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	int ItemId;
	const char *keywords[] = { "ItemId", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &ItemId)) {
		return NULL;
	}
	retval = self->obj->BuyItem(ItemId);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIGame_IsScoreboardOpen(PyIGame *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsScoreboardOpen();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIGame_PrintChatEx(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *Input;
	PyVec3 *Color;
	const char *keywords[] = { "Input", "Color", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "sO!", (char **)keywords, &Input, &PyVec3_Type, &Color)) {
		return NULL;
	}
	self->obj->PrintChatEx(Input, *((PyVec3 *)Color)->obj);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_SwapItems(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	int Slot1;
	int Slot2;
	const char *keywords[] = { "Slot1", "Slot2", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **)keywords, &Slot1, &Slot2)) {
		return NULL;
	}
	self->obj->SwapItems(Slot1, Slot2);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_CursorPosition(PyIGame *self)
{
	PyObject *py_retval;
	PyVec3 *py_Vec3;

	Vec3 const & retval = self->obj->CursorPosition();
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3(retval);
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}


PyObject *
_wrap_PyIGame_CanLevelUpSpell(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	int Slot;
	const char *keywords[] = { "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **)keywords, &Slot)) {
		return NULL;
	}
	retval = self->obj->CanLevelUpSpell(Slot);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}



PyObject *
_wrap_PyIGame_IssueOrder__0(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	eGameObjectOrder Order;
	PyVec3 *Position;
	const char *keywords[] = { "Source", "Order", "Position", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!iO!", (char **)keywords, &PyIUnit_Type, &Source, &Order, &PyVec3_Type, &Position)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	retval = self->obj->IssueOrder(Source_ptr, Order, *((PyVec3 *)Position)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

PyObject *
_wrap_PyIGame_IssueOrder__1(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	eGameObjectOrder Order;
	PyIUnit *Target;
	IUnit *Target_ptr;
	const char *keywords[] = { "Source", "Order", "Target", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!iO!", (char **)keywords, &PyIUnit_Type, &Source, &Order, &PyIUnit_Type, &Target)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->IssueOrder(Source_ptr, Order, Target_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

PyObject * _wrap_PyIGame_IssueOrder(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIGame_IssueOrder__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIGame_IssueOrder__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIGame_IsShopOpen(PyIGame *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsShopOpen();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}



PyObject *
_wrap_PyIGame_IssueOrderEx__0(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	eGameObjectOrder Order;
	PyVec3 *Position;
	bool TriggerEvents;
	PyObject *py_TriggerEvents;
	const char *keywords[] = { "Source", "Order", "Position", "TriggerEvents", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!iO!O", (char **)keywords, &PyIUnit_Type, &Source, &Order, &PyVec3_Type, &Position, &py_TriggerEvents)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	TriggerEvents = (bool)PyObject_IsTrue(py_TriggerEvents);
	retval = self->obj->IssueOrderEx(Source_ptr, Order, *((PyVec3 *)Position)->obj, TriggerEvents);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

PyObject *
_wrap_PyIGame_IssueOrderEx__1(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	bool retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	eGameObjectOrder Order;
	PyIUnit *Target;
	IUnit *Target_ptr;
	bool TriggerEvents;
	PyObject *py_TriggerEvents;
	const char *keywords[] = { "Source", "Order", "Target", "TriggerEvents", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!iO!O", (char **)keywords, &PyIUnit_Type, &Source, &Order, &PyIUnit_Type, &Target, &py_TriggerEvents)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	TriggerEvents = (bool)PyObject_IsTrue(py_TriggerEvents);
	retval = self->obj->IssueOrderEx(Source_ptr, Order, Target_ptr, TriggerEvents);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

PyObject * _wrap_PyIGame_IssueOrderEx(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIGame_IssueOrderEx__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIGame_IssueOrderEx__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}



PyObject *
_wrap_PyIGame_ShowPing__0(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	int PingType;
	PyIUnit *Target;
	IUnit *Target_ptr;
	bool PlaySound;
	PyObject *py_PlaySound;
	const char *keywords[] = { "PingType", "Target", "PlaySound", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!O", (char **)keywords, &PingType, &PyIUnit_Type, &Target, &py_PlaySound)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Target_ptr = (Target ? Target->obj : NULL);
	PlaySound = (bool)PyObject_IsTrue(py_PlaySound);
	self->obj->ShowPing(PingType, Target_ptr, PlaySound);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject *
_wrap_PyIGame_ShowPing__1(PyIGame *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	int PingType;
	PyVec3 *Position;
	bool PlaySound;
	PyObject *py_PlaySound;
	const char *keywords[] = { "PingType", "Position", "PlaySound", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!O", (char **)keywords, &PingType, &PyVec3_Type, &Position, &py_PlaySound)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	PlaySound = (bool)PyObject_IsTrue(py_PlaySound);
	self->obj->ShowPing(PingType, *((PyVec3 *)Position)->obj, PlaySound);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}

PyObject * _wrap_PyIGame_ShowPing(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIGame_ShowPing__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIGame_ShowPing__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIGame_WorldToMinimap(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *World;
	PyVec2 *Minimap;
	const char *keywords[] = { "World", "Minimap", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **)keywords, &PyVec3_Type, &World, &PyVec2_Type, &Minimap)) {
		return NULL;
	}
	retval = self->obj->WorldToMinimap(*((PyVec3 *)World)->obj, *((PyVec2 *)Minimap)->obj);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIGame_Projection(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	bool retval;
	PyVec3 *WorldPosition;
	PyVec2 *ScreenPositionOut;
	Vec2 *ScreenPositionOut_ptr;
	const char *keywords[] = { "WorldPosition", "ScreenPositionOut", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **)keywords, &PyVec3_Type, &WorldPosition, &PyVec2_Type, &ScreenPositionOut)) {
		return NULL;
	}
	ScreenPositionOut_ptr = (ScreenPositionOut ? ScreenPositionOut->obj : NULL);
	retval = self->obj->Projection(*((PyVec3 *)WorldPosition)->obj, ScreenPositionOut_ptr);
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}


PyObject *
_wrap_PyIGame_CurrentTick(PyIGame *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->CurrentTick();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_GetSelectedTarget(PyIGame *self)
{
	PyObject *py_retval;
	IUnit *retval;
	PyIUnit *py_IUnit;

	retval = self->obj->GetSelectedTarget();
	if (!(retval)) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = retval;
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}


PyObject *
_wrap_PyIGame_GetMapId(PyIGame *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetMapId();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_Say(PyIGame *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	char const *Message;
	const char *keywords[] = { "Message", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **)keywords, &Message)) {
		return NULL;
	}
	self->obj->Say(Message);
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_IntervalPerTick(PyIGame *self)
{
	PyObject *py_retval;
	float retval;

	retval = self->obj->IntervalPerTick();
	py_retval = Py_BuildValue((char *) "f", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_GetGameType(PyIGame *self)
{
	PyObject *py_retval;
	int retval;

	retval = self->obj->GetGameType();
	py_retval = Py_BuildValue((char *) "i", retval);
	return py_retval;
}


PyObject *
_wrap_PyIGame_UndoBuy(PyIGame *self)
{
	PyObject *py_retval;

	self->obj->UndoBuy();
	Py_INCREF(Py_None);
	py_retval = Py_None;
	return py_retval;
}


PyObject *
_wrap_PyIGame_IsChatOpen(PyIGame *self)
{
	PyObject *py_retval;
	bool retval;

	retval = self->obj->IsChatOpen();
	py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
	return py_retval;
}

static PyMethodDef PyIGame_methods[] = {
	{ (char *) "Latency", (PyCFunction)_wrap_PyIGame_Latency, METH_NOARGS, "Latency()\n\n" },
	{ (char *) "Quit", (PyCFunction)_wrap_PyIGame_Quit, METH_NOARGS, "Quit()\n\n" },
	{ (char *) "Time", (PyCFunction)_wrap_PyIGame_Time, METH_NOARGS, "Time()\n\n" },
	{ (char *) "TickCount", (PyCFunction)_wrap_PyIGame_TickCount, METH_NOARGS, "TickCount()\n\n" },
	{ (char *) "SellItem", (PyCFunction)_wrap_PyIGame_SellItem, METH_KEYWORDS | METH_VARARGS, "SellItem(Slot)\n\ntype: Slot: int" },
	{ (char *) "WithinFogOfWar", (PyCFunction)_wrap_PyIGame_WithinFogOfWar, METH_KEYWORDS | METH_VARARGS, "WithinFogOfWar(Position)\n\ntype: Position: Vec3 const &" },
	{ (char *) "SendPing", (PyCFunction)_wrap_PyIGame_SendPing, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "Status", (PyCFunction)_wrap_PyIGame_Status, METH_NOARGS, "Status()\n\n" },
	{ (char *) "Taunt", (PyCFunction)_wrap_PyIGame_Taunt, METH_KEYWORDS | METH_VARARGS, "Taunt(TauntId)\n\ntype: TauntId: int" },
	{ (char *) "PrintChat", (PyCFunction)_wrap_PyIGame_PrintChat, METH_KEYWORDS | METH_VARARGS, "PrintChat(Input)\n\ntype: Input: char const *" },
	{ (char *) "ScreenToWorld", (PyCFunction)_wrap_PyIGame_ScreenToWorld, METH_KEYWORDS | METH_VARARGS, "ScreenToWorld(ScreenPosition, WorldPosition)\n\ntype: ScreenPosition: Vec2 const &\ntype: WorldPosition: Vec3 *" },
	{ (char *) "BuyItem", (PyCFunction)_wrap_PyIGame_BuyItem, METH_KEYWORDS | METH_VARARGS, "BuyItem(ItemId)\n\ntype: ItemId: int" },
	{ (char *) "IsScoreboardOpen", (PyCFunction)_wrap_PyIGame_IsScoreboardOpen, METH_NOARGS, "IsScoreboardOpen()\n\n" },
	{ (char *) "PrintChatEx", (PyCFunction)_wrap_PyIGame_PrintChatEx, METH_KEYWORDS | METH_VARARGS, "PrintChatEx(Input, Color)\n\ntype: Input: char const *\ntype: Color: Vec3 const &" },
	{ (char *) "SwapItems", (PyCFunction)_wrap_PyIGame_SwapItems, METH_KEYWORDS | METH_VARARGS, "SwapItems(Slot1, Slot2)\n\ntype: Slot1: int\ntype: Slot2: int" },
	{ (char *) "CursorPosition", (PyCFunction)_wrap_PyIGame_CursorPosition, METH_NOARGS, "CursorPosition()\n\n" },
	{ (char *) "CanLevelUpSpell", (PyCFunction)_wrap_PyIGame_CanLevelUpSpell, METH_KEYWORDS | METH_VARARGS, "CanLevelUpSpell(Slot)\n\ntype: Slot: int" },
	{ (char *) "IssueOrder", (PyCFunction)_wrap_PyIGame_IssueOrder, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "IsShopOpen", (PyCFunction)_wrap_PyIGame_IsShopOpen, METH_NOARGS, "IsShopOpen()\n\n" },
	{ (char *) "IssueOrderEx", (PyCFunction)_wrap_PyIGame_IssueOrderEx, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "ShowPing", (PyCFunction)_wrap_PyIGame_ShowPing, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "WorldToMinimap", (PyCFunction)_wrap_PyIGame_WorldToMinimap, METH_KEYWORDS | METH_VARARGS, "WorldToMinimap(World, Minimap)\n\ntype: World: Vec3 const &\ntype: Minimap: Vec2 &" },
	{ (char *) "Projection", (PyCFunction)_wrap_PyIGame_Projection, METH_KEYWORDS | METH_VARARGS, "Projection(WorldPosition, ScreenPositionOut)\n\ntype: WorldPosition: Vec3 const &\ntype: ScreenPositionOut: Vec2 *" },
	{ (char *) "CurrentTick", (PyCFunction)_wrap_PyIGame_CurrentTick, METH_NOARGS, "CurrentTick()\n\n" },
	{ (char *) "GetSelectedTarget", (PyCFunction)_wrap_PyIGame_GetSelectedTarget, METH_NOARGS, "GetSelectedTarget()\n\n" },
	{ (char *) "GetMapId", (PyCFunction)_wrap_PyIGame_GetMapId, METH_NOARGS, "GetMapId()\n\n" },
	{ (char *) "Say", (PyCFunction)_wrap_PyIGame_Say, METH_KEYWORDS | METH_VARARGS, "Say(Message)\n\ntype: Message: char const *" },
	{ (char *) "IntervalPerTick", (PyCFunction)_wrap_PyIGame_IntervalPerTick, METH_NOARGS, "IntervalPerTick()\n\n" },
	{ (char *) "GetGameType", (PyCFunction)_wrap_PyIGame_GetGameType, METH_NOARGS, "GetGameType()\n\n" },
	{ (char *) "UndoBuy", (PyCFunction)_wrap_PyIGame_UndoBuy, METH_NOARGS, "UndoBuy()\n\n" },
	{ (char *) "IsChatOpen", (PyCFunction)_wrap_PyIGame_IsChatOpen, METH_NOARGS, "IsChatOpen()\n\n" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIGame__tp_dealloc(PyIGame *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIGame__tp_richcompare(PyIGame *PYBINDGEN_UNUSED(self), PyIGame *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIGame_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIGame_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IGame",            /* tp_name */
	sizeof(PyIGame),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIGame__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIGame__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIGame_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIGame__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static int
_wrap_PyIDamage__tp_init(void)
{
	PyErr_SetString(PyExc_TypeError, "class 'IDamage' cannot be constructed (have pure virtual methods but no helper class)");
	return -1;
}


PyObject *
_wrap_PyIDamage_GetAutoAttackDamage(PyIDamage *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	double retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	PyIUnit *Target;
	IUnit *Target_ptr;
	bool Use_Passives;
	PyObject *py_Use_Passives;
	const char *keywords[] = { "Source", "Target", "Use_Passives", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O", (char **)keywords, &PyIUnit_Type, &Source, &PyIUnit_Type, &Target, &py_Use_Passives)) {
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	Use_Passives = (bool)PyObject_IsTrue(py_Use_Passives);
	retval = self->obj->GetAutoAttackDamage(Source_ptr, Target_ptr, Use_Passives);
	py_retval = Py_BuildValue((char *) "d", retval);
	return py_retval;
}


PyObject *
_wrap_PyIDamage_CalcMagicDamage(PyIDamage *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	double retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	PyIUnit *Target;
	IUnit *Target_ptr;
	double Damage;
	const char *keywords[] = { "Source", "Target", "Damage", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!d", (char **)keywords, &PyIUnit_Type, &Source, &PyIUnit_Type, &Target, &Damage)) {
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->CalcMagicDamage(Source_ptr, Target_ptr, Damage);
	py_retval = Py_BuildValue((char *) "d", retval);
	return py_retval;
}



PyObject *
_wrap_PyIDamage_GetSpellDamage__0(PyIDamage *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	double retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	PyIUnit *Target;
	IUnit *Target_ptr;
	int Slot;
	const char *keywords[] = { "Source", "Target", "Slot", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **)keywords, &PyIUnit_Type, &Source, &PyIUnit_Type, &Target, &Slot)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->GetSpellDamage(Source_ptr, Target_ptr, Slot);
	py_retval = Py_BuildValue((char *) "d", retval);
	return py_retval;
}

PyObject *
_wrap_PyIDamage_GetSpellDamage__1(PyIDamage *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
	PyObject *py_retval;
	double retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	PyIUnit *Target;
	IUnit *Target_ptr;
	int Slot;
	int Stage;
	const char *keywords[] = { "Source", "Target", "Slot", "Stage", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!ii", (char **)keywords, &PyIUnit_Type, &Source, &PyIUnit_Type, &Target, &Slot, &Stage)) {
		{
			PyObject *exc_type, *traceback;
			PyErr_Fetch(&exc_type, return_exception, &traceback);
			Py_XDECREF(exc_type);
			Py_XDECREF(traceback);
		}
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->GetSpellDamage(Source_ptr, Target_ptr, Slot, Stage);
	py_retval = Py_BuildValue((char *) "d", retval);
	return py_retval;
}

PyObject * _wrap_PyIDamage_GetSpellDamage(PyIDamage *self, PyObject *args, PyObject *kwargs)
{
	PyObject * retval;
	PyObject *error_list;
	PyObject *exceptions[2] = { 0, };
	retval = _wrap_PyIDamage_GetSpellDamage__0(self, args, kwargs, &exceptions[0]);
	if (!exceptions[0]) {
		return retval;
	}
	retval = _wrap_PyIDamage_GetSpellDamage__1(self, args, kwargs, &exceptions[1]);
	if (!exceptions[1]) {
		Py_DECREF(exceptions[0]);
		return retval;
	}
	error_list = PyList_New(2);
	PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
	Py_DECREF(exceptions[0]);
	PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
	Py_DECREF(exceptions[1]);
	PyErr_SetObject(PyExc_TypeError, error_list);
	Py_DECREF(error_list);
	return NULL;
}


PyObject *
_wrap_PyIDamage_CalcPhysicalDamage(PyIDamage *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	double retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	PyIUnit *Target;
	IUnit *Target_ptr;
	double Damage;
	const char *keywords[] = { "Source", "Target", "Damage", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!d", (char **)keywords, &PyIUnit_Type, &Source, &PyIUnit_Type, &Target, &Damage)) {
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->CalcPhysicalDamage(Source_ptr, Target_ptr, Damage);
	py_retval = Py_BuildValue((char *) "d", retval);
	return py_retval;
}


PyObject *
_wrap_PyIDamage_CalcMixedDamage(PyIDamage *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	double retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	PyIUnit *Target;
	IUnit *Target_ptr;
	double PhysicalDamage;
	double MagicDamage;
	int MagicPct;
	int PhysicalPct;
	int TruePct;
	const char *keywords[] = { "Source", "Target", "PhysicalDamage", "MagicDamage", "MagicPct", "PhysicalPct", "TruePct", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!ddiii", (char **)keywords, &PyIUnit_Type, &Source, &PyIUnit_Type, &Target, &PhysicalDamage, &MagicDamage, &MagicPct, &PhysicalPct, &TruePct)) {
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->CalcMixedDamage(Source_ptr, Target_ptr, PhysicalDamage, MagicDamage, MagicPct, PhysicalPct, TruePct);
	py_retval = Py_BuildValue((char *) "d", retval);
	return py_retval;
}


PyObject *
_wrap_PyIDamage_GetSummonerSpellDamage(PyIDamage *self, PyObject *args, PyObject *kwargs)
{
	PyObject *py_retval;
	double retval;
	PyIUnit *Source;
	IUnit *Source_ptr;
	PyIUnit *Target;
	IUnit *Target_ptr;
	eSummonerSpell SummonerSpell;
	const char *keywords[] = { "Source", "Target", "SummonerSpell", NULL };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **)keywords, &PyIUnit_Type, &Source, &PyIUnit_Type, &Target, &SummonerSpell)) {
		return NULL;
	}
	Source_ptr = (Source ? Source->obj : NULL);
	Target_ptr = (Target ? Target->obj : NULL);
	retval = self->obj->GetSummonerSpellDamage(Source_ptr, Target_ptr, SummonerSpell);
	py_retval = Py_BuildValue((char *) "d", retval);
	return py_retval;
}

static PyMethodDef PyIDamage_methods[] = {
	{ (char *) "GetAutoAttackDamage", (PyCFunction)_wrap_PyIDamage_GetAutoAttackDamage, METH_KEYWORDS | METH_VARARGS, "GetAutoAttackDamage(Source, Target, Use_Passives)\n\ntype: Source: IUnit *\ntype: Target: IUnit *\ntype: Use_Passives: bool" },
	{ (char *) "CalcMagicDamage", (PyCFunction)_wrap_PyIDamage_CalcMagicDamage, METH_KEYWORDS | METH_VARARGS, "CalcMagicDamage(Source, Target, Damage)\n\ntype: Source: IUnit *\ntype: Target: IUnit *\ntype: Damage: double" },
	{ (char *) "GetSpellDamage", (PyCFunction)_wrap_PyIDamage_GetSpellDamage, METH_KEYWORDS | METH_VARARGS, NULL },
	{ (char *) "CalcPhysicalDamage", (PyCFunction)_wrap_PyIDamage_CalcPhysicalDamage, METH_KEYWORDS | METH_VARARGS, "CalcPhysicalDamage(Source, Target, Damage)\n\ntype: Source: IUnit *\ntype: Target: IUnit *\ntype: Damage: double" },
	{ (char *) "CalcMixedDamage", (PyCFunction)_wrap_PyIDamage_CalcMixedDamage, METH_KEYWORDS | METH_VARARGS, "CalcMixedDamage(Source, Target, PhysicalDamage, MagicDamage, MagicPct, PhysicalPct, TruePct)\n\ntype: Source: IUnit *\ntype: Target: IUnit *\ntype: PhysicalDamage: double\ntype: MagicDamage: double\ntype: MagicPct: int\ntype: PhysicalPct: int\ntype: TruePct: int" },
	{ (char *) "GetSummonerSpellDamage", (PyCFunction)_wrap_PyIDamage_GetSummonerSpellDamage, METH_KEYWORDS | METH_VARARGS, "GetSummonerSpellDamage(Source, Target, SummonerSpell)\n\ntype: Source: IUnit *\ntype: Target: IUnit *\ntype: SummonerSpell: eSummonerSpell" },
	{ NULL, NULL, 0, NULL }
};

static void
_wrap_PyIDamage__tp_dealloc(PyIDamage *self)
{

	Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyIDamage__tp_richcompare(PyIDamage *PYBINDGEN_UNUSED(self), PyIDamage *other, int opid)
{

	if (!PyObject_IsInstance((PyObject*)other, (PyObject*)&PyIDamage_Type)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
	switch (opid)
	{
	case Py_LT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_LE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_EQ:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_NE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GE:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	case Py_GT:
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	} /* closes switch (opid) */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}

PyTypeObject PyIDamage_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.IDamage",            /* tp_name */
	sizeof(PyIDamage),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_PyIDamage__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	"",                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)_wrap_PyIDamage__tp_richcompare,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)NULL,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)PyIDamage_methods, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	0,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_PyIDamage__tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};


/* --- containers --- */



static void
Pystd__vector__lt__Vec2__gt__Iter__tp_clear(Pystd__vector__lt__Vec2__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

}


static int
Pystd__vector__lt__Vec2__gt__Iter__tp_traverse(Pystd__vector__lt__Vec2__gt__Iter *self, visitproc visit, void *arg)
{
	Py_VISIT((PyObject *)self->container);
	return 0;
}


static void
_wrap_Pystd__vector__lt__Vec2__gt____tp_dealloc(Pystd__vector__lt__Vec2__gt__ *self)
{
	delete self->obj;
	self->obj = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__Vec2__gt__Iter__tp_dealloc(Pystd__vector__lt__Vec2__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__Vec2__gt____tp_iter(Pystd__vector__lt__Vec2__gt__ *self)
{
	Pystd__vector__lt__Vec2__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__Vec2__gt__Iter, &Pystd__vector__lt__Vec2__gt__Iter_Type);
	Py_INCREF(self);
	iter->container = self;
	iter->iterator = new std::vector<Vec2>::iterator(self->obj->begin());
	return (PyObject*)iter;
}


static PyObject*
_wrap_Pystd__vector__lt__Vec2__gt__Iter__tp_iter(Pystd__vector__lt__Vec2__gt__Iter *self)
{
	Py_INCREF(self);
	return (PyObject*)self;
}

static PyObject* _wrap_Pystd__vector__lt__Vec2__gt__Iter__tp_iternext(Pystd__vector__lt__Vec2__gt__Iter *self)
{
	PyObject *py_retval;
	std::vector<Vec2>::iterator iter;
	PyVec2 *py_Vec2;

	iter = *self->iterator;
	if (iter == self->container->obj->end()) {
		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	++(*self->iterator);
	py_Vec2 = PyObject_New(PyVec2, &PyVec2_Type);
	py_Vec2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec2->obj = new Vec2((*iter));
	py_retval = Py_BuildValue((char *) "N", py_Vec2);
	return py_retval;
}

int _wrap_convert_py2c__std__vector__lt___Vec2___gt__(PyObject *arg, std::vector<Vec2> *container)
{
	if (PyObject_IsInstance(arg, (PyObject*)&Pystd__vector__lt__Vec2__gt___Type)) {
		*container = *((Pystd__vector__lt__Vec2__gt__*)arg)->obj;
	}
	else if (PyList_Check(arg)) {
		container->clear();
		Py_ssize_t size = PyList_Size(arg);
		for (Py_ssize_t i = 0; i < size; i++) {
			Vec2 item;
			if (!_wrap_convert_py2c__Vec2(PyList_GET_ITEM(arg, i), &item)) {
				return 0;
			}
			container->push_back(item);
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError, "parameter must be None, a VecVec2 instance, or a list of Vec2");
		return 0;
	}
	return 1;
}


static int
_wrap_Pystd__vector__lt__Vec2__gt____tp_init(Pystd__vector__lt__Vec2__gt__ *self, PyObject *args, PyObject *kwargs)
{
	const char *keywords[] = { "arg", NULL };
	PyObject *arg = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **)keywords, &arg)) {
		return -1;
	}

	self->obj = new std::vector<Vec2>;

	if (arg == NULL)
		return 0;

	if (!_wrap_convert_py2c__std__vector__lt___Vec2___gt__(arg, self->obj)) {
		delete self->obj;
		self->obj = NULL;
		return -1;
	}
	return 0;
}

PyTypeObject Pystd__vector__lt__Vec2__gt___Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecVec2",            /* tp_name */
	sizeof(Pystd__vector__lt__Vec2__gt__),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__Vec2__gt____tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__Vec2__gt____tp_iter,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_Pystd__vector__lt__Vec2__gt____tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__Vec2__gt__Iter_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecVec2Iter",            /* tp_name */
	sizeof(Pystd__vector__lt__Vec2__gt__Iter),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__Vec2__gt__Iter__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)Pystd__vector__lt__Vec2__gt__Iter__tp_traverse,     /* tp_traverse */
	(inquiry)Pystd__vector__lt__Vec2__gt__Iter__tp_clear,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__Vec2__gt__Iter__tp_iter,          /* tp_iter */
	(iternextfunc)_wrap_Pystd__vector__lt__Vec2__gt__Iter__tp_iternext,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)NULL,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static void
Pystd__vector__lt__Vec3__gt__Iter__tp_clear(Pystd__vector__lt__Vec3__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

}


static int
Pystd__vector__lt__Vec3__gt__Iter__tp_traverse(Pystd__vector__lt__Vec3__gt__Iter *self, visitproc visit, void *arg)
{
	Py_VISIT((PyObject *)self->container);
	return 0;
}


static void
_wrap_Pystd__vector__lt__Vec3__gt____tp_dealloc(Pystd__vector__lt__Vec3__gt__ *self)
{
	delete self->obj;
	self->obj = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__Vec3__gt__Iter__tp_dealloc(Pystd__vector__lt__Vec3__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__Vec3__gt____tp_iter(Pystd__vector__lt__Vec3__gt__ *self)
{
	Pystd__vector__lt__Vec3__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__Vec3__gt__Iter, &Pystd__vector__lt__Vec3__gt__Iter_Type);
	Py_INCREF(self);
	iter->container = self;
	iter->iterator = new std::vector<Vec3>::iterator(self->obj->begin());
	return (PyObject*)iter;
}


static PyObject*
_wrap_Pystd__vector__lt__Vec3__gt__Iter__tp_iter(Pystd__vector__lt__Vec3__gt__Iter *self)
{
	Py_INCREF(self);
	return (PyObject*)self;
}

static PyObject* _wrap_Pystd__vector__lt__Vec3__gt__Iter__tp_iternext(Pystd__vector__lt__Vec3__gt__Iter *self)
{
	PyObject *py_retval;
	std::vector<Vec3>::iterator iter;
	PyVec3 *py_Vec3;

	iter = *self->iterator;
	if (iter == self->container->obj->end()) {
		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	++(*self->iterator);
	py_Vec3 = PyObject_New(PyVec3, &PyVec3_Type);
	py_Vec3->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_Vec3->obj = new Vec3((*iter));
	py_retval = Py_BuildValue((char *) "N", py_Vec3);
	return py_retval;
}

int _wrap_convert_py2c__std__vector__lt___Vec3___gt__(PyObject *arg, std::vector<Vec3> *container)
{
	if (PyObject_IsInstance(arg, (PyObject*)&Pystd__vector__lt__Vec3__gt___Type)) {
		*container = *((Pystd__vector__lt__Vec3__gt__*)arg)->obj;
	}
	else if (PyList_Check(arg)) {
		container->clear();
		Py_ssize_t size = PyList_Size(arg);
		for (Py_ssize_t i = 0; i < size; i++) {
			Vec3 item;
			if (!_wrap_convert_py2c__Vec3(PyList_GET_ITEM(arg, i), &item)) {
				return 0;
			}
			container->push_back(item);
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError, "parameter must be None, a VecVec3 instance, or a list of Vec3");
		return 0;
	}
	return 1;
}


static int
_wrap_Pystd__vector__lt__Vec3__gt____tp_init(Pystd__vector__lt__Vec3__gt__ *self, PyObject *args, PyObject *kwargs)
{
	const char *keywords[] = { "arg", NULL };
	PyObject *arg = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **)keywords, &arg)) {
		return -1;
	}

	self->obj = new std::vector<Vec3>;

	if (arg == NULL)
		return 0;

	if (!_wrap_convert_py2c__std__vector__lt___Vec3___gt__(arg, self->obj)) {
		delete self->obj;
		self->obj = NULL;
		return -1;
	}
	return 0;
}

PyTypeObject Pystd__vector__lt__Vec3__gt___Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecVec3",            /* tp_name */
	sizeof(Pystd__vector__lt__Vec3__gt__),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__Vec3__gt____tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__Vec3__gt____tp_iter,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_Pystd__vector__lt__Vec3__gt____tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__Vec3__gt__Iter_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecVec3Iter",            /* tp_name */
	sizeof(Pystd__vector__lt__Vec3__gt__Iter),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__Vec3__gt__Iter__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)Pystd__vector__lt__Vec3__gt__Iter__tp_traverse,     /* tp_traverse */
	(inquiry)Pystd__vector__lt__Vec3__gt__Iter__tp_clear,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__Vec3__gt__Iter__tp_iter,          /* tp_iter */
	(iternextfunc)_wrap_Pystd__vector__lt__Vec3__gt__Iter__tp_iternext,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)NULL,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static void
Pystd__vector__lt__IUnit__star____gt__Iter__tp_clear(Pystd__vector__lt__IUnit__star____gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

}


static int
Pystd__vector__lt__IUnit__star____gt__Iter__tp_traverse(Pystd__vector__lt__IUnit__star____gt__Iter *self, visitproc visit, void *arg)
{
	Py_VISIT((PyObject *)self->container);
	return 0;
}


static void
_wrap_Pystd__vector__lt__IUnit__star____gt____tp_dealloc(Pystd__vector__lt__IUnit__star____gt__ *self)
{
	delete self->obj;
	self->obj = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__IUnit__star____gt__Iter__tp_dealloc(Pystd__vector__lt__IUnit__star____gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__IUnit__star____gt____tp_iter(Pystd__vector__lt__IUnit__star____gt__ *self)
{
	Pystd__vector__lt__IUnit__star____gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__IUnit__star____gt__Iter, &Pystd__vector__lt__IUnit__star____gt__Iter_Type);
	Py_INCREF(self);
	iter->container = self;
	iter->iterator = new std::vector<IUnit*>::iterator(self->obj->begin());
	return (PyObject*)iter;
}


static PyObject*
_wrap_Pystd__vector__lt__IUnit__star____gt__Iter__tp_iter(Pystd__vector__lt__IUnit__star____gt__Iter *self)
{
	Py_INCREF(self);
	return (PyObject*)self;
}

static PyObject* _wrap_Pystd__vector__lt__IUnit__star____gt__Iter__tp_iternext(Pystd__vector__lt__IUnit__star____gt__Iter *self)
{
	PyObject *py_retval;
	std::vector<IUnit*>::iterator iter;
	PyIUnit *py_IUnit;

	iter = *self->iterator;
	if (iter == self->container->obj->end()) {
		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	++(*self->iterator);
	if (!((*iter))) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	py_IUnit = PyObject_New(PyIUnit, &PyIUnit_Type);
	py_IUnit->obj = (*iter);
	py_IUnit->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_retval = Py_BuildValue((char *) "N", py_IUnit);
	return py_retval;
}

int _wrap_convert_py2c__IUnit___star__(PyObject *value, IUnit * *address)
{
	PyObject *py_retval;
	PyIUnit *tmp_IUnit;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIUnit_Type, &tmp_IUnit)) {
		Py_DECREF(py_retval);
		return 0;
	}
	*address = tmp_IUnit->obj;
	tmp_IUnit->obj = NULL;
	Py_DECREF(py_retval);
	return 1;
}


int _wrap_convert_py2c__std__vector__lt___IUnit___star_____gt__(PyObject *arg, std::vector<IUnit*> *container)
{
	if (PyObject_IsInstance(arg, (PyObject*)&Pystd__vector__lt__IUnit__star____gt___Type)) {
		*container = *((Pystd__vector__lt__IUnit__star____gt__*)arg)->obj;
	}
	else if (PyList_Check(arg)) {
		container->clear();
		Py_ssize_t size = PyList_Size(arg);
		for (Py_ssize_t i = 0; i < size; i++) {
			IUnit * item;
			if (!_wrap_convert_py2c__IUnit___star__(PyList_GET_ITEM(arg, i), &item)) {
				return 0;
			}
			container->push_back(item);
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError, "parameter must be None, a VecIUnit instance, or a list of IUnit *");
		return 0;
	}
	return 1;
}


static int
_wrap_Pystd__vector__lt__IUnit__star____gt____tp_init(Pystd__vector__lt__IUnit__star____gt__ *self, PyObject *args, PyObject *kwargs)
{
	const char *keywords[] = { "arg", NULL };
	PyObject *arg = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **)keywords, &arg)) {
		return -1;
	}

	self->obj = new std::vector<IUnit*>;

	if (arg == NULL)
		return 0;

	if (!_wrap_convert_py2c__std__vector__lt___IUnit___star_____gt__(arg, self->obj)) {
		delete self->obj;
		self->obj = NULL;
		return -1;
	}
	return 0;
}

PyTypeObject Pystd__vector__lt__IUnit__star____gt___Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecIUnit",            /* tp_name */
	sizeof(Pystd__vector__lt__IUnit__star____gt__),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__IUnit__star____gt____tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__IUnit__star____gt____tp_iter,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_Pystd__vector__lt__IUnit__star____gt____tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__IUnit__star____gt__Iter_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecIUnitIter",            /* tp_name */
	sizeof(Pystd__vector__lt__IUnit__star____gt__Iter),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__IUnit__star____gt__Iter__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)Pystd__vector__lt__IUnit__star____gt__Iter__tp_traverse,     /* tp_traverse */
	(inquiry)Pystd__vector__lt__IUnit__star____gt__Iter__tp_clear,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__IUnit__star____gt__Iter__tp_iter,          /* tp_iter */
	(iternextfunc)_wrap_Pystd__vector__lt__IUnit__star____gt__Iter__tp_iternext,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)NULL,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static void
Pystd__vector__lt__ItemData__gt__Iter__tp_clear(Pystd__vector__lt__ItemData__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

}


static int
Pystd__vector__lt__ItemData__gt__Iter__tp_traverse(Pystd__vector__lt__ItemData__gt__Iter *self, visitproc visit, void *arg)
{
	Py_VISIT((PyObject *)self->container);
	return 0;
}


static void
_wrap_Pystd__vector__lt__ItemData__gt____tp_dealloc(Pystd__vector__lt__ItemData__gt__ *self)
{
	delete self->obj;
	self->obj = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__ItemData__gt__Iter__tp_dealloc(Pystd__vector__lt__ItemData__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__ItemData__gt____tp_iter(Pystd__vector__lt__ItemData__gt__ *self)
{
	Pystd__vector__lt__ItemData__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__ItemData__gt__Iter, &Pystd__vector__lt__ItemData__gt__Iter_Type);
	Py_INCREF(self);
	iter->container = self;
	iter->iterator = new std::vector<ItemData>::iterator(self->obj->begin());
	return (PyObject*)iter;
}


static PyObject*
_wrap_Pystd__vector__lt__ItemData__gt__Iter__tp_iter(Pystd__vector__lt__ItemData__gt__Iter *self)
{
	Py_INCREF(self);
	return (PyObject*)self;
}

static PyObject* _wrap_Pystd__vector__lt__ItemData__gt__Iter__tp_iternext(Pystd__vector__lt__ItemData__gt__Iter *self)
{
	PyObject *py_retval;
	std::vector<ItemData>::iterator iter;
	PyItemData *py_ItemData;

	iter = *self->iterator;
	if (iter == self->container->obj->end()) {
		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	++(*self->iterator);
	py_ItemData = PyObject_New(PyItemData, &PyItemData_Type);
	py_ItemData->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_ItemData->obj = new ItemData((*iter));
	py_retval = Py_BuildValue((char *) "N", py_ItemData);
	return py_retval;
}

int _wrap_convert_py2c__ItemData(PyObject *value, ItemData *address)
{
	PyObject *py_retval;
	PyItemData *tmp_ItemData;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyItemData_Type, &tmp_ItemData)) {
		Py_DECREF(py_retval);
		return 0;
	}
	*address = *tmp_ItemData->obj;
	Py_DECREF(py_retval);
	return 1;
}


int _wrap_convert_py2c__std__vector__lt___ItemData___gt__(PyObject *arg, std::vector<ItemData> *container)
{
	if (PyObject_IsInstance(arg, (PyObject*)&Pystd__vector__lt__ItemData__gt___Type)) {
		*container = *((Pystd__vector__lt__ItemData__gt__*)arg)->obj;
	}
	else if (PyList_Check(arg)) {
		container->clear();
		Py_ssize_t size = PyList_Size(arg);
		for (Py_ssize_t i = 0; i < size; i++) {
			ItemData item;
			if (!_wrap_convert_py2c__ItemData(PyList_GET_ITEM(arg, i), &item)) {
				return 0;
			}
			container->push_back(item);
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError, "parameter must be None, a VecItemData instance, or a list of ItemData");
		return 0;
	}
	return 1;
}


static int
_wrap_Pystd__vector__lt__ItemData__gt____tp_init(Pystd__vector__lt__ItemData__gt__ *self, PyObject *args, PyObject *kwargs)
{
	const char *keywords[] = { "arg", NULL };
	PyObject *arg = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **)keywords, &arg)) {
		return -1;
	}

	self->obj = new std::vector<ItemData>;

	if (arg == NULL)
		return 0;

	if (!_wrap_convert_py2c__std__vector__lt___ItemData___gt__(arg, self->obj)) {
		delete self->obj;
		self->obj = NULL;
		return -1;
	}
	return 0;
}

PyTypeObject Pystd__vector__lt__ItemData__gt___Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecItemData",            /* tp_name */
	sizeof(Pystd__vector__lt__ItemData__gt__),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__ItemData__gt____tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__ItemData__gt____tp_iter,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_Pystd__vector__lt__ItemData__gt____tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__ItemData__gt__Iter_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecItemDataIter",            /* tp_name */
	sizeof(Pystd__vector__lt__ItemData__gt__Iter),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__ItemData__gt__Iter__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)Pystd__vector__lt__ItemData__gt__Iter__tp_traverse,     /* tp_traverse */
	(inquiry)Pystd__vector__lt__ItemData__gt__Iter__tp_clear,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__ItemData__gt__Iter__tp_iter,          /* tp_iter */
	(iternextfunc)_wrap_Pystd__vector__lt__ItemData__gt__Iter__tp_iternext,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)NULL,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static void
Pystd__vector__lt__HeroMastery__gt__Iter__tp_clear(Pystd__vector__lt__HeroMastery__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

}


static int
Pystd__vector__lt__HeroMastery__gt__Iter__tp_traverse(Pystd__vector__lt__HeroMastery__gt__Iter *self, visitproc visit, void *arg)
{
	Py_VISIT((PyObject *)self->container);
	return 0;
}


static void
_wrap_Pystd__vector__lt__HeroMastery__gt____tp_dealloc(Pystd__vector__lt__HeroMastery__gt__ *self)
{
	delete self->obj;
	self->obj = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__HeroMastery__gt__Iter__tp_dealloc(Pystd__vector__lt__HeroMastery__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__HeroMastery__gt____tp_iter(Pystd__vector__lt__HeroMastery__gt__ *self)
{
	Pystd__vector__lt__HeroMastery__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__HeroMastery__gt__Iter, &Pystd__vector__lt__HeroMastery__gt__Iter_Type);
	Py_INCREF(self);
	iter->container = self;
	iter->iterator = new std::vector<HeroMastery>::iterator(self->obj->begin());
	return (PyObject*)iter;
}


static PyObject*
_wrap_Pystd__vector__lt__HeroMastery__gt__Iter__tp_iter(Pystd__vector__lt__HeroMastery__gt__Iter *self)
{
	Py_INCREF(self);
	return (PyObject*)self;
}

static PyObject* _wrap_Pystd__vector__lt__HeroMastery__gt__Iter__tp_iternext(Pystd__vector__lt__HeroMastery__gt__Iter *self)
{
	PyObject *py_retval;
	std::vector<HeroMastery>::iterator iter;
	PyHeroMastery *py_HeroMastery;

	iter = *self->iterator;
	if (iter == self->container->obj->end()) {
		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	++(*self->iterator);
	py_HeroMastery = PyObject_New(PyHeroMastery, &PyHeroMastery_Type);
	py_HeroMastery->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
	py_HeroMastery->obj = new HeroMastery((*iter));
	py_retval = Py_BuildValue((char *) "N", py_HeroMastery);
	return py_retval;
}

int _wrap_convert_py2c__HeroMastery(PyObject *value, HeroMastery *address)
{
	PyObject *py_retval;
	PyHeroMastery *tmp_HeroMastery;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyHeroMastery_Type, &tmp_HeroMastery)) {
		Py_DECREF(py_retval);
		return 0;
	}
	*address = *tmp_HeroMastery->obj;
	Py_DECREF(py_retval);
	return 1;
}


int _wrap_convert_py2c__std__vector__lt___HeroMastery___gt__(PyObject *arg, std::vector<HeroMastery> *container)
{
	if (PyObject_IsInstance(arg, (PyObject*)&Pystd__vector__lt__HeroMastery__gt___Type)) {
		*container = *((Pystd__vector__lt__HeroMastery__gt__*)arg)->obj;
	}
	else if (PyList_Check(arg)) {
		container->clear();
		Py_ssize_t size = PyList_Size(arg);
		for (Py_ssize_t i = 0; i < size; i++) {
			HeroMastery item;
			if (!_wrap_convert_py2c__HeroMastery(PyList_GET_ITEM(arg, i), &item)) {
				return 0;
			}
			container->push_back(item);
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError, "parameter must be None, a VecHeroMastery instance, or a list of HeroMastery");
		return 0;
	}
	return 1;
}


static int
_wrap_Pystd__vector__lt__HeroMastery__gt____tp_init(Pystd__vector__lt__HeroMastery__gt__ *self, PyObject *args, PyObject *kwargs)
{
	const char *keywords[] = { "arg", NULL };
	PyObject *arg = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **)keywords, &arg)) {
		return -1;
	}

	self->obj = new std::vector<HeroMastery>;

	if (arg == NULL)
		return 0;

	if (!_wrap_convert_py2c__std__vector__lt___HeroMastery___gt__(arg, self->obj)) {
		delete self->obj;
		self->obj = NULL;
		return -1;
	}
	return 0;
}

PyTypeObject Pystd__vector__lt__HeroMastery__gt___Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecHeroMastery",            /* tp_name */
	sizeof(Pystd__vector__lt__HeroMastery__gt__),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__HeroMastery__gt____tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__HeroMastery__gt____tp_iter,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_Pystd__vector__lt__HeroMastery__gt____tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__HeroMastery__gt__Iter_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecHeroMasteryIter",            /* tp_name */
	sizeof(Pystd__vector__lt__HeroMastery__gt__Iter),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__HeroMastery__gt__Iter__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)Pystd__vector__lt__HeroMastery__gt__Iter__tp_traverse,     /* tp_traverse */
	(inquiry)Pystd__vector__lt__HeroMastery__gt__Iter__tp_clear,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__HeroMastery__gt__Iter__tp_iter,          /* tp_iter */
	(iternextfunc)_wrap_Pystd__vector__lt__HeroMastery__gt__Iter__tp_iternext,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)NULL,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static void
Pystd__vector__lt__std__string__gt__Iter__tp_clear(Pystd__vector__lt__std__string__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

}


static int
Pystd__vector__lt__std__string__gt__Iter__tp_traverse(Pystd__vector__lt__std__string__gt__Iter *self, visitproc visit, void *arg)
{
	Py_VISIT((PyObject *)self->container);
	return 0;
}


static void
_wrap_Pystd__vector__lt__std__string__gt____tp_dealloc(Pystd__vector__lt__std__string__gt__ *self)
{
	delete self->obj;
	self->obj = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_dealloc(Pystd__vector__lt__std__string__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__std__string__gt____tp_iter(Pystd__vector__lt__std__string__gt__ *self)
{
	Pystd__vector__lt__std__string__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__std__string__gt__Iter, &Pystd__vector__lt__std__string__gt__Iter_Type);
	Py_INCREF(self);
	iter->container = self;
	iter->iterator = new std::vector<std::string>::iterator(self->obj->begin());
	return (PyObject*)iter;
}


static PyObject*
_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iter(Pystd__vector__lt__std__string__gt__Iter *self)
{
	Py_INCREF(self);
	return (PyObject*)self;
}

static PyObject* _wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iternext(Pystd__vector__lt__std__string__gt__Iter *self)
{
	PyObject *py_retval;
	std::vector<std::string>::iterator iter;

	iter = *self->iterator;
	if (iter == self->container->obj->end()) {
		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	++(*self->iterator);
	py_retval = Py_BuildValue((char *) "s#", ((*iter)).c_str(), ((*iter)).size());
	return py_retval;
}

int _wrap_convert_py2c__std__string(PyObject *value, std::string *address)
{
	PyObject *py_retval;
	const char *retval_ptr;
	Py_ssize_t retval_len;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "s#", &retval_ptr, &retval_len)) {
		Py_DECREF(py_retval);
		return 0;
	}
	*address = std::string(retval_ptr, retval_len);
	Py_DECREF(py_retval);
	return 1;
}


int _wrap_convert_py2c__std__vector__lt___std__string___gt__(PyObject *arg, std::vector<std::string> *container)
{
	if (PyObject_IsInstance(arg, (PyObject*)&Pystd__vector__lt__std__string__gt___Type)) {
		*container = *((Pystd__vector__lt__std__string__gt__*)arg)->obj;
	}
	else if (PyList_Check(arg)) {
		container->clear();
		Py_ssize_t size = PyList_Size(arg);
		for (Py_ssize_t i = 0; i < size; i++) {
			std::string item;
			if (!_wrap_convert_py2c__std__string(PyList_GET_ITEM(arg, i), &item)) {
				return 0;
			}
			container->push_back(item);
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError, "parameter must be None, a VecString instance, or a list of std::string");
		return 0;
	}
	return 1;
}


static int
_wrap_Pystd__vector__lt__std__string__gt____tp_init(Pystd__vector__lt__std__string__gt__ *self, PyObject *args, PyObject *kwargs)
{
	const char *keywords[] = { "arg", NULL };
	PyObject *arg = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **)keywords, &arg)) {
		return -1;
	}

	self->obj = new std::vector<std::string>;

	if (arg == NULL)
		return 0;

	if (!_wrap_convert_py2c__std__vector__lt___std__string___gt__(arg, self->obj)) {
		delete self->obj;
		self->obj = NULL;
		return -1;
	}
	return 0;
}

PyTypeObject Pystd__vector__lt__std__string__gt___Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecString",            /* tp_name */
	sizeof(Pystd__vector__lt__std__string__gt__),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__std__string__gt____tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__std__string__gt____tp_iter,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_Pystd__vector__lt__std__string__gt____tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__std__string__gt__Iter_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VecStringIter",            /* tp_name */
	sizeof(Pystd__vector__lt__std__string__gt__Iter),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)Pystd__vector__lt__std__string__gt__Iter__tp_traverse,     /* tp_traverse */
	(inquiry)Pystd__vector__lt__std__string__gt__Iter__tp_clear,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iter,          /* tp_iter */
	(iternextfunc)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iternext,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)NULL,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};




static void
Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_clear(Pystd__vector__lt__eGameObjectClassId__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

}


static int
Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_traverse(Pystd__vector__lt__eGameObjectClassId__gt__Iter *self, visitproc visit, void *arg)
{
	Py_VISIT((PyObject *)self->container);
	return 0;
}


static void
_wrap_Pystd__vector__lt__eGameObjectClassId__gt____tp_dealloc(Pystd__vector__lt__eGameObjectClassId__gt__ *self)
{
	delete self->obj;
	self->obj = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_dealloc(Pystd__vector__lt__eGameObjectClassId__gt__Iter *self)
{
	Py_CLEAR(self->container);
	delete self->iterator;
	self->iterator = NULL;

	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__eGameObjectClassId__gt____tp_iter(Pystd__vector__lt__eGameObjectClassId__gt__ *self)
{
	Pystd__vector__lt__eGameObjectClassId__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__eGameObjectClassId__gt__Iter, &Pystd__vector__lt__eGameObjectClassId__gt__Iter_Type);
	Py_INCREF(self);
	iter->container = self;
	iter->iterator = new std::vector<eGameObjectClassId>::iterator(self->obj->begin());
	return (PyObject*)iter;
}


static PyObject*
_wrap_Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_iter(Pystd__vector__lt__eGameObjectClassId__gt__Iter *self)
{
	Py_INCREF(self);
	return (PyObject*)self;
}

static PyObject* _wrap_Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_iternext(Pystd__vector__lt__eGameObjectClassId__gt__Iter *self)
{
	PyObject *py_retval;
	std::vector<eGameObjectClassId>::iterator iter;

	iter = *self->iterator;
	if (iter == self->container->obj->end()) {
		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	++(*self->iterator);
	py_retval = Py_BuildValue((char *) "i", (*iter));
	return py_retval;
}

int _wrap_convert_py2c__eGameObjectClassId(PyObject *value, eGameObjectClassId *address)
{
	PyObject *py_retval;

	py_retval = Py_BuildValue((char *) "(O)", value);
	if (!PyArg_ParseTuple(py_retval, (char *) "i", &*address)) {
		Py_DECREF(py_retval);
		return 0;
	}
	Py_DECREF(py_retval);
	return 1;
}


int _wrap_convert_py2c__std__vector__lt___eGameObjectClassId___gt__(PyObject *arg, std::vector<eGameObjectClassId> *container)
{
	if (PyObject_IsInstance(arg, (PyObject*)&Pystd__vector__lt__eGameObjectClassId__gt___Type)) {
		*container = *((Pystd__vector__lt__eGameObjectClassId__gt__*)arg)->obj;
	}
	else if (PyList_Check(arg)) {
		container->clear();
		Py_ssize_t size = PyList_Size(arg);
		for (Py_ssize_t i = 0; i < size; i++) {
			eGameObjectClassId item;
			if (!_wrap_convert_py2c__eGameObjectClassId(PyList_GET_ITEM(arg, i), &item)) {
				return 0;
			}
			container->push_back(item);
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError, "parameter must be None, a VeceGameObjectClassId instance, or a list of eGameObjectClassId");
		return 0;
	}
	return 1;
}


static int
_wrap_Pystd__vector__lt__eGameObjectClassId__gt____tp_init(Pystd__vector__lt__eGameObjectClassId__gt__ *self, PyObject *args, PyObject *kwargs)
{
	const char *keywords[] = { "arg", NULL };
	PyObject *arg = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **)keywords, &arg)) {
		return -1;
	}

	self->obj = new std::vector<eGameObjectClassId>;

	if (arg == NULL)
		return 0;

	if (!_wrap_convert_py2c__std__vector__lt___eGameObjectClassId___gt__(arg, self->obj)) {
		delete self->obj;
		self->obj = NULL;
		return -1;
	}
	return 0;
}

PyTypeObject Pystd__vector__lt__eGameObjectClassId__gt___Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VeceGameObjectClassId",            /* tp_name */
	sizeof(Pystd__vector__lt__eGameObjectClassId__gt__),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__eGameObjectClassId__gt____tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)NULL,     /* tp_traverse */
	(inquiry)NULL,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__eGameObjectClassId__gt____tp_iter,          /* tp_iter */
	(iternextfunc)NULL,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)_wrap_Pystd__vector__lt__eGameObjectClassId__gt____tp_init,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__eGameObjectClassId__gt__Iter_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	(char *) "SDK.VeceGameObjectClassIdIter",            /* tp_name */
	sizeof(Pystd__vector__lt__eGameObjectClassId__gt__Iter),                  /* tp_basicsize */
	0,                                 /* tp_itemsize */
									   /* methods */
	(destructor)_wrap_Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_dealloc,        /* tp_dealloc */
	(printfunc)0,                      /* tp_print */
	(getattrfunc)NULL,       /* tp_getattr */
	(setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
	NULL,
#else
	(cmpfunc)NULL,           /* tp_compare */
#endif
	(reprfunc)NULL,             /* tp_repr */
	(PyNumberMethods*)NULL,     /* tp_as_number */
	(PySequenceMethods*)NULL, /* tp_as_sequence */
	(PyMappingMethods*)NULL,   /* tp_as_mapping */
	(hashfunc)NULL,             /* tp_hash */
	(ternaryfunc)NULL,          /* tp_call */
	(reprfunc)NULL,              /* tp_str */
	(getattrofunc)NULL,     /* tp_getattro */
	(setattrofunc)NULL,     /* tp_setattro */
	(PyBufferProcs*)NULL,  /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
	NULL,                        /* Documentation string */
	(traverseproc)Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_traverse,     /* tp_traverse */
	(inquiry)Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_clear,             /* tp_clear */
	(richcmpfunc)NULL,   /* tp_richcompare */
	0,             /* tp_weaklistoffset */
	(getiterfunc)_wrap_Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_iter,          /* tp_iter */
	(iternextfunc)_wrap_Pystd__vector__lt__eGameObjectClassId__gt__Iter__tp_iternext,     /* tp_iternext */
	(struct PyMethodDef*)NULL, /* tp_methods */
	(struct PyMemberDef*)0,              /* tp_members */
	NULL,                     /* tp_getset */
	NULL,                              /* tp_base */
	NULL,                              /* tp_dict */
	(descrgetfunc)NULL,    /* tp_descr_get */
	(descrsetfunc)NULL,    /* tp_descr_set */
	0,                 /* tp_dictoffset */
	(initproc)NULL,             /* tp_init */
	(allocfunc)PyType_GenericAlloc,           /* tp_alloc */
	(newfunc)PyType_GenericNew,               /* tp_new */
	(freefunc)0,             /* tp_free */
	(inquiry)NULL,             /* tp_is_gc */
	NULL,                              /* tp_bases */
	NULL,                              /* tp_mro */
	NULL,                              /* tp_cache */
	NULL,                              /* tp_subclasses */
	NULL,                              /* tp_weaklist */
	(destructor)NULL                  /* tp_del */
};


/* --- enumerations --- */



























































#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef SDK_moduledef = {
	PyModuleDef_HEAD_INIT,
	"SDK",
	NULL,
	-1,
	SDK_functions,
};
#endif

#if PY_VERSION_HEX >= 0x03000000
#define MOD_ERROR NULL
//#define MOD_INIT(name) PyObject* PyInit_##name(void)
#define MOD_RETURN(val) val
#else
#define MOD_ERROR
//#define MOD_INIT(name) void init##name(void)
#define MOD_RETURN(val)
#endif
#if defined(__cplusplus)
extern "C"
#endif
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__((visibility("default")))
#endif

PyMODINIT_FUNC
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__((visibility("default")))
#endif
initSDK(void)
{
	PyObject *m;
#if PY_VERSION_HEX >= 0x03000000
	m = PyModule_Create(&SDK_moduledef);
#else
	m = Py_InitModule3((char *) "SDK", SDK_functions, NULL);
#endif
	if (m == NULL) {
		return MOD_ERROR;
	}
	/* Register the 'Vec2' class */
	if (PyType_Ready(&PyVec2_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "Vec2", (PyObject *)&PyVec2_Type);
	/* Register the 'Vec3' class */
	if (PyType_Ready(&PyVec3_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "Vec3", (PyObject *)&PyVec3_Type);
	/* Register the 'Vec4' class */
	if (PyType_Ready(&PyVec4_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "Vec4", (PyObject *)&PyVec4_Type);
	/* Register the 'IUnit' class */
	if (PyType_Ready(&PyIUnit_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IUnit", (PyObject *)&PyIUnit_Type);
	/* Register the 'CastedSpell' class */
	if (PyType_Ready(&PyCastedSpell_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "CastedSpell", (PyObject *)&PyCastedSpell_Type);
	/* Register the 'LastCastedSpellArgs' class */
	if (PyType_Ready(&PyLastCastedSpellArgs_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "LastCastedSpellArgs", (PyObject *)&PyLastCastedSpellArgs_Type);
	/* Register the 'NavigationPath' class */
	if (PyType_Ready(&PyNavigationPath_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "NavigationPath", (PyObject *)&PyNavigationPath_Type);
	/* Register the 'UnitDash' class */
	if (PyType_Ready(&PyUnitDash_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "UnitDash", (PyObject *)&PyUnitDash_Type);
	/* Register the 'OnTeleportArgs' class */
	if (PyType_Ready(&PyOnTeleportArgs_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "OnTeleportArgs", (PyObject *)&PyOnTeleportArgs_Type);
	/* Register the 'AdvPredictionInput' class */
	if (PyType_Ready(&PyAdvPredictionInput_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "AdvPredictionInput", (PyObject *)&PyAdvPredictionInput_Type);
	/* Register the 'AdvPredictionOutput' class */
	if (PyType_Ready(&PyAdvPredictionOutput_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "AdvPredictionOutput", (PyObject *)&PyAdvPredictionOutput_Type);
	/* Register the 'InterruptibleSpell' class */
	if (PyType_Ready(&PyInterruptibleSpell_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "InterruptibleSpell", (PyObject *)&PyInterruptibleSpell_Type);
	/* Register the 'GapCloserSpell' class */
	if (PyType_Ready(&PyGapCloserSpell_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "GapCloserSpell", (PyObject *)&PyGapCloserSpell_Type);
	/* Register the 'ItemData' class */
	if (PyType_Ready(&PyItemData_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "ItemData", (PyObject *)&PyItemData_Type);
	/* Register the 'JungleNotifyData' class */
	if (PyType_Ready(&PyJungleNotifyData_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "JungleNotifyData", (PyObject *)&PyJungleNotifyData_Type);
	/* Register the 'HeroMastery' class */
	if (PyType_Ready(&PyHeroMastery_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "HeroMastery", (PyObject *)&PyHeroMastery_Type);
	/* Register the 'ISpellBook' class */
	if (PyType_Ready(&PyISpellBook_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "ISpellBook", (PyObject *)&PyISpellBook_Type);
	/* Register the 'IFont' class */
	if (PyType_Ready(&PyIFont_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IFont", (PyObject *)&PyIFont_Type);
	/* Register the 'ITexture' class */
	if (PyType_Ready(&PyITexture_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "ITexture", (PyObject *)&PyITexture_Type);
	/* Register the 'IRender' class */
	if (PyType_Ready(&PyIRender_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IRender", (PyObject *)&PyIRender_Type);
	/* Register the 'ITargetSelector' class */
	if (PyType_Ready(&PyITargetSelector_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "ITargetSelector", (PyObject *)&PyITargetSelector_Type);
	/* Register the 'IPrediction' class */
	if (PyType_Ready(&PyIPrediction_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IPrediction", (PyObject *)&PyIPrediction_Type);
	/* Register the 'IMenuOption' class */
	if (PyType_Ready(&PyIMenuOption_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IMenuOption", (PyObject *)&PyIMenuOption_Type);
	/* Register the 'IMenu' class */
	if (PyType_Ready(&PyIMenu_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IMenu", (PyObject *)&PyIMenu_Type);
	/* Register the 'IHealthPrediction' class */
	if (PyType_Ready(&PyIHealthPrediction_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IHealthPrediction", (PyObject *)&PyIHealthPrediction_Type);
	/* Register the 'ISpell2' class */
	if (PyType_Ready(&PyISpell2_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "ISpell2", (PyObject *)&PyISpell2_Type);
	/* Register the 'IOrbwalking' class */
	if (PyType_Ready(&PyIOrbwalking_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IOrbwalking", (PyObject *)&PyIOrbwalking_Type);
	/* Register the 'IInventoryItem' class */
	if (PyType_Ready(&PyIInventoryItem_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IInventoryItem", (PyObject *)&PyIInventoryItem_Type);
	/* Register the 'IMissileData' class */
	if (PyType_Ready(&PyIMissileData_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IMissileData", (PyObject *)&PyIMissileData_Type);
	/* Register the 'INavMesh' class */
	if (PyType_Ready(&PyINavMesh_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "INavMesh", (PyObject *)&PyINavMesh_Type);
	/* Register the 'IUtility' class */
	if (PyType_Ready(&PyIUtility_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IUtility", (PyObject *)&PyIUtility_Type);
	/* Register the 'IPluginSDK' class */
	if (PyType_Ready(&PyIPluginSDK_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IPluginSDK", (PyObject *)&PyIPluginSDK_Type);
	/* Register the 'IEntityList' class */
	if (PyType_Ready(&PyIEntityList_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IEntityList", (PyObject *)&PyIEntityList_Type);
	/* Register the 'IGame' class */
	if (PyType_Ready(&PyIGame_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IGame", (PyObject *)&PyIGame_Type);
	/* Register the 'IDamage' class */
	if (PyType_Ready(&PyIDamage_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "IDamage", (PyObject *)&PyIDamage_Type);
	/* Register the 'std::vector<Vec2>' class */
	if (PyType_Ready(&Pystd__vector__lt__Vec2__gt___Type)) {
		return MOD_ERROR;
	}
	if (PyType_Ready(&Pystd__vector__lt__Vec2__gt__Iter_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "VecVec2", (PyObject *)&Pystd__vector__lt__Vec2__gt___Type);
	PyModule_AddObject(m, (char *) "VecVec2Iter", (PyObject *)&Pystd__vector__lt__Vec2__gt__Iter_Type);
	/* Register the 'std::vector<Vec3>' class */
	if (PyType_Ready(&Pystd__vector__lt__Vec3__gt___Type)) {
		return MOD_ERROR;
	}
	if (PyType_Ready(&Pystd__vector__lt__Vec3__gt__Iter_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "VecVec3", (PyObject *)&Pystd__vector__lt__Vec3__gt___Type);
	PyModule_AddObject(m, (char *) "VecVec3Iter", (PyObject *)&Pystd__vector__lt__Vec3__gt__Iter_Type);
	/* Register the 'std::vector<IUnit*>' class */
	if (PyType_Ready(&Pystd__vector__lt__IUnit__star____gt___Type)) {
		return MOD_ERROR;
	}
	if (PyType_Ready(&Pystd__vector__lt__IUnit__star____gt__Iter_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "VecIUnit", (PyObject *)&Pystd__vector__lt__IUnit__star____gt___Type);
	PyModule_AddObject(m, (char *) "VecIUnitIter", (PyObject *)&Pystd__vector__lt__IUnit__star____gt__Iter_Type);
	/* Register the 'std::vector<ItemData>' class */
	if (PyType_Ready(&Pystd__vector__lt__ItemData__gt___Type)) {
		return MOD_ERROR;
	}
	if (PyType_Ready(&Pystd__vector__lt__ItemData__gt__Iter_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "VecItemData", (PyObject *)&Pystd__vector__lt__ItemData__gt___Type);
	PyModule_AddObject(m, (char *) "VecItemDataIter", (PyObject *)&Pystd__vector__lt__ItemData__gt__Iter_Type);
	/* Register the 'std::vector<HeroMastery>' class */
	if (PyType_Ready(&Pystd__vector__lt__HeroMastery__gt___Type)) {
		return MOD_ERROR;
	}
	if (PyType_Ready(&Pystd__vector__lt__HeroMastery__gt__Iter_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "VecHeroMastery", (PyObject *)&Pystd__vector__lt__HeroMastery__gt___Type);
	PyModule_AddObject(m, (char *) "VecHeroMasteryIter", (PyObject *)&Pystd__vector__lt__HeroMastery__gt__Iter_Type);
	/* Register the 'std::vector<std::string>' class */
	if (PyType_Ready(&Pystd__vector__lt__std__string__gt___Type)) {
		return MOD_ERROR;
	}
	if (PyType_Ready(&Pystd__vector__lt__std__string__gt__Iter_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "VecString", (PyObject *)&Pystd__vector__lt__std__string__gt___Type);
	PyModule_AddObject(m, (char *) "VecStringIter", (PyObject *)&Pystd__vector__lt__std__string__gt__Iter_Type);
	/* Register the 'std::vector<eGameObjectClassId>' class */
	if (PyType_Ready(&Pystd__vector__lt__eGameObjectClassId__gt___Type)) {
		return MOD_ERROR;
	}
	if (PyType_Ready(&Pystd__vector__lt__eGameObjectClassId__gt__Iter_Type)) {
		return MOD_ERROR;
	}
	PyModule_AddObject(m, (char *) "VeceGameObjectClassId", (PyObject *)&Pystd__vector__lt__eGameObjectClassId__gt___Type);
	PyModule_AddObject(m, (char *) "VeceGameObjectClassIdIter", (PyObject *)&Pystd__vector__lt__eGameObjectClassId__gt__Iter_Type);
	PyModule_AddIntConstant(m, (char *) "kHitChanceCollision", kHitChanceCollision);
	PyModule_AddIntConstant(m, (char *) "kHitChanceOutOfRange", kHitChanceOutOfRange);
	PyModule_AddIntConstant(m, (char *) "kHitChanceImpossible", kHitChanceImpossible);
	PyModule_AddIntConstant(m, (char *) "kHitChanceLow", kHitChanceLow);
	PyModule_AddIntConstant(m, (char *) "kHitChanceMedium", kHitChanceMedium);
	PyModule_AddIntConstant(m, (char *) "kHitChanceHigh", kHitChanceHigh);
	PyModule_AddIntConstant(m, (char *) "kHitChanceVeryHigh", kHitChanceVeryHigh);
	PyModule_AddIntConstant(m, (char *) "kHitChanceDashing", kHitChanceDashing);
	PyModule_AddIntConstant(m, (char *) "kHitChanceImmobile", kHitChanceImmobile);
	PyModule_AddIntConstant(m, (char *) "kNeutralMinionCamp", kNeutralMinionCamp);
	PyModule_AddIntConstant(m, (char *) "kFollowerObject", kFollowerObject);
	PyModule_AddIntConstant(m, (char *) "kFollowerObjectWithLerpMovement", kFollowerObjectWithLerpMovement);
	PyModule_AddIntConstant(m, (char *) "kAIHeroClient", kAIHeroClient);
	PyModule_AddIntConstant(m, (char *) "kobj_AI_Marker", kobj_AI_Marker);
	PyModule_AddIntConstant(m, (char *) "kobj_AI_Minion", kobj_AI_Minion);
	PyModule_AddIntConstant(m, (char *) "kLevelPropAI", kLevelPropAI);
	PyModule_AddIntConstant(m, (char *) "kobj_AI_Turret", kobj_AI_Turret);
	PyModule_AddIntConstant(m, (char *) "kobj_AI_Base", kobj_AI_Base);
	PyModule_AddIntConstant(m, (char *) "kobj_GeneralParticleEmitter", kobj_GeneralParticleEmitter);
	PyModule_AddIntConstant(m, (char *) "kMissileClient", kMissileClient);
	PyModule_AddIntConstant(m, (char *) "kDrawFX", kDrawFX);
	PyModule_AddIntConstant(m, (char *) "kUnrevealedTarget", kUnrevealedTarget);
	PyModule_AddIntConstant(m, (char *) "kobj_Barracks", kobj_Barracks);
	PyModule_AddIntConstant(m, (char *) "kobj_BarracksDampener", kobj_BarracksDampener);
	PyModule_AddIntConstant(m, (char *) "kobj_Lake", kobj_Lake);
	PyModule_AddIntConstant(m, (char *) "kobj_AnimatedBuilding", kobj_AnimatedBuilding);
	PyModule_AddIntConstant(m, (char *) "kobj_Building", kobj_Building);
	PyModule_AddIntConstant(m, (char *) "kobj_Levelsizer", kobj_Levelsizer);
	PyModule_AddIntConstant(m, (char *) "kobj_NavPoint", kobj_NavPoint);
	PyModule_AddIntConstant(m, (char *) "kobj_SpawnPoint", kobj_SpawnPoint);
	PyModule_AddIntConstant(m, (char *) "kobj_LampBulb", kobj_LampBulb);
	PyModule_AddIntConstant(m, (char *) "kGrassObject", kGrassObject);
	PyModule_AddIntConstant(m, (char *) "kobj_HQ", kobj_HQ);
	PyModule_AddIntConstant(m, (char *) "kobj_InfoPoint", kobj_InfoPoint);
	PyModule_AddIntConstant(m, (char *) "kLevelPropGameObject", kLevelPropGameObject);
	PyModule_AddIntConstant(m, (char *) "kLevelPropSpawnerPoint", kLevelPropSpawnerPoint);
	PyModule_AddIntConstant(m, (char *) "kobj_Shop", kobj_Shop);
	PyModule_AddIntConstant(m, (char *) "kobj_Turret", kobj_Turret);
	PyModule_AddIntConstant(m, (char *) "Teleport_Teleport", Teleport_Teleport);
	PyModule_AddIntConstant(m, (char *) "Teleport_Recall", Teleport_Recall);
	PyModule_AddIntConstant(m, (char *) "Teleport_Shen", Teleport_Shen);
	PyModule_AddIntConstant(m, (char *) "Teleport_TwistedFate", Teleport_TwistedFate);
	PyModule_AddIntConstant(m, (char *) "Teleport_Unknown", Teleport_Unknown);
	PyModule_AddIntConstant(m, (char *) "Teleport_Start", Teleport_Start);
	PyModule_AddIntConstant(m, (char *) "Teleport_Abort", Teleport_Abort);
	PyModule_AddIntConstant(m, (char *) "Teleport_Finish", Teleport_Finish);
	PyModule_AddIntConstant(m, (char *) "kHexgun", kHexgun);
	PyModule_AddIntConstant(m, (char *) "kDfg", kDfg);
	PyModule_AddIntConstant(m, (char *) "kBotrk", kBotrk);
	PyModule_AddIntConstant(m, (char *) "kBilgewater", kBilgewater);
	PyModule_AddIntConstant(m, (char *) "kTiamat", kTiamat);
	PyModule_AddIntConstant(m, (char *) "kHydra", kHydra);
	PyModule_AddIntConstant(m, (char *) "kBlackFireTorch", kBlackFireTorch);
	PyModule_AddIntConstant(m, (char *) "kOdingVeils", kOdingVeils);
	PyModule_AddIntConstant(m, (char *) "kFrostQueenClaim", kFrostQueenClaim);
	PyModule_AddIntConstant(m, (char *) "kLiandrysTorment", kLiandrysTorment);
	PyModule_AddIntConstant(m, (char *) "kSummonerSpellIgnite", kSummonerSpellIgnite);
	PyModule_AddIntConstant(m, (char *) "kSummonerSpellSmite", kSummonerSpellSmite);
	PyModule_AddIntConstant(m, (char *) "kSlotQ", kSlotQ);
	PyModule_AddIntConstant(m, (char *) "kSlotW", kSlotW);
	PyModule_AddIntConstant(m, (char *) "kSlotE", kSlotE);
	PyModule_AddIntConstant(m, (char *) "kSlotR", kSlotR);
	PyModule_AddIntConstant(m, (char *) "kSummonerSlot1", kSummonerSlot1);
	PyModule_AddIntConstant(m, (char *) "kSummonerSlot2", kSummonerSlot2);
	PyModule_AddIntConstant(m, (char *) "kItem1", kItem1);
	PyModule_AddIntConstant(m, (char *) "kItem2", kItem2);
	PyModule_AddIntConstant(m, (char *) "kItem3", kItem3);
	PyModule_AddIntConstant(m, (char *) "kItem4", kItem4);
	PyModule_AddIntConstant(m, (char *) "kItem5", kItem5);
	PyModule_AddIntConstant(m, (char *) "kItem6", kItem6);
	PyModule_AddIntConstant(m, (char *) "kSlotTrinket", kSlotTrinket);
	PyModule_AddIntConstant(m, (char *) "kSlotRecall", kSlotRecall);
	PyModule_AddIntConstant(m, (char *) "kSlotUnknown", kSlotUnknown);
	PyModule_AddIntConstant(m, (char *) "BUFF_Internal", BUFF_Internal);
	PyModule_AddIntConstant(m, (char *) "BUFF_Aura", BUFF_Aura);
	PyModule_AddIntConstant(m, (char *) "BUFF_CombatEnchancer", BUFF_CombatEnchancer);
	PyModule_AddIntConstant(m, (char *) "BUFF_CombatDehancer", BUFF_CombatDehancer);
	PyModule_AddIntConstant(m, (char *) "BUFF_SpellShield", BUFF_SpellShield);
	PyModule_AddIntConstant(m, (char *) "BUFF_Stun", BUFF_Stun);
	PyModule_AddIntConstant(m, (char *) "BUFF_Invisibility", BUFF_Invisibility);
	PyModule_AddIntConstant(m, (char *) "BUFF_Silence", BUFF_Silence);
	PyModule_AddIntConstant(m, (char *) "BUFF_Taunt", BUFF_Taunt);
	PyModule_AddIntConstant(m, (char *) "BUFF_Polymorph", BUFF_Polymorph);
	PyModule_AddIntConstant(m, (char *) "BUFF_Slow", BUFF_Slow);
	PyModule_AddIntConstant(m, (char *) "BUFF_Snare", BUFF_Snare);
	PyModule_AddIntConstant(m, (char *) "BUFF_Damage", BUFF_Damage);
	PyModule_AddIntConstant(m, (char *) "BUFF_Heal", BUFF_Heal);
	PyModule_AddIntConstant(m, (char *) "BUFF_Haste", BUFF_Haste);
	PyModule_AddIntConstant(m, (char *) "BUFF_SpellImmunity", BUFF_SpellImmunity);
	PyModule_AddIntConstant(m, (char *) "BUFF_PhysicalImmunity", BUFF_PhysicalImmunity);
	PyModule_AddIntConstant(m, (char *) "BUFF_Invulnerability", BUFF_Invulnerability);
	PyModule_AddIntConstant(m, (char *) "BUFF_Sleep", BUFF_Sleep);
	PyModule_AddIntConstant(m, (char *) "BUFF_NearSight", BUFF_NearSight);
	PyModule_AddIntConstant(m, (char *) "BUFF_Frenzy", BUFF_Frenzy);
	PyModule_AddIntConstant(m, (char *) "BUFF_Fear", BUFF_Fear);
	PyModule_AddIntConstant(m, (char *) "BUFF_Charm", BUFF_Charm);
	PyModule_AddIntConstant(m, (char *) "BUFF_Poison", BUFF_Poison);
	PyModule_AddIntConstant(m, (char *) "BUFF_Suppression", BUFF_Suppression);
	PyModule_AddIntConstant(m, (char *) "BUFF_Blind", BUFF_Blind);
	PyModule_AddIntConstant(m, (char *) "BUFF_Counter", BUFF_Counter);
	PyModule_AddIntConstant(m, (char *) "BUFF_Shred", BUFF_Shred);
	PyModule_AddIntConstant(m, (char *) "BUFF_Flee", BUFF_Flee);
	PyModule_AddIntConstant(m, (char *) "BUFF_Knockup", BUFF_Knockup);
	PyModule_AddIntConstant(m, (char *) "BUFF_Knockback", BUFF_Knockback);
	PyModule_AddIntConstant(m, (char *) "BUFF_Disarm", BUFF_Disarm);
	PyModule_AddIntConstant(m, (char *) "State_CanAttack", State_CanAttack);
	PyModule_AddIntConstant(m, (char *) "State_CanCast", State_CanCast);
	PyModule_AddIntConstant(m, (char *) "State_CanMove", State_CanMove);
	PyModule_AddIntConstant(m, (char *) "State_Immovable", State_Immovable);
	PyModule_AddIntConstant(m, (char *) "State_RevealSpecificUnit", State_RevealSpecificUnit);
	PyModule_AddIntConstant(m, (char *) "State_Taunted", State_Taunted);
	PyModule_AddIntConstant(m, (char *) "State_Feared", State_Feared);
	PyModule_AddIntConstant(m, (char *) "State_Fleeing", State_Fleeing);
	PyModule_AddIntConstant(m, (char *) "State_Supressed", State_Supressed);
	PyModule_AddIntConstant(m, (char *) "State_Asleep", State_Asleep);
	PyModule_AddIntConstant(m, (char *) "State_NearSight", State_NearSight);
	PyModule_AddIntConstant(m, (char *) "State_Ghosted", State_Ghosted);
	PyModule_AddIntConstant(m, (char *) "State_GhostProof", State_GhostProof);
	PyModule_AddIntConstant(m, (char *) "State_Charmed", State_Charmed);
	PyModule_AddIntConstant(m, (char *) "Ready", Ready);
	PyModule_AddIntConstant(m, (char *) "NotReady", NotReady);
	PyModule_AddIntConstant(m, (char *) "NotLearned", NotLearned);
	PyModule_AddIntConstant(m, (char *) "Supressed", Supressed);
	PyModule_AddIntConstant(m, (char *) "Unknown16", Unknown16);
	PyModule_AddIntConstant(m, (char *) "Cooldown", Cooldown);
	PyModule_AddIntConstant(m, (char *) "NoMana", NoMana);
	PyModule_AddIntConstant(m, (char *) "Unknown128", Unknown128);
	PyModule_AddIntConstant(m, (char *) "UnableToCast", UnableToCast);
	PyModule_AddIntConstant(m, (char *) "kNeutral", kNeutral);
	PyModule_AddIntConstant(m, (char *) "kTeam1", kTeam1);
	PyModule_AddIntConstant(m, (char *) "kTeam2", kTeam2);
	PyModule_AddIntConstant(m, (char *) "FL_INVALID", FL_INVALID);
	PyModule_AddIntConstant(m, (char *) "FL_CREEP", FL_CREEP);
	PyModule_AddIntConstant(m, (char *) "FL_HERO", FL_HERO);
	PyModule_AddIntConstant(m, (char *) "FL_TURRET", FL_TURRET);
	PyModule_AddIntConstant(m, (char *) "FL_MISSILE", FL_MISSILE);
	PyModule_AddIntConstant(m, (char *) "kHoldPosition", kHoldPosition);
	PyModule_AddIntConstant(m, (char *) "kMoveTo", kMoveTo);
	PyModule_AddIntConstant(m, (char *) "kAttackUnit", kAttackUnit);
	PyModule_AddIntConstant(m, (char *) "kAutoAttackPet", kAutoAttackPet);
	PyModule_AddIntConstant(m, (char *) "kAutoAttack", kAutoAttack);
	PyModule_AddIntConstant(m, (char *) "kMovePet", kMovePet);
	PyModule_AddIntConstant(m, (char *) "kAttackTo", kAttackTo);
	PyModule_AddIntConstant(m, (char *) "kStop", kStop);
	PyModule_AddIntConstant(m, (char *) "kTargetCast", kTargetCast);
	PyModule_AddIntConstant(m, (char *) "kLineCast", kLineCast);
	PyModule_AddIntConstant(m, (char *) "kCircleCast", kCircleCast);
	PyModule_AddIntConstant(m, (char *) "kConeCast", kConeCast);
	PyModule_AddIntConstant(m, (char *) "kLastHitPrediction", kLastHitPrediction);
	PyModule_AddIntConstant(m, (char *) "kLaneClearPrediction", kLaneClearPrediction);
	PyModule_AddIntConstant(m, (char *) "kStaticMesh", kStaticMesh);
	PyModule_AddIntConstant(m, (char *) "kGrassMesh", kGrassMesh);
	PyModule_AddIntConstant(m, (char *) "kWallMesh", kWallMesh);
	PyModule_AddIntConstant(m, (char *) "kBuildingMesh", kBuildingMesh);
	PyModule_AddIntConstant(m, (char *) "kPropMesh", kPropMesh);
	PyModule_AddIntConstant(m, (char *) "kEventOrbwalkBeforeAttack", kEventOrbwalkBeforeAttack);
	PyModule_AddIntConstant(m, (char *) "kEventOrbwalkOnAttack", kEventOrbwalkOnAttack);
	PyModule_AddIntConstant(m, (char *) "kEventOrbwalkAfterAttack", kEventOrbwalkAfterAttack);
	PyModule_AddIntConstant(m, (char *) "kEventOrbwalkTargetChange", kEventOrbwalkTargetChange);
	PyModule_AddIntConstant(m, (char *) "kEventOrbwalkNonKillableMinion", kEventOrbwalkNonKillableMinion);
	PyModule_AddIntConstant(m, (char *) "kEventOnGameUpdate", kEventOnGameUpdate);
	PyModule_AddIntConstant(m, (char *) "kEventOnRender", kEventOnRender);
	PyModule_AddIntConstant(m, (char *) "kEventOnSpellCast", kEventOnSpellCast);
	PyModule_AddIntConstant(m, (char *) "kEventOnUnitDeath", kEventOnUnitDeath);
	PyModule_AddIntConstant(m, (char *) "kEventOnCreateObject", kEventOnCreateObject);
	PyModule_AddIntConstant(m, (char *) "kEventOnDestroyObject", kEventOnDestroyObject);
	PyModule_AddIntConstant(m, (char *) "kEventOnDoCast", kEventOnDoCast);
	PyModule_AddIntConstant(m, (char *) "kEventOnInterruptible", kEventOnInterruptible);
	PyModule_AddIntConstant(m, (char *) "kEventOnGapCloser", kEventOnGapCloser);
	PyModule_AddIntConstant(m, (char *) "kEventOnIssueOrder", kEventOnIssueOrder);
	PyModule_AddIntConstant(m, (char *) "kEventOnBuffAdd", kEventOnBuffAdd);
	PyModule_AddIntConstant(m, (char *) "kEventOnBuffRemove", kEventOnBuffRemove);
	PyModule_AddIntConstant(m, (char *) "kEventOnGameEnd", kEventOnGameEnd);
	PyModule_AddIntConstant(m, (char *) "kEventOnLevelUp", kEventOnLevelUp);
	PyModule_AddIntConstant(m, (char *) "kEventOnPreCast", kEventOnPreCast);
	PyModule_AddIntConstant(m, (char *) "kEventOrbwalkFindTarget", kEventOrbwalkFindTarget);
	PyModule_AddIntConstant(m, (char *) "kEventOnDash", kEventOnDash);
	PyModule_AddIntConstant(m, (char *) "kEventOnD3DPresent", kEventOnD3DPresent);
	PyModule_AddIntConstant(m, (char *) "kEventOnD3DPreReset", kEventOnD3DPreReset);
	PyModule_AddIntConstant(m, (char *) "kEventOnD3DPostReset", kEventOnD3DPostReset);
	PyModule_AddIntConstant(m, (char *) "kEventOnRenderBehindHud", kEventOnRenderBehindHud);
	PyModule_AddIntConstant(m, (char *) "kEventOnWndProc", kEventOnWndProc);
	PyModule_AddIntConstant(m, (char *) "kEventOnEnterVisible", kEventOnEnterVisible);
	PyModule_AddIntConstant(m, (char *) "kEventOnExitVisible", kEventOnExitVisible);
	PyModule_AddIntConstant(m, (char *) "kEventOnUpdateChargedSpell", kEventOnUpdateChargedSpell);
	PyModule_AddIntConstant(m, (char *) "kEventOnPlayAnimation", kEventOnPlayAnimation);
	PyModule_AddIntConstant(m, (char *) "kEventOnPauseAnimation", kEventOnPauseAnimation);
	PyModule_AddIntConstant(m, (char *) "kEventOnJungleNotification", kEventOnJungleNotification);
	PyModule_AddIntConstant(m, (char *) "kEventOnNewPath", kEventOnNewPath);
	PyModule_AddIntConstant(m, (char *) "kEventOnTeleport", kEventOnTeleport);
	PyModule_AddIntConstant(m, (char *) "QuickestKill", QuickestKill);
	PyModule_AddIntConstant(m, (char *) "ClosestPriority", ClosestPriority);
	PyModule_AddIntConstant(m, (char *) "ClosestToCursorPriority", ClosestToCursorPriority);
	PyModule_AddIntConstant(m, (char *) "LowestHealthPriority", LowestHealthPriority);
	PyModule_AddIntConstant(m, (char *) "MostStacks", MostStacks);
	PyModule_AddIntConstant(m, (char *) "MostAD", MostAD);
	PyModule_AddIntConstant(m, (char *) "MostAP", MostAP);
	PyModule_AddIntConstant(m, (char *) "LeastAttacks", LeastAttacks);
	PyModule_AddIntConstant(m, (char *) "LeastCasts", LeastCasts);
	PyModule_AddIntConstant(m, (char *) "TrueDamage", TrueDamage);
	PyModule_AddIntConstant(m, (char *) "PhysicalDamage", PhysicalDamage);
	PyModule_AddIntConstant(m, (char *) "SpellDamage", SpellDamage);
	PyModule_AddIntConstant(m, (char *) "kLowDanger", kLowDanger);
	PyModule_AddIntConstant(m, (char *) "kMediumDanger", kMediumDanger);
	PyModule_AddIntConstant(m, (char *) "kHighDanger", kHighDanger);
	PyModule_AddIntConstant(m, (char *) "kTeamUnknown", kTeamUnknown);
	PyModule_AddIntConstant(m, (char *) "kTeamOrder", kTeamOrder);
	PyModule_AddIntConstant(m, (char *) "kTeamChaos", kTeamChaos);
	PyModule_AddIntConstant(m, (char *) "kTeamNeutral", kTeamNeutral);
	PyModule_AddIntConstant(m, (char *) "kFontWeightThin", kFontWeightThin);
	PyModule_AddIntConstant(m, (char *) "kFontWeightNormal", kFontWeightNormal);
	PyModule_AddIntConstant(m, (char *) "kFontWeightBold", kFontWeightBold);
	PyModule_AddIntConstant(m, (char *) "kFontWeightHeavy", kFontWeightHeavy);
	PyModule_AddIntConstant(m, (char *) "kFontLocationNormal", kFontLocationNormal);
	PyModule_AddIntConstant(m, (char *) "kFontLocationCenterVertical", kFontLocationCenterVertical);
	PyModule_AddIntConstant(m, (char *) "kFontLocationCenterHorizontal", kFontLocationCenterHorizontal);
	PyModule_AddIntConstant(m, (char *) "kFontLocationCenter", kFontLocationCenter);
	PyModule_AddIntConstant(m, (char *) "kCollidesWithNothing", kCollidesWithNothing);
	PyModule_AddIntConstant(m, (char *) "kCollidesWithMinions", kCollidesWithMinions);
	PyModule_AddIntConstant(m, (char *) "kCollidesWithHeroes", kCollidesWithHeroes);
	PyModule_AddIntConstant(m, (char *) "kCollidesWithYasuoWall", kCollidesWithYasuoWall);
	PyModule_AddIntConstant(m, (char *) "kCollidesWithWalls", kCollidesWithWalls);
	PyModule_AddIntConstant(m, (char *) "kCollidesWithAllies", kCollidesWithAllies);
	PyModule_AddIntConstant(m, (char *) "kModeLastHit", kModeLastHit);
	PyModule_AddIntConstant(m, (char *) "kModeMixed", kModeMixed);
	PyModule_AddIntConstant(m, (char *) "kModeLaneClear", kModeLaneClear);
	PyModule_AddIntConstant(m, (char *) "kModeCombo", kModeCombo);
	PyModule_AddIntConstant(m, (char *) "kModeFreeze", kModeFreeze);
	PyModule_AddIntConstant(m, (char *) "kModeCustom", kModeCustom);
	PyModule_AddIntConstant(m, (char *) "kModeNone", kModeNone);
	PyModule_AddIntConstant(m, (char *) "kPingNormal", kPingNormal);
	PyModule_AddIntConstant(m, (char *) "kPingDanger", kPingDanger);
	PyModule_AddIntConstant(m, (char *) "kPingEnemyMissing", kPingEnemyMissing);
	PyModule_AddIntConstant(m, (char *) "kPingOnMyWay", kPingOnMyWay);
	PyModule_AddIntConstant(m, (char *) "kPingFallback", kPingFallback);
	PyModule_AddIntConstant(m, (char *) "kPingAssistMe", kPingAssistMe);
	PyModule_AddIntConstant(m, (char *) "kGameNormal", kGameNormal);
	PyModule_AddIntConstant(m, (char *) "kGameDominion", kGameDominion);
	PyModule_AddIntConstant(m, (char *) "kGameTutorial", kGameTutorial);
	PyModule_AddIntConstant(m, (char *) "kGameARAM", kGameARAM);
	PyModule_AddIntConstant(m, (char *) "kGameFirstBlood", kGameFirstBlood);
	PyModule_AddIntConstant(m, (char *) "kGameAscension", kGameAscension);
	PyModule_AddIntConstant(m, (char *) "kMapCrystalScar", kMapCrystalScar);
	PyModule_AddIntConstant(m, (char *) "kMapTwistedTreeline", kMapTwistedTreeline);
	PyModule_AddIntConstant(m, (char *) "kMapSummonersRift", kMapSummonersRift);
	PyModule_AddIntConstant(m, (char *) "kMapHowlingAbyss", kMapHowlingAbyss);
	PyModule_AddIntConstant(m, (char *) "kDance", kDance);
	PyModule_AddIntConstant(m, (char *) "kTaunt", kTaunt);
	PyModule_AddIntConstant(m, (char *) "kLaugh", kLaugh);
	PyModule_AddIntConstant(m, (char *) "kJoke", kJoke);
	PyModule_AddIntConstant(m, (char *) "kToggle", kToggle);
	return MOD_RETURN(m);
}